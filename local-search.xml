<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>手写Promise!!</title>
    <link href="/2023/09/18/%E6%89%8B%E5%86%99Promise/"/>
    <url>/2023/09/18/%E6%89%8B%E5%86%99Promise/</url>
    
    <content type="html"><![CDATA[<blockquote><p>原文 : <a href="https://juejin.cn/post/7269640045043777576">https://juejin.cn/post/7269640045043777576</a></p></blockquote><p>首先，<code>Promise</code>肯定是一个类，所以我们才可以<code>new</code>它，然后<code>Promise实例化</code>的时候给它传入一个回调我们叫它<code>executor</code>方法，Promise内部会<code>立即调用</code>这个<code>executor方法</code>，并且会传入<code>resolve</code>和<code>reject</code>两个函数作为调用参数，另外在Promise类的原型上应该提供一个<code>then</code>方法，它里面可以传入两个回调，分别为<code>Promise成功的回调</code>和<code>Promise失败的回调</code>。调用<code>resolve</code>后会走入<code>成功的回调中</code>，调用<code>reject</code>后会走入<code>失败的回调中</code>。</p><h3 id="初级版本Promise"><a href="#初级版本Promise" class="headerlink" title="初级版本Promise"></a>初级版本Promise</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PENDING</span> = <span class="hljs-string">&#x27;PENDING&#x27;</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">FULFILLED</span> = <span class="hljs-string">&#x27;FULFILLED&#x27;</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">REJECTED</span> = <span class="hljs-string">&#x27;REJECTED&#x27;</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Promise</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-literal">undefined</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = <span class="hljs-literal">undefined</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PENDING</span><br>    <span class="hljs-comment">// 定义两个数组解决异步调用resovle或者reject的问题</span><br>    <span class="hljs-comment">// 充当队列把then里边的回调存起来</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onResolvedCallbacks</span> = [];<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span> = [];<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">resolve</span> = (<span class="hljs-params">value</span>) =&gt; &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">FULFILLED</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onResolvedCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> <span class="hljs-title function_">fn</span>())<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">reject</span> = (<span class="hljs-params">reason</span>) =&gt; &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = reason<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">REJECTED</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> <span class="hljs-title function_">fn</span>())<br>      &#125;<br>    &#125;<br>    <span class="hljs-title function_">executor</span>(resolve, reject);<br>  &#125;<br>  <span class="hljs-title function_">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">FULFILLED</span>) &#123;<br>      onFulfilled &amp;&amp; <span class="hljs-title function_">onFulfilled</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>)<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">REJECTED</span>) &#123;<br>      onRejected &amp;&amp; <span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>)<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">onResolvedCallbacks</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">onFulfilled</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>)<br>      &#125;)<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>)<br>      &#125;)<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">Promise</span>;<br><br></code></pre></td></tr></table></figure><h3 id="链式调用Promise"><a href="#链式调用Promise" class="headerlink" title="链式调用Promise"></a>链式调用Promise</h3><blockquote><p>内部调用then方法时，返回了一个新的promise，并让这个新的promise接管了它下一个then方法。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PENDING</span> = <span class="hljs-string">&#x27;PENDING&#x27;</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">FULFILLED</span> = <span class="hljs-string">&#x27;FULFILLED&#x27;</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">REJECTED</span> = <span class="hljs-string">&#x27;REJECTED&#x27;</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Promise</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-literal">undefined</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = <span class="hljs-literal">undefined</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PENDING</span><br>    <span class="hljs-comment">// 定义两个数组解决异步调用resovle或者reject的问题</span><br>    <span class="hljs-comment">// 充当队列把then里边的回调存起来</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onResolvedCallbacks</span> = [];<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span> = [];<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">resolve</span> = (<span class="hljs-params">value</span>) =&gt; &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">FULFILLED</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onResolvedCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> <span class="hljs-title function_">fn</span>())<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">reject</span> = (<span class="hljs-params">reason</span>) =&gt; &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = reason<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">REJECTED</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> <span class="hljs-title function_">fn</span>())<br>      &#125;<br>    &#125;<br>    <span class="hljs-title function_">executor</span>(resolve, reject);<br>  &#125;<br>  <span class="hljs-title function_">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>) &#123;<br>    <span class="hljs-keyword">const</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">FULFILLED</span>) &#123;<br>        <span class="hljs-comment">// onFulfilled方法可能返回值或者promise</span><br>        <span class="hljs-keyword">const</span> x = <span class="hljs-title function_">onFulfilled</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>)<br>        <span class="hljs-title function_">resolvePromise</span>(promise2, x, resolve, reject)<br>      &#125;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">REJECTED</span>) &#123;<br>        <span class="hljs-comment">// onRejected方法可能返回值或者promise</span><br>        <span class="hljs-keyword">const</span> x = <span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>)<br>        <span class="hljs-title function_">resolvePromise</span>(promise2, x, resolve, reject)<br>      &#125;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onResolvedCallbacks</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-keyword">const</span> x = <span class="hljs-title function_">onFulfilled</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>)<br>          <span class="hljs-title function_">resolvePromise</span>(promise2, x, resolve, reject)<br>        &#125;)<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-keyword">const</span> x = <span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>)<br>          <span class="hljs-title function_">resolvePromise</span>(promise2, x, resolve, reject)<br>        &#125;)<br>      &#125;<br>    &#125;)<br>    <span class="hljs-keyword">return</span> promise2<br>  &#125;<br>&#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">Promise</span>;<br><br></code></pre></td></tr></table></figure><blockquote><p>这里最主要的就是<code>resolvePromise</code>，来看下它做了什么：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">resolvePromise</span>(<span class="hljs-params">promise2, x, resolve, reject</span>) &#123;<br>  <span class="hljs-keyword">if</span> (promise2 === x) &#123;<br>    <span class="hljs-comment">// 防止循环引用</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;UnhandledPromiseRejectionWarning: TypeError: Chaining cycle detected for promise #&lt;Promise&gt;&#x27;</span>))<br>  &#125;<br>  <span class="hljs-keyword">let</span> called;  <span class="hljs-comment">// 声明变量called，相当于加了一把锁，让promise只能调用一次成功或者失败回调，防止死循环。</span><br>  <span class="hljs-comment">// 判断x的类型 x是对象或函数才有可能是一个promise</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; x !== <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">const</span> then = x.<span class="hljs-property">then</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>        <span class="hljs-comment">// 只能认为它是一个promise</span><br>        then.<span class="hljs-title function_">call</span>(x, <span class="hljs-function">(<span class="hljs-params">y</span>) =&gt;</span> &#123;<br>          <span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span><br>          called = <span class="hljs-literal">true</span><br>          <span class="hljs-title function_">resolvePromise</span>(promise2, y, resolve, reject) <span class="hljs-comment">// 精髓, 递归解析</span><br>        &#125;, <span class="hljs-function">(<span class="hljs-params">r</span>) =&gt;</span> &#123;<br>          <span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span><br>          called = <span class="hljs-literal">true</span><br>          <span class="hljs-title function_">reject</span>(r)<br>        &#125;)<br>      &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(x)<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>      <span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span><br>      called = <span class="hljs-literal">true</span><br>      <span class="hljs-title function_">reject</span>(e)<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(x)<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>因为<code>promise</code>在<code>EventLoop</code>里面是个微任务，不过我们可以简单通过<code>setTimout</code>模拟。</p><p>然后我们再加上一些报错的捕获代码以及一些参数的兼容代码，以及实现<code>catch</code>方法。</p></blockquote><h3 id="完全版本Promise"><a href="#完全版本Promise" class="headerlink" title="完全版本Promise"></a>完全版本Promise</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PENDING</span> = <span class="hljs-string">&quot;PENDING&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">FULFILLED</span> = <span class="hljs-string">&quot;FULFILLED&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">REJECTED</span> = <span class="hljs-string">&quot;REJECTED&quot;</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Promise</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-literal">undefined</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = <span class="hljs-literal">undefined</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PENDING</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onResolvedCallbacks</span> = [];<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span> = [];<br><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">resolve</span> = (<span class="hljs-params">value</span>) =&gt; &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">FULFILLED</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onResolvedCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> <span class="hljs-title function_">fn</span>());<br>      &#125;<br>    &#125;;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">reject</span> = (<span class="hljs-params">reason</span>) =&gt; &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = reason;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">REJECTED</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> <span class="hljs-title function_">fn</span>());<br>      &#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-title function_">executor</span>(resolve, reject);<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>      <span class="hljs-title function_">reject</span>(e);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-title function_">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>) &#123;<br>    <span class="hljs-comment">// 这里兼容下 onFulfilled 和 onRejected 的传参</span><br>    onFulfilled = <span class="hljs-keyword">typeof</span> onFulfilled === <span class="hljs-string">&quot;function&quot;</span> ? onFulfilled : <span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> v;<br>    onRejected =<br>      <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">&quot;function&quot;</span><br>      ? onRejected<br>    : <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">throw</span> err;<br>    &#125;;<br>    <span class="hljs-keyword">const</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">FULFILLED</span>) &#123;<br>        <span class="hljs-comment">// 用 setTimeout 模拟异步</span><br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">const</span> x = <span class="hljs-title function_">onFulfilled</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>            <span class="hljs-title function_">resolvePromise</span>(promise2, x, resolve, reject);<br>          &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>            <span class="hljs-title function_">reject</span>(e);<br>          &#125;<br>        &#125;, <span class="hljs-number">0</span>);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">REJECTED</span>) &#123;<br>        <span class="hljs-comment">// 用 setTimeout 模拟异步</span><br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">const</span> x = <span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>);<br>            <span class="hljs-title function_">resolvePromise</span>(promise2, x, resolve, reject);<br>          &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>            <span class="hljs-title function_">reject</span>(e);<br>          &#125;<br>        &#125;, <span class="hljs-number">0</span>);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onResolvedCallbacks</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-comment">// 用 setTimeout 模拟异步</span><br>          <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>              <span class="hljs-keyword">const</span> x = <span class="hljs-title function_">onFulfilled</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>              <span class="hljs-title function_">resolvePromise</span>(promise2, x, resolve, reject);<br>            &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>              <span class="hljs-title function_">reject</span>(e);<br>            &#125;<br>          &#125;, <span class="hljs-number">0</span>);<br>        &#125;);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-comment">// 用 setTimeout 模拟异步</span><br>          <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>              <span class="hljs-keyword">const</span> x = <span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>);<br>              <span class="hljs-title function_">resolvePromise</span>(promise2, x, resolve, reject);<br>            &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>              <span class="hljs-title function_">reject</span>(e);<br>            &#125;<br>          &#125;, <span class="hljs-number">0</span>);<br>        &#125;);<br>      &#125;<br>    &#125;);<br><br>    <span class="hljs-keyword">return</span> promise2;<br>  &#125;<br>  <span class="hljs-comment">// catch函数实际上里面就是调用了then方法</span><br>  <span class="hljs-keyword">catch</span>(errCallback) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-literal">null</span>, errCallback);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 解决链式调用</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">resolvePromise</span>(<span class="hljs-params">promise2, x, resolve, reject</span>) &#123;<br>  <span class="hljs-keyword">if</span> (promise2 === x) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">reject</span>(<br>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<br>        <span class="hljs-string">&quot;UnhandledPromiseRejectionWarning: TypeError: Chaining cycle detected for promise #&lt;Promise&gt;&quot;</span><br>      )<br>    );<br>  &#125;<br>  <span class="hljs-keyword">let</span> called;<br>  <span class="hljs-comment">// 判断x的类型 x是对象或函数才有可能是一个promise</span><br>  <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&quot;object&quot;</span> &amp;&amp; x !== <span class="hljs-literal">null</span>) || <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">const</span> then = x.<span class="hljs-property">then</span>;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>        <span class="hljs-comment">// 只能认为它是一个promise</span><br>        then.<span class="hljs-title function_">call</span>(<br>          x,<br>          <span class="hljs-function">(<span class="hljs-params">y</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span>;<br>            called = <span class="hljs-literal">true</span>;<br>            <span class="hljs-title function_">resolvePromise</span>(promise2, y, resolve, reject);<br>          &#125;,<br>          <span class="hljs-function">(<span class="hljs-params">r</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span>;<br>            called = <span class="hljs-literal">true</span>;<br>            <span class="hljs-title function_">reject</span>(r);<br>          &#125;<br>        );<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(x);<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>      <span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span>;<br>      called = <span class="hljs-literal">true</span>;<br>      <span class="hljs-title function_">reject</span>(e);<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(x);<br>  &#125;<br>&#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">Promise</span>;<br></code></pre></td></tr></table></figure><h3 id="测试promise是否符合规范"><a href="#测试promise是否符合规范" class="headerlink" title="测试promise是否符合规范"></a>测试promise是否符合规范</h3><ol><li><p>首先安装依赖包 <code>npm i promises-aplus-tests -D</code></p></li><li><p>在我们的代码中添加</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">defer</span> = <span class="hljs-title class_">Promise</span>.<span class="hljs-property">deferred</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">let</span> dfd = &#123;&#125;;<br>  dfd.<span class="hljs-property">promise</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>      dfd.<span class="hljs-property">resolve</span> = resolve;<br>      dfd.<span class="hljs-property">reject</span> = reject;<br>  &#125;);<br>  <span class="hljs-keyword">return</span> dfd;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意别忘了 <code>module.exports = Promise;</code></p></blockquote></li><li><p>运行 <code>promises-aplus-tests 文件名</code> 即可</p></li><li><p>有872个测试用例，全部通过即可以认为这是一个标准的promise。</p></li></ol><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309181510458.png" alt="image-20230918151029374"></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手写函数</title>
    <link href="/2023/09/15/%E6%89%8B%E5%86%99%E5%87%BD%E6%95%B0/"/>
    <url>/2023/09/15/%E6%89%8B%E5%86%99%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="手写apply函数"><a href="#手写apply函数" class="headerlink" title="手写apply函数"></a>手写apply函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myApply</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">thisArg, otherArgs</span>) &#123;<br>    <span class="hljs-comment">// 确保 thisArg 不为 null 或 undefined，如果是，则默认为全局对象 window</span><br>    thisArg === (thisArg === <span class="hljs-literal">null</span> || thisArg === <span class="hljs-literal">undefined</span>) ? <span class="hljs-variable language_">window</span> : <span class="hljs-title class_">Object</span>(thisArg);<br><br>    <span class="hljs-comment">// 创建一个唯一的 Symbol 用于存储原函数</span><br>    <span class="hljs-keyword">const</span> fnKey = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;fn&#x27;</span>);<br><br>    <span class="hljs-comment">// 将原函数存储在 thisArg 对象的一个不可枚举属性中</span><br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(thisArg, fnKey, &#123;<br>        <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,   <span class="hljs-comment">// 不可枚举</span><br>        <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,  <span class="hljs-comment">// 可配置</span><br>        <span class="hljs-attr">value</span>: <span class="hljs-variable language_">this</span>          <span class="hljs-comment">// 原函数</span><br>    &#125;);<br><br>    <span class="hljs-comment">// 调用存储在 thisArg 对象中的原函数，并传递参数 otherArgs</span><br>    <span class="hljs-comment">// 只是说要通过thisArg来调用, thisArg[fnKey] 就是原函数</span><br>    thisArg[fnKey](...otherArgs);<br><br>    <span class="hljs-comment">// 删除存储在 thisArg 对象中的原函数，以防止污染原对象</span><br>    <span class="hljs-keyword">delete</span> thisArg[fnKey];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="手写bind函数"><a href="#手写bind函数" class="headerlink" title="手写bind函数"></a>手写bind函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hybind</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">thisArg, ...otherArgs</span>) &#123;<br>    <span class="hljs-comment">// 确保 thisArg 不是 null 或 undefined，如果是，则默认为全局对象 window</span><br>    thisArg = thisArg === <span class="hljs-literal">null</span> || thisArg === <span class="hljs-literal">undefined</span> ? <span class="hljs-variable language_">window</span> : <span class="hljs-title class_">Object</span>(thisArg);<br><br>    <span class="hljs-comment">// 创建一个唯一的 Symbol 作为属性名，用于存储原函数</span><br>    <span class="hljs-keyword">const</span> fnKey = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;fn&#x27;</span>);<br><br>    <span class="hljs-comment">// 使用 Object.defineProperty 方法将原函数存储在 thisArg 对象的属性中</span><br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(thisArg, fnKey, &#123;<br>        <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,   <span class="hljs-comment">// 不可枚举</span><br>        <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,  <span class="hljs-comment">// 可配置</span><br>        <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>,     <span class="hljs-comment">// 不可写</span><br>        <span class="hljs-attr">value</span>: <span class="hljs-variable language_">this</span>          <span class="hljs-comment">// 原函数</span><br>    &#125;);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...newArgs</span>) =&gt;</span> &#123;  <span class="hljs-comment">// 返回一个函数</span><br>        <span class="hljs-comment">// 创建一个合并了原参数和新参数的参数数组</span><br>        <span class="hljs-keyword">var</span> allArgs = [...otherArgs, ...newArgs];<br>        <br>        <span class="hljs-comment">// 调用存储在 thisArg 对象中的原函数，并传递合并后的参数数组</span><br>        thisArg[fnKey](...allArgs);<br>        <br>        <span class="hljs-comment">// 不需要删除 fnKey，因为下次调用还会使用它</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="手写柯里化函数"><a href="#手写柯里化函数" class="headerlink" title="手写柯里化函数"></a>手写柯里化函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">curring</span>(<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">cur</span>(<span class="hljs-params">...args</span>) &#123;<br>        <span class="hljs-keyword">if</span>(args.<span class="hljs-property">length</span> &gt;= fn.<span class="hljs-property">length</span>) &#123;<br>            <span class="hljs-comment">// 如果传入的参数数量达到了原函数 fn 的参数数量，执行原函数 fn 并返回结果</span><br>            <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果传入的参数数量不足，返回一个新的函数，用于接收更多参数</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...newArgs</span>) &#123;<br>                <span class="hljs-comment">// 将新传入的参数与之前的参数合并，递归调用 cur</span><br>                <span class="hljs-keyword">return</span> cur.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args.<span class="hljs-title function_">concat</span>(newArgs));<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 返回初始的 cur 函数</span><br>    <span class="hljs-keyword">return</span> cur;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="获取对象所有属性"><a href="#获取对象所有属性" class="headerlink" title="获取对象所有属性"></a>获取对象所有属性</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">inheritedPropertyNames</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">var</span> props = &#123;&#125;;<br>  <span class="hljs-keyword">while</span>(obj) &#123;<br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyNames</span>(obj).<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">p</span>) &#123;<br>      props[p] = <span class="hljs-literal">true</span>;<br>    &#125;);<br>    obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(obj);  <span class="hljs-comment">// 找原型链</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyNames</span>(props);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue响应式原理</title>
    <link href="/2023/09/12/Vue%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"/>
    <url>/2023/09/12/Vue%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="1-认识响应式逻辑"><a href="#1-认识响应式逻辑" class="headerlink" title="1. 认识响应式逻辑"></a>1. 认识响应式逻辑</h2><ul><li>假如你有一个变量m , 你的某一段代码使用了变量m , 如果某个时刻变量m发生了改变, 那么这段代码也会重新执行.</li><li>但实际上执行的代码中可能不止一行代码，所以我们可以将这些代码放到一个函数中, 于是就变成了, <strong>你有一个对象, 你的某个函数使用了对象的某个属性, 如果某个时候这个属性发生改变, 这个函数也会重新执行</strong></li></ul><h2 id="2-响应式依赖收集"><a href="#2-响应式依赖收集" class="headerlink" title="2. 响应式依赖收集"></a>2. 响应式依赖收集</h2><h3 id="2-1-响应式函数的实现watchFn"><a href="#2-1-响应式函数的实现watchFn" class="headerlink" title="2.1. 响应式函数的实现watchFn"></a>2.1. 响应式函数的实现watchFn</h3><p>我们现在实现一个响应式函数</p><p>◼ 但是我们怎么区分呢？</p><ul><li>这个时候我们封装一个新的函数<code>watchFn</code>；</li><li><strong>凡是传入到watchFn的函数，就是需要响应式的；</strong></li><li>其他默认定义的函数都是不需要响应式的；</li></ul><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927280.png" alt="img"></p><p>如图, foo以及bar都是需要响应式的</p><p>我们将这些函数在响应之前先执行一次</p><p>当obj的某个属性发生变化时, 就依次执行reactiveFns中的函数</p><p>目前当然是极为不完善, 待后续优化hhh</p><h3 id="2-2-响应式依赖的收集-类"><a href="#2-2-响应式依赖的收集-类" class="headerlink" title="2.2. 响应式依赖的收集__类"></a>2.2. 响应式依赖的收集__类</h3><p>◼ 目前我们收集的依赖是放到一个数组中来保存的，但是这里会存在数据管理的问题：</p><ul><li> 我们在实际开发中<strong>需要监听很多对象的响应式；</strong></li><li> 这些对象需要监听的不只是一个属性，它们很多属性的变化，都会有对应的响应式函数；</li><li> 我们不<strong>可能在全局维护一大堆的数组来保存这些响应函数；</strong></li></ul><p>◼ 所以我们要<strong>设计一个类，这个类用于管理某一个对象的某一个属性的所有响应式函数：</strong></p><ul><li> 相当于替代了原来的简单 reactiveFns 的数组；</li></ul><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927189.png" alt="img"></p><p>这个类记住</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927257.png" alt="img"></p><p>当我们某个属性发生变化时, 只需执行dep.notify()就行了, 无需一个一个的遍历函数</p><p>这个obj对象就对应Depend类所创建出来的对象</p><p>当然, 还需大大的优化</p><p>现在我们每次修改了一个属性之后都是手动的去调用, 这样太麻烦了, 我们想要让它自动去调用响应函数,</p><p>因此我们要去监听属性的变化</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="3-Object-defineProperty-监听属性变化"><a href="#3-Object-defineProperty-监听属性变化" class="headerlink" title="3. Object.defineProperty()监听属性变化"></a>3. Object.defineProperty()监听属性变化</h2><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927250.png" alt="img"></p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927238.png" alt="img"></p><p>再记一遍这个类</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927292.png" alt="img"></p><p>注意看注释</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927814.png" alt="img"></p><p>这里在属性变化后就不用手动给它通知了, 自动响应实现</p><p>不过这种收集方式其实是错误的hhhhh</p><h2 id="4-自动收集依赖-🔥"><a href="#4-自动收集依赖-🔥" class="headerlink" title="4. 自动收集依赖 🔥"></a>4. 自动收集依赖 🔥</h2><p>我们现在发现了一个问题 , obj 对象的两个属性都依赖于 同一个dep对象的reactiveFns,</p><p>这样就会造成我们根本没办法区分它们</p><p>对于同一个对象来说, 我们还是给它放到了同一个dep里面, 这会造成无法将它的属性区分</p><p><strong>如何解决这个问题呢 ?</strong> </p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927843.png" alt="img"></p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927050.png" alt="img"></p><p>比如我们要获取obj对象的name属性的依赖</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> dep = objMap.<span class="hljs-title function_">get</span>(obj).<span class="hljs-title function_">get</span>(name);<br>dep.<span class="hljs-title function_">notifiy</span>();<br></code></pre></td></tr></table></figure><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927155.png" alt="img"></p><ul><li><p>dep对象数据结构的管理</p></li><li><p>每一个对象的每一个属性都会对应一个dep对象</p></li><li><p>同一个对象的多个属性的dep对象是存放一个map对象中</p></li><li><p>多个对象的map对象, 会被存放到一个objMap的对象中</p></li><li><p>当执行get函数, 自动的添加fn函数</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Depend</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span> = []<br>  &#125;<br><br>  <span class="hljs-title function_">addDepend</span>(<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-keyword">if</span> (fn) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span>.<span class="hljs-title function_">push</span>(fn)<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-title function_">notify</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> &#123;<br>      <span class="hljs-title function_">fn</span>()<br>    &#125;)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span><br>&#125;<br><br><span class="hljs-comment">// 设置一个专门执行响应式函数的一个函数</span><br><span class="hljs-keyword">let</span> reactiveFn = <span class="hljs-literal">null</span> <span class="hljs-comment">// </span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">watchFn</span>(<span class="hljs-params">fn</span>) &#123;<br>  reactiveFn = fn<br>  <span class="hljs-title function_">fn</span>() <span class="hljs-comment">// 执行下方的get方法 , 使得间接的把函数加到特定的dep对象上</span><br>  <span class="hljs-comment">//(因为函数中会有一些对象会有一些属性)</span><br>  reactiveFn = <span class="hljs-literal">null</span> <span class="hljs-comment">// 使用完后再置为null, 不然可能会造成影响</span><br>&#125;<br><br><span class="hljs-comment">// 封装一个函数: 负责通过obj的key获取对应的Depend对象</span><br><span class="hljs-comment">// 我们用一个WeakMap对所有对象进行管理, 我们不需要对里面进行强引用, </span><br><span class="hljs-comment">// 如果有一天obj为null,那就无法销毁了</span><br><span class="hljs-keyword">const</span> objMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>()<br><br><br><span class="hljs-comment">// 这个函数的作用是通过对象的key找到它的dep对象</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getDepend</span>(<span class="hljs-params">obj, key</span>) &#123;<br>  <br>  <span class="hljs-comment">// 1.根据对象obj, 找到对应的map对象</span><br>  <span class="hljs-keyword">let</span> map = objMap.<span class="hljs-title function_">get</span>(obj) <span class="hljs-comment">// 没有就new一个</span><br>  <span class="hljs-keyword">if</span> (!map) &#123;<br>    map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br>    objMap.<span class="hljs-title function_">set</span>(obj, map)<br>  &#125;<br><br>  <span class="hljs-comment">// 2.根据key, 找到对应的depend对象</span><br>  <span class="hljs-keyword">let</span> dep = map.<span class="hljs-title function_">get</span>(key)<br>  <span class="hljs-keyword">if</span> (!dep) &#123;<br>    dep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Depend</span>()<br>    map.<span class="hljs-title function_">set</span>(key, dep)<br>  &#125;<br>  <span class="hljs-keyword">return</span> dep<br>&#125;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> value = obj[key]<br><br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, key, &#123;<br>    <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">newValue</span>) &#123;<br>      value = newValue<br>      <span class="hljs-comment">// 拿到这个对象的属性的dep对象</span><br>      <span class="hljs-keyword">const</span> dep = <span class="hljs-title function_">getDepend</span>(obj, key)<br>      dep.<span class="hljs-title function_">notify</span>()  <span class="hljs-comment">// 对这些</span><br>    &#125;,<br>    <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-comment">// 在函数中拿到obj 和 key 就会调用这个get方法</span><br>      <span class="hljs-comment">// console.log(&quot;get函数中:&quot;, obj, key)</span><br>      <span class="hljs-comment">// 找到对应的obj对象的key对应的dep对象</span><br>      <span class="hljs-keyword">const</span> dep = <span class="hljs-title function_">getDepend</span>(obj, key) <br>      <span class="hljs-comment">// 意味着我们只会创建obj对象的key属性的dep对象</span><br>      dep.<span class="hljs-title function_">addDepend</span>(reactiveFn) <br>      <span class="hljs-comment">// 精髓 : 在这个dep对象上放入跟特有对象的特有属性相关的函数,即reactiveFn</span><br>      <span class="hljs-comment">// dep这个对象就是保存了跟这个特有对象特有属性相关的一些函数</span><br>      <br>      <span class="hljs-keyword">return</span> value<br>    &#125;<br>  &#125;)<br>&#125;)<br><br><span class="hljs-title function_">watchFn</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;foo function&quot;</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;foo:&quot;</span>, obj.<span class="hljs-property">name</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;foo&quot;</span>, obj.<span class="hljs-property">age</span>)<br>&#125;)<br><br><span class="hljs-title function_">watchFn</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;bar function&quot;</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;bar:&quot;</span>, obj.<span class="hljs-property">age</span> + <span class="hljs-number">10</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>注意看注释 !!!!!</p><p>你用了我的数据, 我就收集你的依赖, 你没用, 我就不收集 —</p><p>我们还有可以优化的点 : </p><p>当我们执行下面这段代码时</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927937.png" alt="img"></p><p>age发生变化时, 它会执行两次函数</p><p>我们可以这样操作</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927105.png" alt="img"></p><p>我们的reactiveFns是一个Set, 这样它就不会添加相同的函数到这里面去</p><p>然后下方的push改为add</p><p>还有一个地方是我们可以给<img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927328.png" alt="img">这个地方换个写法</p><p>我们并不希望将reactiveFn添加放到get中，因为它是属于Dep的行为 (也可以不换, 看自己 )</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927511.png" alt="img"></p><p>我们直接在类中添加一个方法自动获取收集的函数<code>depend()</code></p><p>相当于利用到这个自由变量<code>reactiveFn</code></p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927495.png" alt="img"></p><p>然后直接<code>dep.depen()</code>调用即可</p><p>不过这两种写法都可以 hhh</p><p>但这个代码还有不足, 关于<strong>多个对象</strong>, 我们如何给它挨个来自动收集依赖, 因为我们这里是写死给obj对象自动收集依赖的</p><p>如何解决呢? </p><p>方法如下hhh —- 多个对象响应式</p><h2 id="5-多个对象响应式"><a href="#5-多个对象响应式" class="headerlink" title="5. 多个对象响应式"></a>5. 多个对象响应式</h2><p>我们只需要将监听对象属性的这一串代码封装为一个函数</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927710.png" alt="img"></p><p>这里我们将这一串代码封装为一个函数reactive, 我们创建的对象就可以作为参数传递进去, 那么这个对象的所有属性就能被监听到了, 然后我们<strong>返回一个被监听的对象</strong></p><p>注意 : 需要返回这个对象哈, 别搞忘了</p><p>然后我们在创建对象时使用这个函数, 那么对象的所有属性就能被监听到了</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927717.png" alt="img"></p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927766.png" alt="img"></p><p>以上都是vue2响应式原理(也就是defineProperty), 接下来我们用vue3对代码进行重构</p><p>特别easy</p><h2 id="6-vue3-监听对象-proxy"><a href="#6-vue3-监听对象-proxy" class="headerlink" title="6. vue3__监听对象__proxy"></a>6. vue3__监听对象__proxy</h2><p>我们直接将</p><p>Object.defineProperty</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927710.png" alt="img"></p><p>这部分代码改成</p><p>proxy</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927876.png" alt="img"></p><p>在我们调用了Proxy的get捕获器时, 收集依赖</p><p>因为如果一个函数中使用了某个对象的key，那么它应该被收集依赖；</p><p>这部分代码即可</p><p>都是学过的东西 , 忘了就翻翻前面的笔记 </p><h2 id="7-完整响应式代码"><a href="#7-完整响应式代码" class="headerlink" title="7. 完整响应式代码"></a>7. 完整响应式代码</h2><p>完整响应式代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Depend</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()<br>  &#125;<br><br>  <span class="hljs-title function_">addDepend</span>(<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-keyword">if</span> (fn) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span>.<span class="hljs-title function_">add</span>(fn)<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-title function_">depend</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (reactiveFn) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span>.<span class="hljs-title function_">add</span>(reactiveFn)<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-title function_">notify</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> &#123;<br>      <span class="hljs-title function_">fn</span>()<br>    &#125;)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> reactiveFn = <span class="hljs-literal">null</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">watchFn</span>(<span class="hljs-params">fn</span>) &#123;<br>  reactiveFn = fn<br>  <span class="hljs-title function_">fn</span>()<br>  reactiveFn = <span class="hljs-literal">null</span><br>&#125;<br><br><span class="hljs-keyword">const</span> objMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>()<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getDepend</span>(<span class="hljs-params">obj, key</span>) &#123;<br>  <span class="hljs-comment">// 1.根据对象obj, 找到对应的map对象</span><br>  <span class="hljs-keyword">let</span> map = objMap.<span class="hljs-title function_">get</span>(obj)<br>  <span class="hljs-keyword">if</span> (!map) &#123;<br>    map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br>    objMap.<span class="hljs-title function_">set</span>(obj, map)<br>  &#125;<br><br>  <span class="hljs-comment">// 2.根据key, 找到对应的depend对象</span><br>  <span class="hljs-keyword">let</span> dep = map.<span class="hljs-title function_">get</span>(key)<br>  <span class="hljs-keyword">if</span> (!dep) &#123;<br>    dep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Depend</span>()<br>    map.<span class="hljs-title function_">set</span>(key, dep)<br>  &#125;<br>  <span class="hljs-keyword">return</span> dep<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">reactive</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">const</span> objProxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;<br>    <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">target, key, newValue, receiver</span>) &#123;<br>      <span class="hljs-comment">// target[key] = newValue</span><br>      <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, newValue, receiver)<br>      <span class="hljs-keyword">const</span> dep = <span class="hljs-title function_">getDepend</span>(target, key)<br>      dep.<span class="hljs-title function_">notify</span>()<br>    &#125;,<br>    <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">target, key, receiver</span>) &#123;<br>      <span class="hljs-keyword">const</span> dep = <span class="hljs-title function_">getDepend</span>(target, key)<br>      dep.<span class="hljs-title function_">depend</span>()<br>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver)<br>    &#125;<br>  &#125;)<br>  <span class="hljs-keyword">return</span> objProxy <br>&#125;<br></code></pre></td></tr></table></figure><p>业务代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = <span class="hljs-title function_">reactive</span>(&#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>  <span class="hljs-attr">address</span>: <span class="hljs-string">&quot;广州市&quot;</span><br>&#125;)<br><br><span class="hljs-title function_">watchFn</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">name</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">age</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">age</span>)<br>&#125;)<br><br><span class="hljs-comment">// 修改name</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;--------------&quot;</span>)<br><span class="hljs-comment">// obj.name = &quot;kobe&quot;</span><br>obj.<span class="hljs-property">age</span> = <span class="hljs-number">20</span><br><span class="hljs-comment">// obj.address = &quot;上海市&quot;</span><br><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;=============== user =================&quot;</span>)<br><span class="hljs-keyword">const</span> user = <span class="hljs-title function_">reactive</span>(&#123;<br>  <span class="hljs-attr">nickname</span>: <span class="hljs-string">&quot;abc&quot;</span>,<br>  <span class="hljs-attr">level</span>: <span class="hljs-number">100</span><br>&#125;)<br><br><span class="hljs-title function_">watchFn</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;nickname:&quot;</span>, user.<span class="hljs-property">nickname</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;level:&quot;</span>, user.<span class="hljs-property">level</span>)<br>&#125;)<br><br>user.<span class="hljs-property">nickname</span> = <span class="hljs-string">&quot;cba&quot;</span><br></code></pre></td></tr></table></figure><p>执行结果</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927019.png" alt="img"></p><p>总结 : </p><ul><li>Vue3主要是通过Proxy来监听数据的变化以及收集相关的依赖的；</li><li>ue2中通过我们前面学习过的Object.defineProerty的方式来实现对象属性的监听；</li></ul>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>后端抽象理解</title>
    <link href="/2023/06/19/%E5%90%8E%E7%AB%AF%E5%BD%A2%E8%B1%A1%E7%90%86%E8%A7%A3%E7%AF%87/"/>
    <url>/2023/06/19/%E5%90%8E%E7%AB%AF%E5%BD%A2%E8%B1%A1%E7%90%86%E8%A7%A3%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h2 id="如何形象的理解-spring"><a href="#如何形象的理解-spring" class="headerlink" title="如何形象的理解 spring?"></a>如何形象的理解 spring?</h2><blockquote><p>依赖注入框架，帮助你管理 Java 对象，集成一些其他的内容</p></blockquote><p>让我们用通俗易懂的语言来解释Spring框架。</p><p>想象一下你在组装一台电脑。你需要连接各个硬件组件，如CPU、内存、硬盘等，并确保它们能够协同工作。Spring框架就像是电脑组装的助手，它帮助你管理和组织各个组件，并提供一些便捷的功能。</p><p>在这个比喻中：</p><ul><li>你可以将硬件组件看作是你的应用程序中的不同部分，如服务、数据访问对象、控制器等。</li><li>Spring框架则扮演了管理和组织这些组件的角色，确保它们能够协同工作。</li><li>框架提供了一种便捷的方式来连接和配置这些组件，就像你将硬件组件插入主板上的插槽一样。</li><li>框架还提供了一些额外的功能，如依赖注入（DI），就像是帮助你将各个硬件组件连接在一起，使它们可以相互通信和协作。</li><li>你可以使用框架提供的功能来实现业务逻辑，就像在电脑上运行软件应用程序一样。</li></ul><p>总的来说，Spring框架是一个帮助你管理和组织应用程序组件的工具。它简化了开发过程，提供了便捷的连接和配置方式，并提供了一些额外的功能来增强应用程序的灵活性和可维护性。使用Spring框架，你可以更轻松地构建和管理复杂的应用程序，并提供高效、可靠的功能。</p><h2 id="如何形象的理解依赖注入"><a href="#如何形象的理解依赖注入" class="headerlink" title="如何形象的理解依赖注入?"></a>如何形象的理解依赖注入?</h2><p>让我们用一个日常生活的比喻来形象地理解依赖注入。</p><p>假设你是一个厨师，需要准备一道菜。为了完成这道菜，你需要使用一些食材，如蔬菜、肉类、调味料等。</p><p>在没有依赖注入的情况下，你可能需要自己去购买这些食材，并将它们携带到厨房。这意味着你要亲自管理食材的采购、携带和使用过程。这可能会增加你的负担和工作量，还可能导致混乱和错误。</p><p>现在，假设你有一个厨师助手，他负责为你提供所需的食材。这就是依赖注入的概念在生活中的体现。</p><p>在这个比喻中：</p><ul><li>你是主厨，负责菜的制作，即应用程序的核心逻辑。</li><li>食材是你所需要的依赖对象，如服务、数据访问对象等。</li><li>厨师助手是依赖注入的机制，负责将食材提供给你，以供你使用。</li><li>依赖注入让你从繁琐的采购和管理任务中解放出来，专注于菜的制作。</li></ul><p>在编程中，依赖注入的概念类似。它是一种设计模式，通过在需要使用某个对象的地方将其注入（提供）给目标对象，减少了目标对象与依赖对象之间的耦合性。这样，目标对象可以专注于自己的业务逻辑，而不需要关心如何创建或获取依赖对象。</p><p>总而言之，依赖注入就像是一个厨师助手为你提供所需食材一样，它让你从繁琐的依赖管理中解放出来，让你的代码更加清晰、模块化和可维护。它使代码的组织和协作更加灵活和简单。</p><h2 id="如何形象的理解-springmvc"><a href="#如何形象的理解-springmvc" class="headerlink" title="如何形象的理解 springmvc ?"></a>如何形象的理解 springmvc ?</h2><blockquote><p>web 框架，提供接口访问、restful接口等能力</p></blockquote><p>让我们用一个类比来形象地理解Spring MVC。</p><p>假设你是一家快餐店的服务员，负责接待顾客并处理他们的点餐请求。</p><p>在没有Spring MVC的情况下，你可能需要一个人来处理所有的任务，包括接待顾客、记录点餐、取餐、上菜等。这样的情况下，你可能会感到忙碌和混乱，很难有效地处理顾客的需求。</p><p>现在，假设快餐店引入了Spring MVC框架来协助你进行工作。这就是Spring MVC的作用。</p><p>在这个比喻中：</p><ul><li>你是服务员，负责处理顾客的点餐请求，即处理Web请求的控制器。</li><li>顾客是Web应用的用户，发送请求给服务器。</li><li>Spring MVC框架则扮演了一个协调者的角色，负责接收请求、路由请求到适当的控制器，并将结果返回给用户。</li><li>框架提供了一些便捷的功能，如请求路由、参数绑定、视图渲染等，使你能够更加高效地处理顾客的点餐请求。</li></ul><p>使用Spring MVC，你可以将业务逻辑分散到不同的控制器中，每个控制器负责处理特定类型的请求。这样，你可以更好地组织和管理代码，并提供更好的用户体验。</p><p>总而言之，Spring MVC就像是一个服务员的协助工具，帮助你更好地处理Web请求，分散和管理业务逻辑，并提供高效的处理方式。它简化了开发过程，提供了便捷的路由和控制功能，使得Web应用的开发更加模块化、可维护和可扩展。</p><h2 id="如何形象的理解-mybatis"><a href="#如何形象的理解-mybatis" class="headerlink" title="如何形象的理解 mybatis ?"></a>如何形象的理解 mybatis ?</h2><blockquote><p>Java 操作数据库的框架，持久层框架，对 jdbc 的封装</p></blockquote><p>让我们用一个类比来形象地理解MyBatis。</p><p>假设你是一个图书管理员，负责管理图书馆的图书和借阅记录。</p><p>在没有MyBatis的情况下，你可能需要手动管理图书和借阅记录的存储、查询和更新。这意味着你需要编写大量的SQL语句来执行数据库操作，并处理与数据库的连接、事务等细节。这样的工作可能会非常繁琐和复杂。</p><p>现在，假设你有一个智能助手，他帮助你<strong>自动化处理图书和借阅记录的管理</strong>。这就是MyBatis的作用。</p><p>在这个比喻中：</p><ul><li>你是图书管理员，负责处理图书和借阅记录的管理，即数据访问对象（DAO）。</li><li>图书和借阅记录是数据库中的数据，需要进行存储、查询和更新。</li><li>MyBatis框架则扮演了一个智能助手的角色，负责处理与数据库的交互和操作。</li><li>框架提供了一种便捷的方式来映射数据库表和<code>Java</code>对象，并提供了一些SQL执行和结果映射的功能。</li></ul><p>使用MyBatis，你可以通过简单的配置文件和注解来定义SQL语句和参数映射，而无需手动编写大量的SQL语句。框架会自动处理与数据库的连接、事务和结果集的映射，让你更专注于业务逻辑的实现。</p><p>总而言之，MyBatis就像是一个智能助手，帮助你简化和自动化与数据库的交互和操作。它减少了手动编写SQL语句的工作量，提供了便捷的数据访问方式，并帮助你更好地组织和管理数据库操作的代码。使用MyBatis，你可以更轻松地进行数据库操作，并提供高效和可维护的数据访问层。</p><h2 id="如何形象的理解-mybatis-plus"><a href="#如何形象的理解-mybatis-plus" class="headerlink" title="如何形象的理解 mybatis - plus ?"></a>如何形象的理解 mybatis - plus ?</h2><blockquote><p>对 mybatis 的增强，不用写 sql 也能实现增删改查</p></blockquote><p>让我们用一个类比来形象地理解MyBatis-Plus。</p><p>假设你是一位室内设计师，负责设计客户的家居装修方案。</p><p>在没有MyBatis-Plus的情况下，你可能需要从头开始设计和实施每个客户的装修方案。这意味着你需要考虑并编写各种细节，如房间布局、材料选择、色彩搭配等。这样的工作可能会非常繁琐和耗时。</p><p>现在，假设你有一个装修助手，他为你提供了一套标准化的装修方案和设计模板。这就是MyBatis-Plus的作用。</p><p>在这个比喻中：</p><ul><li>你是室内设计师，负责设计和实施装修方案，即数据访问对象（DAO）。</li><li>客户是数据库中的表，每个客户对应一张表，需要进行增删改查等操作。</li><li>MyBatis-Plus框架则扮演了一个装修助手的角色，提供了一系列标准化的操作和设计模板。</li><li>框架提供了一种简单的方式来定义实体类和数据库表的映射关系，并提供了一些通用的数据访问功能。</li></ul><p>使用MyBatis-Plus，你可以通过简单的注解和配置来定义实体类和数据库表的映射关系，而无需手动编写繁琐的SQL语句。框架会自动处理与数据库的连接、事务和CRUD操作，让你更专注于业务逻辑的实现。</p><p>总而言之，MyBatis-Plus就像是一个装修助手，为你提供了一套标准化的操作和设计模板。它简化了数据访问层的开发过程，提供了便捷的数据访问方式，并帮助你更好地组织和管理数据库操作的代码。使用MyBatis-Plus，你可以更轻松地进行数据库操作，并提供高效和可维护的数据访问层。</p><h2 id="如何形象的理解-springboot"><a href="#如何形象的理解-springboot" class="headerlink" title="如何形象的理解 springboot ?"></a>如何形象的理解 springboot ?</h2><blockquote><p>快速启动 &#x2F; 快速集成项目。不用自己管理 spring 配置，不用自己整合各种框架</p></blockquote><p>让我们用一个类比来形象地理解Spring Boot。</p><p>假设你是一位厨师，需要准备一道复杂的菜肴。</p><p>在没有Spring Boot的情况下，你需要从头开始购买食材、准备厨房、研究菜谱、调整烹饪参数等。这意味着你需要花费大量的时间和精力来完成每个环节，才能最终完成菜肴的制作。</p><p>现在，假设你有一套现成的厨房设备和标准化的食谱，这就是Spring Boot的作用。</p><p>在这个比喻中：</p><ul><li>你是厨师，负责设计和制作菜肴，即应用程序的开发者。</li><li>菜肴是应用程序，需要进行配置、开发和部署等操作。</li><li>Spring Boot框架则扮演了一个现成的厨房设备和标准化的食谱的角色，提供了一套预定义的配置和开发规范。</li><li>框架帮助你简化了应用程序的搭建和开发过程，提供了自动配置、内嵌服务器、依赖管理等功能。</li></ul><p>使用Spring Boot，你可以通过简单的配置和约定来快速搭建和开发应用程序，无需手动处理繁琐的配置和依赖管理。框架会自动处理与服务器的集成、配置的加载和管理，让你更专注于业务逻辑的实现。</p><p>总而言之，Spring Boot就像是一个现成的厨房设备和标准化的食谱，帮助你快速搭建和开发应用程序。它简化了应用程序的搭建和开发过程，提供了自动化的配置和依赖管理，让你能够更轻松地构建高效和可维护的应用程序。</p><blockquote><p>Spring Boot是Spring的一个子项目，旨在简化Spring应用程序的搭建和开发过程，通过自动配置和约定大于配置的原则，提供了一套预定义的规范和配置，使得开发者能够更快速地创建独立的、自包含的应用程序。</p></blockquote><h2 id="什么是-junit-单元测试库"><a href="#什么是-junit-单元测试库" class="headerlink" title="什么是 junit 单元测试库?"></a>什么是 junit 单元测试库?</h2><p>JUnit是一个Java单元测试库，用于编写和执行单元测试。它提供了一组用于编写测试用例的注解和断言方法，可以帮助开发者进行自动化的单元测试。</p><p>JUnit的主要作用是帮助开发者验证代码的正确性和稳定性。通过编写单元测试用例，开发者可以针对代码的不同模块、方法或类编写测试代码，用于验证其预期行为是否符合预期。单元测试可以帮助开发者发现和修复代码中的bug，减少代码出错的可能性，并提高代码的质量和可维护性。</p><p>JUnit提供了一些常用的注解，如<code>@Test</code>用于标记测试方法，<code>@Before</code>和<code>@After</code>用于在测试方法执行前后执行一些初始化和清理操作，<code>@BeforeClass</code>和<code>@AfterClass</code>用于在所有测试方法执行前后执行一次初始化和清理操作。此外，JUnit还提供了一系列的断言方法，如<code>assertEquals</code>、<code>assertTrue</code>、<code>assertFalse</code>等，用于验证测试结果是否符合预期。</p><p>使用JUnit，开发者可以编写简洁、可重复运行的测试用例，并通过运行JUnit测试来自动执行这些测试用例，获取测试结果。这样可以提高开发效率，减少手动测试的工作量，并保证代码的可靠性和稳定性。</p><p>总之，JUnit是一个Java单元测试库，它提供了注解和断言方法，用于编写和执行单元测试，帮助开发者验证代码的正确性和稳定性，并提高代码的质量和可维护性。</p><h2 id="关于用户登录状态管理的详细过程："><a href="#关于用户登录状态管理的详细过程：" class="headerlink" title="关于用户登录状态管理的详细过程："></a>关于用户登录状态管理的详细过程：</h2><ol><li><p>客户端与服务器建立连接后，服务器为客户端创建一个会话（session），并返回会话的标识符（session ID）给客户端。这个会话可以是匿名会话，表示客户端尚未登录。</p></li><li><p>当用户成功登录时，服务器会为该用户创建一个具有用户信息的会话对象，并将会话对象存储在服务器端。通常会将用户信息存储在会话对象的属性中，例如，将用户ID、用户名等信息存储为会话属性。</p></li><li><p>服务器将会话的标识符（session ID）发送给客户端，并要求客户端将其存储为一个 cookie。这个 cookie 的作用是在客户端保存会话标识符，以便在后续的请求中携带该会话标识符。</p></li><li><p>客户端接收到服务器返回的会话标识符后，将其存储为 cookie，保存在客户端浏览器中。</p></li><li><p>当客户端再次向服务器发送请求时，在请求头中会包含该域名下的所有 cookie 信息，包括会话标识符。</p></li><li><p>服务器接收到请求后，从请求头中提取出会话标识符，通过该标识符在服务器端查找对应的会话对象。</p></li><li><p>服务器根据会话标识符找到对应的会话对象后，可以从会话对象中获取存储的用户信息，如用户的登录名等。</p></li></ol><p>总结：通过将会话标识符存储在客户端的 cookie 中，客户端在后续的请求中携带该会话标识符，使服务器能够识别客户端，并通过会话对象管理用户的登录状态和其他相关信息。</p><p>需要注意的是，上述过程是一种常见的用户登录状态管理方式，但实际上，还有其他方法可以实现用户登录状态的管理，如使用 JSON Web Token (JWT) 等。具体的实现方式可能因框架和技术选型而有所差异。</p><h2 id="简单说明cookie和session"><a href="#简单说明cookie和session" class="headerlink" title="简单说明cookie和session"></a><strong>简单说明cookie和session</strong></h2><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcode">🪔 以最常见的登陆案例讲解cookie的使用过程：<br>（<span class="hljs-number">1</span>）首先用户在客户端浏览器向服务器首次发起登陆请求<br>（<span class="hljs-number">2</span>）登陆成功后，服务端会把登陆的用户信息设置在cookie 中，并将cookie返回给客户端浏览器<br>（<span class="hljs-number">3</span>）客户端浏览器接收到 cookie 请求后，会把 cookie 保存到本地<span class="hljs-comment">(可能是内存，也可能是磁盘，看具体使用情况而定)</span><br>（<span class="hljs-number">4</span>）以后再次访问该 web 应用时，客户端浏览器就会把本地的 cookie 带上，这样服务端就能根据 cookie 获得用户信息了<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">🪔 同样以登陆案例为例子讲解 <span class="hljs-keyword">session</span> 的使用过程：<br>（<span class="hljs-number">1</span>）首先用户在客户端浏览器发起登陆请求<br>（<span class="hljs-number">2</span>）登陆成功后，服务端会把用户信息保存在服务端，并返回一个唯一的 <span class="hljs-keyword">session</span> 标识给客户端浏览器。<br>（<span class="hljs-number">3</span>）客户端浏览器会把这个唯一的 <span class="hljs-keyword">session</span> 标识保存在起来<br>（<span class="hljs-number">4</span>）以后再次访问 web 应用时，客户端浏览器会把这个唯一的 <span class="hljs-keyword">session</span> 标识带上，这样服务端就能根据这个唯一标识找到用户信息。<br></code></pre></td></tr></table></figure><p><strong>看到这里可能会引起疑问：把唯一的 session 标识返回给客户端浏览器，然后保存起来，以后访问时带上，这难道不是 cookie 吗？</strong></p><blockquote><p>没错，session 只是一种会话机制，在许多 web 应用中，session 机制就是通过 cookie 来实现的。也就是说它只是使用了 cookie 的功能，并不是使用 cookie完成会话保存。与 cookie 在保存客户端保存会话的机制相反，session 通过 cookie 的功能把会话信息保存到了服务端。</p></blockquote><p><strong>session和cookie有什么区别？</strong></p><ol><li><p>cookie 是浏览器提供的一种缓存机制，它可以用于维持客户端与服务端之间的会话</p></li><li><p>session 指的是维持客户端与服务端会话的一种机制，它可以通过 cookie 实现，也可以通过别的手段实现。</p></li><li><p>如果用 cookie 实现会话，那么会话会保存在客户端浏览器中</p></li><li><p>而 session 机制提供的会话是保存在服务端的。</p></li></ol><p><strong>举个小例子说明Cookie和Session之间的区别和联系</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">🦥 <br>假如一个咖啡店有喝五杯赠一杯咖啡的优惠，但是一次性消费<span class="hljs-number">5</span>杯咖啡的客人很少，这时就需要某种方式来记录某位顾客的消费数量。无外乎下面的几种方案：<br><span class="hljs-number">1</span>、该店的店员很厉害，能记住每位顾客的消费数量，只要顾客一走进咖啡店，店员就知道该怎么对待了。这种做法就是协议本身支持状态。但是<span class="hljs-keyword">http</span>协议本身是无状态的。<br><span class="hljs-number">2</span>、发给顾客一张卡片，上面记录着消费的数量，一般还有个有效期限。每次消费时，如果顾客出示这张卡片，则此次消费就会与以前或以后的消费相联系起来。这种做法就是在客户端保持状态，也就是cookie，顾客就相当于浏览器。<br><span class="hljs-number">3</span>、发给顾客一张会员卡，除了卡号之外什么信息也不纪录，每次消费时，如果顾客出示该卡片，则店员在店里的记录本上找到这个卡号对应的记录添加一些消费信息。这种做法就是在服务器端保持状态。<br></code></pre></td></tr></table></figure><h2 id="正向代理和反向代理的区别是什么"><a href="#正向代理和反向代理的区别是什么" class="headerlink" title="正向代理和反向代理的区别是什么?"></a>正向代理和反向代理的区别是什么?</h2><p><a href="https://www.cnblogs.com/taostaryu/p/10547132.html">原文</a></p><blockquote><p>代理其实就是一个中介，A和B本来可以直连，中间插入一个C，C就是中介。<br>刚开始的时候，代理多数是帮助内网client访问外网server用的<br>后来出现了反向代理，”反向”这个词在这儿的意思其实是指方向相反，即代理将来自外网客户端的请求转发到内网服务器，从外到内.</p></blockquote><h4 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h4><p>正向代理类似一个跳板机，代理访问外部资源 .</p><p>比如我们国内访问谷歌，直接访问访问不到，我们可以通过一个正向代理服务器，请求发到代理服，代理服务器能够访问谷歌，这样由代理去谷歌取到返回数据，再返回给我们，这样我们就能访问谷歌了 .</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202306181011210.png" alt="image-20230618101113110"></p><p><strong>正向代理的用途：</strong></p><ol><li>访问原来无法访问的资源，如google</li><li>可以做缓存，加速访问资源</li><li>对客户端访问授权，上网进行认证</li><li>代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息</li></ol><h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><p>反向代理（Reverse Proxy）实际运行方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202306181011725.png" alt="image-20230618101124689"></p><p><strong>反向代理的作用：</strong></p><ol><li>保证内网的安全，阻止web攻击，大型网站，通常将反向代理作为公网访问地址，Web服务器是内网 . </li><li>负载均衡，通过反向代理服务器来优化网站的负载</li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>正向代理即是客户端代理, 代理客户端, 服务端不知道实际发起请求的客户端.</strong></p><p><strong>反向代理即是服务端代理, 代理服务端, 客户端不知道实际提供服务的服务端</strong></p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202306181014100.png" alt="image-20230618101447052"></p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202306181013811.png" alt="image-20230618101318766"></p><h2 id="java项目中target文件是什么文件"><a href="#java项目中target文件是什么文件" class="headerlink" title="java项目中target文件是什么文件?"></a>java项目中target文件是什么文件?</h2><p><code>target</code> 文件夹通常是在构建过程中由构建工具生成的默认输出目录，例如 Maven 或 Gradle。在 Maven 项目中，<code>target</code> 文件夹用于存储编译后的类文件、资源文件和生成的构建产物（如 JAR 文件）等。</p><p>当你执行 Maven 的构建命令（如 <code>mvn package</code>）时，Maven 会将项目的源代码编译成字节码，并将编译后的类文件和其他资源文件输出到 <code>target</code> 文件夹中。此外，构建工具还会在 <code>target</code> 文件夹中生成其他与构建过程相关的临时文件和日志文件。</p><p>通常情况下，<code>target</code> 文件夹的内容应该是可以被忽略的，不应该被版本控制系统（如 Git）所跟踪。这是因为 <code>target</code> 文件夹的内容可以通过重新构建项目来生成，而不需要将生成的文件包含在版本控制中。</p><p>需要注意的是，<code>target</code> 文件夹的名称可以在 Maven 或 Gradle 的配置文件中进行自定义，但通常情况下，<code>target</code> 是默认的输出目录名称。</p><h2 id="java项目中controller文件的作用是什么"><a href="#java项目中controller文件的作用是什么" class="headerlink" title="java项目中controller文件的作用是什么?"></a>java项目中controller文件的作用是什么?</h2><p>在Java项目中，控制器（Controller）的作用是处理客户端发起的请求并返回响应。它充当了应用程序的入口点，协调不同的组件来完成特定的业务逻辑。控制器主要负责以下几个方面的工作：</p><ol><li><p><strong>接收请求</strong>：控制器监听特定的URL路径或请求方法，并接收来自客户端的请求。它充当了请求的入口，接收并解析请求参数、路径、请求体等信息。</p></li><li><p><strong>处理业务逻辑</strong>：一旦接收到请求，控制器会调用相应的服务（Service）或业务逻辑组件来处理具体的业务逻辑。它可以从数据库、外部服务或其他组件中获取数据，并对数据进行处理、转换或验证。</p></li><li><p><strong>调用服务层</strong>：控制器通常与服务层（Service Layer）进行交互，通过依赖注入或手动创建实例来调用服务层提供的方法。服务层负责封装业务逻辑，处理数据持久化、事务管理、业务规则等操作。</p></li><li><p><strong>返回响应</strong>：控制器根据请求处理的结果生成相应的响应，并将其返回给客户端。响应可以是HTML页面、JSON数据、文件下载等形式。控制器负责将响应数据封装成适当的格式，并设置响应头和状态码。</p></li><li><p><strong>路由和URL映射</strong>：控制器根据不同的URL路径和请求方法来映射到相应的处理方法。它通过使用路由配置或注解来定义URL与处理方法之间的映射关系，以便将请求正确地分发到对应的处理方法。</p></li><li><p><strong>控制流程和验证</strong>：控制器可以处理用户输入的验证和数据校验，确保数据的合法性和完整性。它还可以根据业务需求决定请求的流程，例如重定向、转发或错误处理等。</p></li></ol><p>总之，控制器在Java项目中起着连接用户界面、业务逻辑和数据持久化层的桥梁作用。它接收并处理请求，协调其他组件完成特定的业务功能，并将处理结果返回给客户端。控制器的设计良好与否对于项目的可维护性、可测试性和灵活性具有重要影响。</p><h2 id="java项目里mapper的作用是什么"><a href="#java项目里mapper的作用是什么" class="headerlink" title="java项目里mapper的作用是什么?"></a>java项目里mapper的作用是什么?</h2><p>在Java项目中，Mapper（或称为数据访问对象，DAO）的作用是封装对数据库的访问操作。它充当了应用程序和数据库之间的桥梁，负责执行数据库查询、更新、插入和删除等操作。Mapper的主要作用如下：</p><ol><li><p><strong>数据库访问</strong>：Mapper负责与数据库进行交互，执行SQL语句或调用数据库的API来完成数据的读取、写入和修改操作。它封装了对数据库的底层访问细节，使开发人员可以以面向对象的方式操作数据库，而无需直接编写原始的SQL语句。</p></li><li><p><strong>对象关系映射</strong>（ORM）：Mapper将数据库中的表和实体对象进行映射，实现了对象与关系数据库之间的转换。它通过配置或注解定义实体类和数据库表之间的映射关系，使开发人员可以以面向对象的方式操作数据，而不需要关注数据库的具体实现细节。</p></li><li><p><strong>数据库事务管理</strong>：Mapper可以处理数据库事务，确保一组数据库操作要么全部成功提交，要么全部回滚。它提供了事务的开始、提交和回滚等操作，使开发人员能够在一致的状态下操作数据库，保持数据的完整性和一致性。</p></li><li><p><strong>查询优化和性能调优</strong>：Mapper可以通过编写高效的SQL语句或使用数据库的特定特性来优化查询性能。它可以利用数据库的索引、缓存机制、分页查询等功能来提高数据访问的效率，减少数据库的负载和响应时间。</p></li><li><p><strong>数据库访问的抽象层</strong>：Mapper提供了对数据库访问的高层抽象，使开发人员能够以面向对象的方式对数据进行操作，而不必关注数据库的细节。它提供了一组通用的CRUD（创建、读取、更新、删除）方法，简化了对数据的操作。</p></li></ol><p>总之，Mapper在Java项目中起着与数据库交互的角色，负责执行数据库操作、实现对象与数据库之间的映射以及提供事务管理等功能。它使开发人员能够以面向对象的方式操作数据库，提高了开发效率和代码的可维护性。通过使用Mapper，可以将数据库操作与业务逻辑解耦，提供了灵活性和可扩展性，使得数据访问更加方便和高效。</p><h2 id="IService和BaseMapper它们的区别是什么"><a href="#IService和BaseMapper它们的区别是什么" class="headerlink" title="IService和BaseMapper它们的区别是什么?"></a>IService<T>和BaseMapper<T>它们的区别是什么?</h2><p><code>IService&lt;T&gt;</code> 和 <code>BaseMapper&lt;T&gt;</code> 是 MyBatis-Plus 框架中的两个核心接口，它们在功能和作用上有一些区别。</p><p><code>IService&lt;T&gt;</code> 接口是用于定义通用的业务操作方法的接口，提供了对数据库表进行常见的增删改查操作的方法定义。它包含了一系列的方法，如保存实体对象、删除记录、更新记录、查询记录等。开发人员可以通过实现 <code>IService&lt;T&gt;</code> 接口或继承该接口来自定义业务逻辑操作。</p><p><code>BaseMapper&lt;T&gt;</code> 接口是 MyBatis-Plus 框架提供的基础映射器接口，用于定义数据库表的基本操作方法。它继承了 MyBatis 中的 <code>Mapper&lt;T&gt;</code> 接口，并额外添加了一些常见的数据库操作方法，如插入记录、删除记录、更新记录、查询记录等。<code>BaseMapper&lt;T&gt;</code> 接口提供了对数据库表进行基本操作的能力。</p><p>区别总结如下：</p><ul><li><code>IService&lt;T&gt;</code> 是定义通用业务操作方法的接口，用于封装和定义业务逻辑，提供了更高层次的抽象，使得业务逻辑更加简洁和易于维护。</li><li><code>BaseMapper&lt;T&gt;</code> 是基础映射器接口，用于定义数据库表的基本操作方法，提供了对数据库的增删改查能力。</li><li><code>IService&lt;T&gt;</code> 可以自定义业务逻辑方法，对数据库操作进行封装，而 <code>BaseMapper&lt;T&gt;</code> 主要提供了一些基本的数据库操作方法。</li><li><code>IService&lt;T&gt;</code> 可以根据具体业务需求进行扩展和定制，而 <code>BaseMapper&lt;T&gt;</code> 主要用于执行基本的数据库操作。</li></ul><p>在实际开发中，通常会同时使用 <code>IService&lt;T&gt;</code> 和 <code>BaseMapper&lt;T&gt;</code> 接口。<code>IService&lt;T&gt;</code> 可以作为业务层的接口，定义具体业务操作方法，而 <code>BaseMapper&lt;T&gt;</code> 则作为数据访问层的接口，提供基本的数据库操作方法。这样可以将业务逻辑和数据访问操作进行解耦，并提高代码的可读性和可维护性。</p><h2 id="Autowired注解的作用是什么"><a href="#Autowired注解的作用是什么" class="headerlink" title="@Autowired注解的作用是什么?"></a>@Autowired注解的作用是什么?</h2><p><code>@Autowired</code> 注解是 Spring 框架提供的依赖注入注解，用于自动装配对象。</p><p>作用如下：</p><ol><li>自动装配依赖对象：<code>@Autowired</code> 注解可以自动将标注的属性、构造函数或方法参数与容器中匹配的 bean 进行关联，完成依赖对象的注入。</li><li>简化配置：通过 <code>@Autowired</code> 注解，可以省去手动配置依赖对象的步骤，由 Spring 容器自动查找并注入所需的对象。</li><li>解决对象之间的耦合：通过依赖注入，对象之间的关系由容器管理，减少了对象之间的直接依赖，降低了耦合性，提高了代码的灵活性和可维护性。</li><li>提高代码的可测试性：使用依赖注入可以方便进行单元测试，可以轻松替换依赖对象或使用模拟对象进行测试。</li></ol><p>要注意的是，使用 <code>@Autowired</code> 注解进行自动装配时，需要保证容器中存在匹配的 bean 对象。如果存在多个匹配的 bean 对象，可以结合使用 <code>@Qualifier</code> 注解或通过指定 bean 的名称进行限定，以确定要注入的具体对象。</p><p>另外，<code>@Autowired</code> 注解可以用于字段、构造函数、Setter 方法以及一些特殊的注入场景，例如 <code>@Autowired</code> 与 <code>@Qualifier</code> 的组合使用，以及与 <code>@Value</code> 注解一起使用等。</p><p>当用户使用网上零食商城的零食分类模块时，以下是一个具体的流程示例：</p><ol><li>用户进入网上零食商城的零食分类页面。</li><li>用户提供分类条件，例如选择特定的食品类别、价格范围或品牌等。</li><li>用户点击”搜索”或类似的按钮，将输入条件传递给零食分类模块。</li><li>零食分类模块接收用户输入的条件。</li><li>模块开始处理用户输入的条件，进行以下步骤：<ul><li>分析用户选择的食品类别、价格范围或品牌等条件。</li><li>查询数据库或调用相关接口，获取与用户条件匹配的零食列表。</li><li>对零食列表进行筛选和排序，根据用户的排序要求或其他标准进行处理。</li><li>生成经过分类和排序的零食列表。</li></ul></li><li>零食分类模块将处理结果返回给用户界面。</li><li>用户界面展示分类结果，包括零食的名称、价格、图片等信息（O1）。</li><li>用户可以浏览所展示的零食列表，查看详细信息，并选择感兴趣的零食进行购买。</li><li>用户可以选择特定的分类结果，例如点击特定的分类标签。</li><li>用户界面将用户选择的分类结果传递给零食分类模块。</li><li>模块接收用户选择的分类结果并进行处理，展示与选择分类匹配的零食列表（O2）。</li><li>用户界面展示根据</li><li>用户选择的分类结果所筛选出的零食列表，供用户浏览和购买。</li><li>用户可以继续浏览和购买感兴趣的零食，或者返回重新选择分类条件。</li></ol>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>费曼学习法</title>
    <link href="/2023/06/10/%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95/"/>
    <url>/2023/06/10/%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="关于费曼学习法"><a href="#关于费曼学习法" class="headerlink" title="关于费曼学习法"></a>关于费曼学习法</h2><blockquote><p>前两天偶然间了解到了费曼学习法, 算是拓宽了我对学习方法的认知. </p><p>它可以简化为四个单词 </p></blockquote><p><code>Concept</code> (概念) – <code>Teach</code> (教给别人) – <code>Review</code> (回顾) – <code>Simplify</code> (简化)</p><ol><li>第一步 : 假装把一个知识(概念) 教给一个小孩子 .</li></ol><p>尽量用最基础的词汇, 以使得这些小孩子刚好能理解这些基本的概念和知识, 当你卡壳了, 也就是不知道如何解释某个概念或与其它知识的联系的时候 – 预示着学习的机会到来了. </p><ol start="2"><li>第二步 : 回顾</li></ol><p>你已经发现了你大脑知识库的边缘, 懂得自己能力的界限也是一种能力. 你需要回到自己的原始材料, 重新学习, 直到你可以用基本的术语解释这一概念. </p><ol start="3"><li>第三步: 将语言条理化 , 简化</li></ol><p>要保证你的手上有一套自己的手写笔记 , 检查一下确保自己没有从原材料中借用任何行话. 请阅读一遍自己的手写笔记 , 如果听起来比较混乱 , 这意味着你还需要更深入的理解该领域 . 这时候你需要重新回到第二步 —— 一直重复直到你的手写笔记解释得通俗易懂且有条理性 . </p><ol start="4"><li>第四步(可选) : 传授</li></ol><p>如果你真的确保你的理解没什么问题, 检测知识最终的途径就是你能有能力把它传播给另一个人 , 如果没有这样一个具象的人 , 那你可以将自己的笔记分享出去 , 通过大家的反馈以使得自己对知识的理解更加通透. </p><blockquote><p>昨天基本上一整天时间都花在搭建博客上了, 这个学习方法也没有得到应用, 从今儿开始, 尝试这种学习方法~🎆</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>日常琐碎</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习方法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的第一篇博客</title>
    <link href="/2023/06/09/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/06/09/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="我的第一篇博客"><a href="#我的第一篇博客" class="headerlink" title="我的第一篇博客"></a>我的第一篇博客</h1><blockquote><p>分享琐碎</p></blockquote><p>忙里偷闲, 或者说闲来无事吧, 实际上, 时间已经来到期末, 可是呢, 我还是保留着对技术的疯狂热情, 搭建这个博客是因为偶然间在星球冲浪时, 看见一位大佬所写的hexo搭建博客系列. 正是这一契机让我花了大半天时间搞了这一个博客.</p><p>其实之前也有花时间搭过一个博客, 是通过 <code>VuePress</code> 搭建的 </p><p>(刚刚搞了好久的图床哈哈哈哈哈哈哈哈哈哈, 主要是通过 阿里云 + Pikgo + Typora 构建的)<br><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202306092321545.png" alt="image-20230609232105109"></p><p>这界面还是略显花哨 , 相比呢以下界面就显得非常滴简约好看</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202306092322286.png" alt="image-20230609232220960"> </p><p>话不多说, 准备优化博客咯 —— hh</p>]]></content>
    
    
    <categories>
      
      <category>日常琐碎</category>
      
    </categories>
    
    
    <tags>
      
      <tag>感想</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
