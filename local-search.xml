<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>😈请介绍一下TCP和UDP</title>
    <link href="/2023/10/24/TCP%E4%B8%8EUDP/"/>
    <url>/2023/10/24/TCP%E4%B8%8EUDP/</url>
    
    <content type="html"><![CDATA[<h3 id="1-TCP-和-UDP-的概念及特点"><a href="#1-TCP-和-UDP-的概念及特点" class="headerlink" title="1. TCP 和 UDP 的概念及特点"></a>1. TCP 和 UDP 的概念及特点</h3><p>⭐<strong>UDP</strong></p><p><code>UDP</code>的全称是<strong>用户数据报协议</strong>，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在传输层，处于IP协议的上一层。<code>UDP</code>有<strong>不提供数据包分组和组装和不能对数据包进行排序</strong>的缺点，也就是说，<strong>当报文发送之后，是无法得知其是否安全完整到达</strong>的。</p><blockquote><p>它的特点如下：</p></blockquote><p><strong>1）面向无连接</strong></p><p>首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。</p><p>具体来说就是：</p><ul><li>在发送端，应用层将数据传递给传输层的 <code>UDP</code> 协议，<code>UDP</code> 只会给数据增加一个 <code>UDP</code> 头标识下是 <code>UDP</code> 协议，然后就传递给网络层了</li><li>在接收端，网络层将数据传递给传输层，<code>UDP</code> 只去除 <code>IP</code> 报文头就传递给应用层，不会任何拼接操作</li></ul><p><strong>2）有单播，多播，广播的功能</strong></p><p><code>UDP</code> 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 <code>UDP</code> 提供了单播，多播，广播的功能。</p><p><strong>3）面向报文</strong></p><p>发送方的<code>UDP</code>对应用程序交下来的报文，在添加首部后就向下交付<code>IP</code>层。<code>UDP</code>对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文</p><p><strong>4）不可靠性</strong></p><p>首先不可靠性体现在<strong>无连接</strong>上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。</p><p>并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。</p><p>再者网络环境时好时坏，但是 <code>UDP</code> 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在<strong>某些实时性要求高的场景（比如电话会议）就需要使用</strong> <code>UDP</code> <strong>而不是</strong> <code>TCP</code><strong>。</strong></p><p><strong>5）头部开销小，传输数据报文时是很高效的。</strong><br><code>UDP</code> 头部包含了以下几个数据：</p><ul><li>两个十六位的端口号，分别为源端口（可选字段）和目标端口</li><li>整个数据报文的长度</li><li>整个数据报文的检验和（IPv4 可选字段），该字段用于发现头部信息和数据中的错误</li></ul><p>因此 <code>UDP</code> 的<strong>头部开销小</strong>，只有<code>8</code>字节，相比 <code>TCP</code> 的至少<code>20</code>字节要少得多，在传输数据报文时是很高效的。</p><p><code>UDP</code> <strong>协议为什么不可靠 ?</strong></p><p><code>UDP</code>在传输数据之前不需要先建立连接，远地主机的运输层在接收到<code>UDP</code>报文后，不需要确认，提供不可靠交付。总结就以下四点：</p><ul><li>不保证消息交付：不确认，不重传，无超时</li><li>不保证交付顺序：不设置包序号，不重排，不会发生队首阻塞</li><li>不跟踪连接状态：不必建立连接或重启状态机</li><li>不进行拥塞控制：不内置客户端或网络反馈机制</li></ul><p>⭐<strong>TCP</strong></p><p><code>TCP</code>的全称是传输控制协议 , 是一种<strong>面向连接的、可靠的</strong>、<strong>基于字节流</strong>的传输层通信协议。</p><p>流就是指不间断的数据结构。</p><blockquote><p>它有以下几个特点：</p></blockquote><p><strong>1）面向连接</strong></p><p>面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。</p><p><strong>2）仅支持单播传输</strong></p><p>每条<code>TCP</code>传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。</p><p><strong>3）面向字节流</strong></p><p><code>TCP</code>不像<code>UDP</code>一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。</p><p><strong>4）可靠传输</strong></p><p>对于可靠传输，判断丢包、误码靠的是<code>TCP</code>的段编号以及确认号。<code>TCP</code>为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(<code>ACK</code>)；如果发送端实体在合理的往返时延(<code>RTT</code>)内未收到确认，那么对应的数据（假设丢失了）将会被重传。</p><p><strong>5）提供拥塞控制</strong></p><p>当网络出现拥塞的时候，<code>TCP</code>能够减小向网络注入数据的速率和数量，缓解拥塞。</p><p><strong>6）提供全双工通信</strong></p><p><code>TCP</code>允许通信双方的应用程序在任何时候都能发送数据，因为<code>TCP</code>连接的两端都设有缓存，用来临时存放双向通信的数据。当然，<code>TCP</code>可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于<code>MSS</code>）</p><p><strong>TCP 的重传机制</strong></p><p>由于<code>TCP</code>的下层网络（网络层）可能出现<strong>丢失、重复或失序</strong>的情况，<code>TCP</code>协议提供可靠数据传输服务。为保证数据传输的正确性，<code>TCP</code>会重传其认为已丢失（包括报文中的比特错误）的包。<code>TCP</code>使用两套独立的机制来完成重传，一是<strong>基于时间</strong>，二是<strong>基于确认信息</strong>。</p><p><code>TCP</code>在发送一个数据之后，就开启一个定时器，若是在这个时间内没有收到发送数据的<code>ACK</code>确认报文，则对该报文进行重传，在达到一定次数还没有成功时放弃并发送一个复位信号。</p><h3 id="2-TCP-和-UDP-的区别"><a href="#2-TCP-和-UDP-的区别" class="headerlink" title="2. TCP 和 UDP 的区别"></a>2. TCP 和 UDP 的区别</h3><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310241713024.png" alt="img"></p><h3 id="3-TCP-和-UDP-的使用场景"><a href="#3-TCP-和-UDP-的使用场景" class="headerlink" title="3. TCP 和 UDP 的使用场景"></a>3. TCP 和 UDP 的使用场景</h3><ul><li><code>TCP</code><strong>应用场景：</strong> 效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有<code>UDP</code>高。例如：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。</li><li><code>UDP</code><strong>应用场景：</strong> 效率要求相对高，对准确性要求相对低的场景。例如：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）。</li></ul><h3 id="4-TCP的拥塞控制机制"><a href="#4-TCP的拥塞控制机制" class="headerlink" title="4. TCP的拥塞控制机制"></a>4. TCP的拥塞控制机制</h3><p>TCP的拥塞控制机制主要是以下四种机制：</p><ul><li><strong>慢启动（慢开始）</strong></li><li><strong>拥塞避免</strong></li><li><strong>快速重传</strong></li><li><strong>快速恢复</strong></li></ul><p>拥塞窗口是发送方的</p><p><strong>（1）慢启动（慢开始）</strong></p><ul><li><p>在开始发送的时候设置<code>cwnd = 1</code>（<code>cwnd</code>指的是拥塞窗口）</p></li><li><p>思路：开始的时候不要发送大量数据，而是先测试一下网络的拥塞程度，由小到大增加拥塞窗口的大小。</p></li><li><p>为了防止<code>cwnd</code>增长过大引起网络拥塞，设置一个慢开始门限(<code>ssthresh</code> 状态变量) </p></li><li><p>当<code>cnwd &lt; ssthresh</code>，使用慢开始算法</p></li><li><p>当<code>cnwd = ssthresh</code>，既可使用慢开始算法，也可以使用拥塞避免算法</p></li><li><p>当<code>cnwd &gt; ssthresh</code>，使用拥塞避免算法</p></li></ul><p><strong>（2）拥塞避免</strong></p><ul><li>拥塞避免未必能够完全避免拥塞，是说在拥塞避免阶段<strong>将拥塞窗口控制为按线性增长</strong>，使网络不容易出现阻塞。</li><li>思路： 让拥塞窗口<code>cwnd</code>缓慢的增大，即每经过一个返回时间<code>RTT</code>就把发送方的拥塞控制窗口加一</li><li>无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞，就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为<code>1</code>，执行慢开始算法。其中，判断网络出现拥塞的根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理。</li></ul><blockquote><p> 如图 : </p></blockquote><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310241713132.png" alt="img"></p><p><strong>（3）快速重传</strong></p><ul><li>快重传要求接收方在收到一个失序的报文段后就立即发出重复确认(为的是使发送方及早知道有报文段没有到达对方)。发送方只要连续收到三个重复确认就立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</li><li>由于不需要等待设置的重传计时器到期，能尽早重传未被确认的报文段，能提高整个网络的吞吐量</li></ul><p><strong>（4）快速恢复</strong></p><ul><li>当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把<code>ssthresh</code>门限减半。但是接下去并不执行慢开始算法。</li><li>考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将<code>cwnd</code>设置为<code>ssthresh</code>的大小，然后执行拥塞避免算法。</li></ul><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310241713088.png" alt="img"></p><h3 id="5-TCP的流量控制机制"><a href="#5-TCP的流量控制机制" class="headerlink" title="5. TCP的流量控制机制"></a>5. TCP的流量控制机制</h3><p>一般来说，流量控制就是为了让发送方发送数据的速度不要太快，要让接收方来得及接收。TCP采用大小可变的<strong>滑动窗口</strong>进行流量控制，窗口大小的单位是字节。这里说的窗口大小其实就是每次传输的数据大小。</p><ul><li>当一个连接建立时，连接的每一端分配一个缓冲区来保存输入的数据，并将缓冲区的大小发送给另一端。</li><li>当数据到达时，接收方发送确认，其中包含了自己剩余的缓冲区大小。（剩余的缓冲区空间的大小被称为窗口，指出窗口大小的通知称为窗口通告 。接收方在发送的每一确认中都含有一个窗口通告。）</li><li>如果接收方应用程序读数据的速度能够与数据到达的速度一样快，接收方将在每一确认中发送一个正的窗口通告。</li><li>如果发送方操作的速度快于接收方，接收到的数据最终将充满接收方的缓冲区，导致接收方通告一个零窗口。发送方收到一个零窗口通告时，必须停止发送，直到接收方重新通告一个正的窗口。</li></ul><h3 id="6-TCP的可靠传输机制"><a href="#6-TCP的可靠传输机制" class="headerlink" title="6. TCP的可靠传输机制"></a>6. TCP的可靠传输机制</h3><p><code>TCP</code> 的可靠传输机制是基于<strong>连续</strong> <code>ARQ</code> <strong>协议</strong>和<strong>滑动窗口协议</strong>的。</p><p><code>TCP</code> 协议在发送方维持了一个发送窗口</p><ul><li>发送窗口以前的报文段是已经发送并确认了的报文段，</li><li>发送窗口内包含了已经发送但未确认的报文段和允许发送但还未发送的报文段</li><li>发送窗口以后的报文段是缓存中还不允许发送的报文段。</li></ul><p>当<strong>发送方</strong>向<strong>接收方</strong>发送报文时，会依次发送窗口内的所有报文段，并且设置一个定时器，这个定时器可以理解为是最早发送但未收到确认的报文段。 </p><ul><li>如果在定时器的时间内收到某一个报文段的确认回答，则滑动窗口，将窗口的首部向后滑动到确认报文段的后一个位置。</li><li>此时如果还有已发送但没有确认的报文段，则重新设置定时器，如果没有了则关闭定时器。</li><li>如果定时器超时，则<strong>重新发送</strong>所有已经发送但还未收到确认的报文段，并将超时的间隔设置为以前的<strong>两倍</strong>。</li></ul><p>当发送方收到接收方的三个冗余的确认应答后，这是一种指示， 说明该报文段以后的报文段很有可能发生丢失了，那么发送方会启用<strong>快速重传</strong>的机制，就是当前定时器结束前，发送所有的<strong>已发送但确认</strong>的报文段。</p><p>接收方使用的是<strong>累计确认</strong>的机制，对于所有按序到达的报文段，接收方返回一个报文段的肯定回答。如果收到了一个乱序的报文段，那么接方会直接<strong>丢弃</strong>，并返回一个最近的按序到达的报文段的肯定回答。使用累计确认保证了返回的确认号之前的报文段都已经按序到达了，所以发送窗口可以移动到已确认报文段的后面。</p><p>发送窗口的大小是变化的，它是由接收窗口剩余大小和网络中拥塞程度来决定的，<code>TCP </code>就是通过控制发送窗口的长度来控制报文 段的发送速率。</p><p>但是 <code>TCP</code> 协议并不完全和滑动窗口协议相同，因为许多的 <code>TCP</code> 实现会将失序的报文段给<strong>缓存</strong>起来，并且发生重传时，只会重传一个报文段，因此 <code>TCP</code> 协议的可靠传输机制更像是窗口滑动协议和选择重传协议的一个混合体。</p><p><strong>TCP 如何保证传输过程的可靠性?</strong></p><ul><li><strong>校验和</strong>：发送方在发送数据之前计算校验和，接收方收到数据后同样计算，如果不一致，那么传输有误。</li><li><strong>确认应答，序列号</strong>：<code>TCP</code>进行传输时数据都进行了编号，每次接收方返回<code>ACK</code>都有确认序列号。</li><li><strong>超时重传</strong>：如果发送方发送数据一段时间后没有收到<code>ACK</code>，那么就重发数据。</li><li><strong>连接管理</strong>：三次握手和四次挥手的过程。</li><li><strong>流量控制</strong>：<code>TCP</code>协议报头包含16位的窗口大小，接收方会在返回<code>ACK</code>时同时把自己的即时窗口填入，发送方就根据报文中窗口的大小控制发送速度。</li><li><strong>拥塞控制</strong>：刚开始发送数据的时候，拥塞窗口是<code>1</code>，以后每次收到<code>ACK</code>，则拥塞窗口<code>+1</code>，然后将拥塞窗口和收到的窗口取<strong>较小值</strong>作为实际发送的窗口，如果发生超时重传，拥塞窗口重置为<code>1</code>。这样做的目的就是为了保证传输过程的高效性和可靠性。</li></ul><h3 id="7-❗TCP的三次握手和四次挥手"><a href="#7-❗TCP的三次握手和四次挥手" class="headerlink" title="7. ❗TCP的三次握手和四次挥手"></a>7. ❗TCP的三次握手和四次挥手</h3><p><strong>❗三次握手</strong></p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310241713110.png" alt="img"></p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310241713203.png" alt="img"></p><p>三次握手（Three-way Handshake）其实就是指建立一个<code>TCP</code>连接时，需要客户端和服务器总共发送<code>3</code>个包。进行三次握手的主要作用就是<strong>为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。</strong></p><blockquote><p>实质上其实就是连接服务器指定端口，建立<code>TCP</code>连接，并同步连接双方的序列号和确认号，交换<code>TCP</code>窗口大小信息。</p></blockquote><p>刚开始客户端处于 <code>Closed</code> 的状态，服务端处于 <code>Listen</code> 状态。</p><ul><li><strong>第一次握手</strong>：客户端给服务端发一个 <code>SYN</code> 报文，并指明客户端的初始化序列号 <code>ISN</code>，此时客户端处于   <code>SYN_SENT</code> 状态。</li></ul><blockquote><p>首部的同步位<code>SYN=1</code>，初始序号<code>seq=x</code>，<code>SYN=1</code>的报文段不能携带数据，但要消耗掉一个序号。</p></blockquote><ul><li><strong>第二次握手</strong>：服务器收到客户端的 <code>SYN</code> 报文之后，会以自己的 <code>SYN</code> 报文作为应答，并且也是指定了自己的初始化序列号 <code>ISN</code>。同时会把客户端的 <code>ISN + 1</code> 作为<code>ACK</code> 的值，表示自己已经收到了客户端的 <code>SYN</code>，此时服务器处于 <code>SYN_RCVD</code> 的状态。</li></ul><blockquote><p>在确认报文段中<code>SYN=1</code>，<code>ACK=1</code>，确认号<code>ack=x+1</code>，初始序号<code>seq=y</code></p></blockquote><ul><li><strong>第三次握手</strong>：客户端收到 <code>SYN</code> 报文之后，会发送一个 <code>ACK</code> 报文，当然，也是一样把服务器的 <code>ISN + 1</code> 作为 <code>ACK</code> 的值，表示已经收到了服务端的 <code>SYN</code> 报文，此时客户端处于 <code>ESTABLISHED</code> 状态。服务器收到 <code>ACK</code> 报文之后，也处于 <code>ESTABLISHED</code> 状态，此时，双方已建立起了连接。</li></ul><blockquote><p>确认报文段<code>ACK=1</code>，确认号<code>ack=y+1</code>，序号<code>seq=x+1</code>（初始为<code>seq=x</code>，第二个报文段所以要<code>+1</code>），   <code>ACK</code>报文段可以携带数据，不携带数据则不消耗序号。</p></blockquote><p><strong>那为什么要三次握手呢？两次不行吗？</strong></p><ul><li>如果是用两次握手，则会出现下面这种情况</li></ul><p>如果客户端发送第一个请求, 但是因为请求报文丢失服务端未收到, 于是客户端发送第二个请求, 这时候服务端收到请求, 客户端也收到了确认, 这时便建立了连接。</p><p>但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求,  于是就向客户端发出确认报文段，同意建立连接, 这时客户端收到了确认便建立了连接, 但是客户端不知道这个连接咋来的, 就忽略了这个确认, 那么服务端就一直等待客户端发送数据, 就会浪费服务端的资源。(以上都是建立在两次握手的情况下)</p><p><strong>简单来说就是以下三步：</strong></p><ul><li><strong>第一次握手：</strong> 客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 <code>SYN-SENT</code> 状态。</li><li><strong>第二次握手：</strong> 服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 <code>SYN-RECEIVED</code> 状态。</li><li><strong>第三次握手：</strong> 当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 <code>ESTABLISHED</code> 状态，服务端收到这个应答后也进入 <code>ESTABLISHED</code> 状态，此时连接建立成功。</li></ul><p><code>TCP</code> 三次握手的建立连接的过程就是相互确认初始序号的过程，告诉对方，什么样序号的报文段能够被正确接收。 第三次握手的作用是客户端对服务器端的初始序号的确认。如果只使用两次握手，那么服务器就没有办法知道自己的序号是否 已被确认。同时这样也是为了防止失效的请求报文段被服务器接收，而出现错误的情况。</p><p><strong>❗四次挥手</strong></p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310241713172.png" alt="img"></p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310241713016.png" alt="img"></p><p>双方都处于 <code>ESTABLISHED</code> 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：</p><ul><li><strong>第一次挥手</strong>： 客户端会发送一个 <code>FIN </code>报文，报文中会指定一个序列号。此时客户端处于 <code>FIN_WAIT1</code> 状态。</li></ul><blockquote><p>即发出连接释放报文段（<code>FIN=1</code>，序号<code>seq=u</code>）, 并停止再发送数据，主动关闭<code>TCP</code>连接，进入<code>FIN_WAIT1</code>（终止等待1）状态，等待服务端的确认。</p></blockquote><ul><li><strong>第二次挥手</strong>：服务端收到 <code>FIN </code>之后，会发送 <code>ACK</code> 报文，且把客户端的序列号值 <code>+1</code> 作为 <code>ACK</code> 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 <code>CLOSE_WAIT</code> 状态。因为<code>server</code>端可能还有没有发送完成的数据</li></ul><blockquote><p>即服务端收到连接释放报文段后即发出确认报文段（<code>ACK=1</code>，确认号<code>ack=u+1</code>，序号<code>seq=v</code>），服务端进入<code>CLOSE_WAIT</code>（关闭等待）状态，此时的<code>TCP</code>处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入<code>FIN_WAIT2</code>（终止等待2）状态，等待服务端发出的连接释放报文段。</p></blockquote><ul><li><strong>第三次挥手：</strong>等到<code>server</code>端数据都发送完毕之后,  这时服务端也想断开连接，和客户端的第一次挥手一样，发给 <code>FIN</code> 报文，且指定一个序列号。此时服务端处于 <code>LAST_ACK</code>的状态。</li></ul><blockquote><p>即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（<code>FIN=1</code>，<code>ACK=1</code>，序号<code>seq=w</code>，确认号<code>ack=u+1</code>），服务端进入<code>LAST_ACK</code>（最后确认）状态，等待客户端的确认。</p></blockquote><ul><li><strong>第四次挥手：</strong>客户端收到 <code>FIN</code> 之后，一样发送一个 <code>ACK</code> 报文作为应答，且把服务端的序列号值 <code>+1</code> 作为自己 <code>ACK</code> 报文的序列号值，此时客户端处于 <code>TIME_WAIT</code> 状态。需要过一阵子以确保服务端收到自己的 <code>ACK</code> 报文之后才会进入 <code>CLOSED</code> 状态，服务端收到 <code>ACK</code> 报文之后，就处于关闭连接了，处于 <code>CLOSED</code> 状态。</li></ul><blockquote><p>即客户端收到服务端的连接释放报文段后，对此发出确认报文段（<code>ACK=1</code>，<code>seq=u+1</code>，<code>ack=w+1</code>），客户端进入<code>TIME_WAIT</code>（时间等待）状态。此时<code>TCP</code>未释放掉，需要经过时间等待计时器设置的时间<code>2MSL</code>后，客户端才进入<code>CLOSED</code>状态。</p></blockquote><p><strong>为什么要四次挥手呢?</strong></p><p>因为当服务端收到客户端的<code>SYN</code>连接请求报文后，可以直接发送<code>SYN+ACK</code>报文。其中<code>ACK</code>报文是用来应答的，<code>SYN</code>报文是用来同步的。但是关闭连接时，当服务端收到<code>FIN</code>报文时，很可能并不会立即关闭<code>SOCKET</code>，所以只能先回复一个<code>ACK</code>报文，告诉客户端，”你发的<code>FIN</code>报文我收到了”。<strong>只有等到我服务端所有的报文都发送完了，我才能发送</strong><code>**FIN**</code><strong>报文</strong>，因此不能一起发送，故需要四次挥手。</p><p><strong>简单来说就是以下四步：</strong></p><ul><li><strong>第一次挥手：</strong> 若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。</li><li><strong>第二次挥手</strong>：服务端收到连接释放请求后，会告诉应用层要释放 <code>TCP</code> 链接。然后会发送 <code>ACK</code> 包，并进入 <code>CLOSE_WAIT</code> 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 <code>TCP</code> 连接是双向的，所以服务端仍旧可以发送数据给客户端。</li><li><strong>第三次挥手</strong>：服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 <code>LAST-ACK</code> 状态。</li><li><strong>第四次挥手：</strong> 客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 <code>TIME-WAIT</code> 状态。该状态会持续 <code>2MSL</code>（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 <code>CLOSED</code> 状态。当服务端收到确认应答后，也便进入 <code>CLOSED</code> 状态。</li></ul><p><code>TCP</code> 使用四次挥手的原因是因为 <code>TCP</code> 的连接是<strong>全双工</strong>的，所以需要双方分别释放到对方的连接，单独一方的连接释放，只代表不能再向对方发送数据，连接处于的是半释放的状态。</p><p>最后一次挥手中，客户端会等待一段时间再关闭的原因，是为了防止发送给服务器的确认报文段丢失或者出错，从而导致服务器端不能正常关闭。</p><h3 id="8-TCP-粘包是怎么回事，如何处理-为什么-UDP-不会"><a href="#8-TCP-粘包是怎么回事，如何处理-为什么-UDP-不会" class="headerlink" title="8. TCP 粘包是怎么回事，如何处理? 为什么 UDP 不会?"></a>8. TCP 粘包是怎么回事，如何处理? 为什么 UDP 不会?</h3><p>默认情况下, <code>TCP</code> 连接会启用<strong>延迟传送</strong>算法 (<code>Nagle</code> 算法), 在数据发送之前缓存他们. </p><p>如果短时间有多个数据发送, 会缓冲到⼀起作⼀次发送 (缓冲大小见 <code>socket.bufferSize</code>), 这样可以<strong>减少</strong> <code>**IO**</code> <strong>消耗提高性能.</strong></p><p>如果是传输⽂件的话, 那么根本不用处理粘包的问题, 来⼀个包拼⼀个包就好了。但是如果是多条消息, 或者是别的⽤途的数据那么就需要处理粘包.</p><p><strong>下面看⼀个例⼦</strong></p><p>连续调⽤两次 send 分别发送两段数据 data1 和 data2, 在接收端有以下⼏种常⻅的情况:</p><ul><li>A. 先接收到 data1, 然后接收到 data2 . </li><li>B. 先接收到 data1 的部分数据, 然后接收到 data1 余下的部分以及 data2 的全部. </li><li>C. 先接收到了 data1 的全部数据和 data2 的部分数据, 然后接收到了 data2 的余下的数据. </li><li>D. ⼀次性接收到了 data1 和 data2 的全部数据.</li></ul><blockquote><p>其中的 BCD 就是我们常见的粘包的情况.</p></blockquote><p>⽽对于处理粘包的问题, 常⻅的解决⽅案有 : </p><ul><li><strong>多次发送之前间隔⼀个等待时间</strong>：只需要等上⼀段时间再进⾏下⼀次 <code>send</code> 就好, 适⽤于交互频率特别低的场景. 缺点也很明显, 对于⽐较频繁的场景⽽⾔传输效率实在太低，不过⼏乎不⽤做什么处理.</li><li><strong>关闭 Nagle 算法</strong>：关闭 <code>Nagle</code> 算法, 在 <code>Node.js</code> 中你可以通过 <code>socket.setNoDelay()</code> ⽅法来关闭 <code>Nagle</code> 算法, 让每⼀次 <code>send</code> 都不缓冲直接发送。该方法比较适用于每次发送的数据都比较大 (但不是⽂件那么大), 并且频率不是特别高的场景<strong>。</strong>如果是每次发送的数据量比较小, 并且频率特别高的, 关闭 <code>Nagle</code> 纯属自废武功。</li><li><strong>进行封包&#x2F;拆包：</strong> 封包&#x2F;拆包是⽬前业内常⻅的解决⽅案了。即给每个数据包在发送之前, 于其前&#x2F;后放⼀些有特征的数据, 然后收到数据的时候根据特征数据分割出来各个数据包。</li></ul><p><strong>为什么udp不会粘包？</strong></p><ul><li><code>TCP</code>协议是面向流的协议，<code>UDP</code>是面向消息的协议。<code>UDP</code>段都是⼀条消息，应⽤程序必须<strong>以消息为单位</strong>提取数据，不能⼀次提取任意字节的数据</li><li><code>UDP</code>具有保护消息边界，在每个<code>UDP</code>包中就有了消息头（消息来源地址，端⼝等信息），这样对于接收端来说就容易进⾏区分处理了。传输协议把数据当作⼀条独⽴的消息在⽹上传输，接收端只能接收独⽴的消息。接收端⼀次只能接收发送端发出的⼀个<strong>数据包</strong> , 如果⼀次接受数据的大小小于发送端⼀次发送的数据⼤⼩，就会丢失⼀部分数据，即使丢失，接受端也不会分两次去接收。</li></ul><blockquote><p>祝大家程序员节快乐🎉🍾(10.24)</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树层序遍历, 你真的懂了吗？</title>
    <link href="/2023/10/21/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2023/10/21/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<p>⭐借鉴于代码随想录</p><p>二叉树的层序遍历，<strong>就是图论中的广度优先搜索在二叉树中的应用</strong>，需要借助队列来实现</p><blockquote><p> 此时又发现队列的一个应用了。</p></blockquote><p>来 — 一口气打十个!  (其实是九个)</p><hr><h3 id="1-二叉树的层序遍历"><a href="#1-二叉树的层序遍历" class="headerlink" title="1. 二叉树的层序遍历"></a>1. 二叉树的层序遍历</h3><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310211739444.png" alt="img"></p><p>层序遍历一个二叉树。就是从左到右一层一层的去遍历二叉树。这种遍历的方式和我们之前讲过的都不太一样。</p><p>需要借用一个辅助数据结构即队列来实现，<strong>队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。</strong></p><p><strong>而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。</strong></p><p>使用队列实现二叉树广度优先遍历，动画如下：</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310211739987.gif" alt="img"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> levelOrder = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">let</span> res = [], queue = [];<br>    <span class="hljs-keyword">if</span>(root === <span class="hljs-literal">null</span>)  <span class="hljs-keyword">return</span> res;<br>    queue.<span class="hljs-title function_">push</span>(root); <span class="hljs-comment">// root只是根节点</span><br>    <span class="hljs-keyword">while</span>(queue.<span class="hljs-property">length</span>) &#123;<br>        <span class="hljs-keyword">let</span> length = queue.<span class="hljs-property">length</span>; <span class="hljs-comment">// 记录当前层级有多少个节点</span><br>        <span class="hljs-keyword">let</span> curLevel = []; <span class="hljs-comment">// 存放每一层的所有节点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-keyword">let</span> node = queue.<span class="hljs-title function_">shift</span>(); <span class="hljs-comment">// 每次拿到队头元素</span><br>            curLevel.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">val</span>); <span class="hljs-comment">// 存放当前层下一层的节点</span><br>            node.<span class="hljs-property">left</span> &amp;&amp; queue.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">left</span>);<br>            node.<span class="hljs-property">right</span> &amp;&amp; queue.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">right</span>);<br>        &#125;<br>        res.<span class="hljs-title function_">push</span>(curLevel); <span class="hljs-comment">//把每一层的结果(所有节点)放到结果数组</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-二叉树的层序遍历-反着来"><a href="#2-二叉树的层序遍历-反着来" class="headerlink" title="2. 二叉树的层序遍历(反着来)"></a>2. 二叉树的层序遍历(反着来)</h3><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310211739428.png" alt="img"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> levelOrderBottom = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">let</span> res = [];<br>    <span class="hljs-keyword">let</span> queue = [];<br>    <span class="hljs-keyword">if</span>(root === <span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> res;<br>    queue.<span class="hljs-title function_">push</span>(root);<br>    <span class="hljs-keyword">while</span>(queue.<span class="hljs-property">length</span>) &#123;<br>        <span class="hljs-keyword">let</span> len = queue.<span class="hljs-property">length</span>;<br>        <span class="hljs-keyword">let</span> curLevel = [];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-keyword">let</span> node = queue.<span class="hljs-title function_">shift</span>();<br>            curLevel.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">val</span>);<br>            <span class="hljs-keyword">if</span>(node.<span class="hljs-property">left</span>) queue.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">left</span>);<br>            <span class="hljs-keyword">if</span>(node.<span class="hljs-property">right</span>) queue.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">right</span>);<br>        &#125;<br>        res.<span class="hljs-title function_">unshift</span>(curLevel)<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><p>最后改一下 push 的顺序就行</p><h3 id="3-二叉树的右视图"><a href="#3-二叉树的右视图" class="headerlink" title="3. 二叉树的右视图"></a>3. 二叉树的右视图</h3><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310211739435.png" alt="img"></p><p>依然是按照顶部到底部的顺序, 不要搞复杂了</p><p>这里就是当遍历到每一层最右边的节点时就加入到 curLevel 数组中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> rightSideView = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">let</span> res = [], queue = [];<br>    <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> res;<br>    queue.<span class="hljs-title function_">push</span>(root);<br>    <span class="hljs-keyword">while</span>(queue.<span class="hljs-property">length</span>) &#123;<br>        <span class="hljs-keyword">let</span> len = queue.<span class="hljs-property">length</span>;<br>        <span class="hljs-keyword">let</span> curLevel = [];<br>        <span class="hljs-keyword">while</span>(len--) &#123;<br>            <span class="hljs-keyword">let</span> node = queue.<span class="hljs-title function_">shift</span>();<br>            <span class="hljs-keyword">if</span>(!len) curLevel.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">val</span>);<br>            <span class="hljs-keyword">if</span>(node.<span class="hljs-property">left</span>) queue.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">left</span>);<br>            <span class="hljs-keyword">if</span>(node.<span class="hljs-property">right</span>) queue.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">right</span>);<br>        &#125;<br>        res.<span class="hljs-title function_">push</span>(curLevel);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="4-二叉树的层平均值"><a href="#4-二叉树的层平均值" class="headerlink" title="4. 二叉树的层平均值"></a>4. 二叉树的层平均值</h3><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310211739460.png" alt="img"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val, left, right) &#123;</span><br><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span><br><span class="hljs-comment"> *     this.left = (left===undefined ? null : left)</span><br><span class="hljs-comment"> *     this.right = (right===undefined ? null : right)</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">var</span> averageOfLevels = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">let</span> res = [], queue = [];<br>    queue.<span class="hljs-title function_">push</span>(root);<br>    <span class="hljs-keyword">while</span>(queue.<span class="hljs-property">length</span>) &#123;<br>        <span class="hljs-keyword">let</span> len = queue.<span class="hljs-property">length</span>;<br>        <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-keyword">let</span> node = queue.<span class="hljs-title function_">shift</span>();<br>            sum += node.<span class="hljs-property">val</span>;<br>            <span class="hljs-keyword">if</span>(node.<span class="hljs-property">left</span>) queue.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">left</span>);<br>            <span class="hljs-keyword">if</span>(node.<span class="hljs-property">right</span>) queue.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">right</span>);<br>        &#125;<br>        res.<span class="hljs-title function_">push</span>(sum / len)<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="5-N-叉树的层序遍历"><a href="#5-N-叉树的层序遍历" class="headerlink" title="5. N 叉树的层序遍历"></a>5. N 叉树的层序遍历</h3><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310211739433.png" alt="img"></p><blockquote><p> 跟模板没啥差别</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * // Definition for a Node.</span><br><span class="hljs-comment"> * function Node(val,children) &#123;</span><br><span class="hljs-comment"> *    this.val = val;</span><br><span class="hljs-comment"> *    this.children = children;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Node|null</span>&#125; <span class="hljs-variable">root</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[][]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> levelOrder = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">let</span> res = [], queue = [];<br>    <span class="hljs-keyword">if</span>(root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> res;<br>    queue.<span class="hljs-title function_">push</span>(root);<br>    <span class="hljs-keyword">while</span>(queue.<span class="hljs-property">length</span>) &#123;<br>        <span class="hljs-keyword">let</span> len = queue.<span class="hljs-property">length</span>;<br>        <span class="hljs-keyword">let</span> curLevel = [];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-keyword">let</span> node = queue.<span class="hljs-title function_">shift</span>();<br>            curLevel.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">val</span>);<br>          <span class="hljs-comment">// push所有子节点就行</span><br>            <span class="hljs-keyword">if</span>(node.<span class="hljs-property">children</span>) queue.<span class="hljs-title function_">push</span>(...node.<span class="hljs-property">children</span>)<br>        &#125;<br>        res.<span class="hljs-title function_">push</span>(curLevel);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="6-在每个树行中找最大值"><a href="#6-在每个树行中找最大值" class="headerlink" title="6. 在每个树行中找最大值"></a>6. 在每个树行中找最大值</h3><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310211739217.png" alt="img"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript">ar largestValues = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">let</span> res = [], queue = [];<br>    <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> res;<br>    queue.<span class="hljs-title function_">push</span>(root);<br>    <span class="hljs-keyword">while</span>(queue.<span class="hljs-property">length</span>) &#123;<br>        <span class="hljs-keyword">let</span> len = queue.<span class="hljs-property">length</span>;<br>        <span class="hljs-keyword">let</span> max = -<span class="hljs-title class_">Infinity</span>;  <span class="hljs-comment">// 注意有可能为负值, 所以不能取0</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-keyword">let</span> node = queue.<span class="hljs-title function_">shift</span>();<br>            max = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(max, node.<span class="hljs-property">val</span>);<br>            <span class="hljs-keyword">if</span>(node.<span class="hljs-property">left</span>) queue.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">left</span>);<br>            <span class="hljs-keyword">if</span>(node.<span class="hljs-property">right</span>) queue.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">right</span>);<br>        &#125;<br>        res.<span class="hljs-title function_">push</span>(max);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="7-填充每个节点的下一个右侧节点指针"><a href="#7-填充每个节点的下一个右侧节点指针" class="headerlink" title="7. 填充每个节点的下一个右侧节点指针"></a>7. 填充每个节点的下一个右侧节点指针</h3><p>这题将 “完美二叉树” 改为 “二叉树” 也没什么区别, 一模一样的代码 ~~</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310211739299.png" alt="img"></p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310211739194.png" alt="img"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * // Definition for a Node.</span><br><span class="hljs-comment"> * function Node(val, left, right, next) &#123;</span><br><span class="hljs-comment"> *    this.val = val === undefined ? null : val;</span><br><span class="hljs-comment"> *    this.left = left === undefined ? null : left;</span><br><span class="hljs-comment"> *    this.right = right === undefined ? null : right;</span><br><span class="hljs-comment"> *    this.next = next === undefined ? null : next;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Node</span>&#125; <span class="hljs-variable">root</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">Node</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> connect = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">let</span> queue = [];<br>    <span class="hljs-keyword">if</span>(root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root;<br>    queue.<span class="hljs-title function_">push</span>(root);<br>    <span class="hljs-keyword">while</span>(queue.<span class="hljs-property">length</span>) &#123;<br>        <span class="hljs-keyword">let</span> len = queue.<span class="hljs-property">length</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-keyword">let</span> node = queue.<span class="hljs-title function_">shift</span>();<br>          <span class="hljs-comment">// 因为前一个已经shift了, 后一个就是队首元素, 且要保证不是最后一个元素</span><br>            <span class="hljs-comment">// 如果是最后一个元素, 正好next就等于默认的null</span><br>            <span class="hljs-keyword">if</span>(i &lt; len - <span class="hljs-number">1</span>) node.<span class="hljs-property">next</span> = queue[<span class="hljs-number">0</span>]; <br>            <span class="hljs-keyword">if</span>(node.<span class="hljs-property">left</span>) queue.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">left</span>)<br>            <span class="hljs-keyword">if</span>(node.<span class="hljs-property">right</span>) queue.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">right</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="8-二叉树的最大深度"><a href="#8-二叉树的最大深度" class="headerlink" title="8. 二叉树的最大深度"></a>8. 二叉树的最大深度</h3><p>用层序遍历也挺简单, 最大深度就是层数</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310211739209.png" alt="img"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> maxDepth = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">let</span> queue = [], cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(root === <span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    queue.<span class="hljs-title function_">push</span>(root);<br>    <span class="hljs-keyword">while</span>(queue.<span class="hljs-property">length</span>) &#123;<br>        <span class="hljs-keyword">let</span> len = queue.<span class="hljs-property">length</span>;<br>        cnt++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-keyword">let</span> node = queue.<span class="hljs-title function_">shift</span>();<br>            <span class="hljs-keyword">if</span>(node.<span class="hljs-property">left</span>) queue.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">left</span>);<br>            <span class="hljs-keyword">if</span>(node.<span class="hljs-property">right</span>) queue.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">right</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="9-二叉树的最小深度"><a href="#9-二叉树的最小深度" class="headerlink" title="9. 二叉树的最小深度"></a>9. 二叉树的最小深度</h3><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310211739223.png" alt="img"></p><p>如果某一层的节点没有左右子节点, 那么最小深度就是这一层的层数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> minDepth = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">let</span> queue = [], cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    queue.<span class="hljs-title function_">push</span>(root);<br>    <span class="hljs-keyword">while</span>(queue.<span class="hljs-property">length</span>) &#123;<br>        <span class="hljs-keyword">let</span> len = queue.<span class="hljs-property">length</span>;<br>        cnt++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-keyword">let</span> node = queue.<span class="hljs-title function_">shift</span>();<br>            <span class="hljs-comment">// 如果某一层的节点没有左右子节点, 那么最小深度就是这一层的层数</span><br>            <span class="hljs-keyword">if</span>(!node.<span class="hljs-property">left</span> &amp;&amp; !node.<span class="hljs-property">right</span>)<span class="hljs-keyword">return</span> cnt;<br>            <span class="hljs-keyword">if</span>(node.<span class="hljs-property">left</span>) queue.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">left</span>);<br>            <span class="hljs-keyword">if</span>(node.<span class="hljs-property">right</span>) queue.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">right</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>over</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>介绍下 HTTP 的演化过程和优化？</title>
    <link href="/2023/10/20/HTTP%E6%BC%94%E5%8C%96/"/>
    <url>/2023/10/20/HTTP%E6%BC%94%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h3 id="1-HTTP-x2F-1-0-存在的问题"><a href="#1-HTTP-x2F-1-0-存在的问题" class="headerlink" title="1. HTTP&#x2F;1.0 存在的问题"></a>1. HTTP&#x2F;1.0 存在的问题</h3><ul><li>队头阻塞问题：因为只有⼀个连接，所以如果有⼀个请求被阻塞，后续请求也会被阻塞。</li><li>无法多路复用：只能按顺序传输⼀个请求和响应，无法同时传输多个请求和响应。</li><li>每次请求需要新建连接：每次请求都需要新建连接，连接的建⽴和关闭过程会消耗时间。</li></ul><h3 id="2-HTTP-x2F-1-0-到-HTTP-x2F-1-1-的优化："><a href="#2-HTTP-x2F-1-0-到-HTTP-x2F-1-1-的优化：" class="headerlink" title="2. HTTP&#x2F;1.0 到 HTTP&#x2F;1.1 的优化："></a>2. HTTP&#x2F;1.0 到 HTTP&#x2F;1.1 的优化：</h3><ul><li><strong>持久连接</strong>：在 HTTP&#x2F;1.0 中，每次请求都需要建⽴⼀个新的TCP连接，⽽在 HTTP&#x2F;1.1 中，引⼊了持久连接（也称为复⽤连接），这样可以在⼀个<code>TCP</code>连接上发送多个<code>HTTP</code>请求和响应，减少了<code>TCP</code>连接的建立和关闭所需的时间和资源消耗。 </li><li>**管线化 [1]**：在 HTTP&#x2F;1.1 中，⽀持请求管线化，即客户端可以同时发送多个请求，在服务端处理完第⼀个请求之前不必等待其它请求的返回。这种⽅式虽然提⾼了性能，但由于各个请求之间存在依赖关系，当其中⼀个请求出错时，会导致后续请求都失败.</li><li><strong>缓存方面</strong>，在 http1.0 中主要使用 header 里的 If-Modified-Since、Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略，例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。</li><li><strong>支持 Host 字段:</strong>  http1.1 中新增了 host 字段，通过在请求头中添加 Host 字段来区分不同的主机。用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此有了 host 字段，这样就可以将请求发往到同一台服务器上的不同网站。</li><li><strong>支持断点续传</strong> :  HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能。http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li><li><strong>新增 HTTP 方法</strong> :  http1.1 相对于 http1.0 还新增了很多请求方法，如 PUT、HEAD、OPTIONS 等。</li></ul><p><strong>什么是管线化(管道网络运输)?</strong></p><blockquote><p>管道（pipeline）网络传输是指：可以在同一个 <code>TCP</code> 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。但是服务器还是按照顺序回应请求。如果前面的回应特别慢，后面就会有许多请求排队等着。这称为队头堵塞。</p></blockquote><h3 id="3-HTTP-x2F-1-1-到-HTTP-x2F-2-的优化："><a href="#3-HTTP-x2F-1-1-到-HTTP-x2F-2-的优化：" class="headerlink" title="3. HTTP&#x2F;1.1 到 HTTP&#x2F;2 的优化："></a>3. HTTP&#x2F;1.1 到 HTTP&#x2F;2 的优化：</h3><ul><li><strong>二进制协议</strong>：HTTP&#x2F;2 是一个二进制协议。在 HTTP&#x2F;1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP&#x2F;2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础。</li><li><strong>数据流：</strong> HTTP&#x2F;2 使用了数据流的概念，因为 HTTP&#x2F;2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP&#x2F;2 将每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送时，都必须标记数据流 ID ，用来区分它属于哪个数据流。</li><li><strong>多路复用</strong>：HTTP&#x2F;1.x 中⼀个 TCP 连接只能同时处理⼀个请求，而 HTTP&#x2F;2 中⽀持多路复用，即同⼀个连接客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送,  这样就避免了”队头堵塞”[1] 的问题。</li><li><strong>头信息压缩：</strong> HTTP&#x2F;2 实现了头信息压缩，由于 HTTP 1.1 协议不带状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP&#x2F;2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表(首部表)，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了。</li><li><strong>服务器推送：</strong> HTTP&#x2F;2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送提前给客户端推送必要的资源，这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服务器主动推送的是静态资源，和 WebSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的。</li></ul><p><strong>什么是队头堵塞?</strong></p><blockquote><p>队头阻塞是由 HTTP 基本的“请求 - 应答”模型所导致的。HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列。队列里的请求是没有优先级的，只有入队的先后顺序，排在最前面的请求会被最优先处理。如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本，造成了队头堵塞的现象。</p></blockquote><p> <strong>页面有多张图片，HTTP是怎样的加载表现？</strong></p><ul><li>在HTTP 1下，浏览器对一个域名下最大<code>TCP</code>连接数为6，所以会请求多次。可以用多域名部署解决。这样可以提高同时请求的数目，加快页面图片的获取速度。</li><li>在HTTP 2下，可以一瞬间加载出来很多资源，因为，HTTP2支持<strong>多路复用</strong>，可以在一个TCP连接中发送多个HTTP请求。</li></ul><p><strong>HTTP2的头部压缩算法是怎样的？</strong></p><p><code>HTTP2</code>的头部压缩是<code>HPACK</code>算法。在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，采用<strong>哈夫曼编码</strong>来压缩整数和字符串，可以达到50%~90%的高压缩率。具体来说 : </p><ul><li>在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，<strong>对于相同的数据，不再通过每次请求和响应发送；</strong></li><li>首部表在<code>HTTP/2</code>的连接存续期内始终存在，由客户端和服务器共同渐进地更新；</li><li>每个新的首部键值对要么被追加到当前表的末尾，要么替换表中之前的值。</li></ul><h3 id="4-HTTP-x2F-2-到-HTTP-x2F-3-的优化："><a href="#4-HTTP-x2F-2-到-HTTP-x2F-3-的优化：" class="headerlink" title="4. HTTP&#x2F;2 到 HTTP&#x2F;3 的优化："></a>4. HTTP&#x2F;2 到 HTTP&#x2F;3 的优化：</h3><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310202352356.png" alt="img"></p><blockquote><p>了解</p></blockquote><p><code>HTTP/3</code>基于<code>UDP</code>协议实现了类似于<code>TCP</code>的多路复用数据流、传输可靠性等功能，这套功能被称为<code>QUIC</code>协议。</p><ul><li><strong>流量控制、传输可靠性功能</strong>：<code>QUIC</code>在<code>UDP</code>的基础上增加了一层来保证数据传输可靠性，它提供了数据包重传、拥塞控制、以及其他一些<code>TCP</code>中的特性。</li><li><strong>集成</strong><code>**TLS**</code><strong>加密功能</strong>：目前<code>QUIC</code>使用<code>TLS1.3</code>，减少了握手所花费的<code>RTT</code>数。</li><li><strong>多路复用</strong>：同一物理连接上可以有多个独立的逻辑数据流，实现了数据流的单独传输，解决了<code>TCP</code>的队头阻塞问题。</li><li><strong>快速握手</strong>：由于基于<code>UDP</code>，可以实现使用<code>0 ~ 1</code>个<code>RTT</code>来建立连接。</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你了解浏览器安全吗?</title>
    <link href="/2023/10/18/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8/"/>
    <url>/2023/10/18/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="1-什么是-XSS-攻击？"><a href="#1-什么是-XSS-攻击？" class="headerlink" title="1.  什么是 XSS 攻击？"></a>1.  什么是 XSS 攻击？</h2><blockquote><p>概念</p></blockquote><p>XSS 攻击指的是<strong>跨站脚本攻击</strong>，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 <code>cookie</code> 等。</p><p>XSS 的<strong>本质</strong>是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。</p><p>攻击者可以通过这种攻击方式可以进行以下操作：</p><ul><li>获取页面的数据，如<code>DOM</code>、<code>cookie</code>、<code>localStorage</code>；</li><li><code>DOS</code>攻击，发送合理请求，占用服务器资源，从而使用户无法访问服务器；</li><li>破坏页面结构；</li><li>流量劫持（将链接指向某网站）；</li></ul><blockquote><p>攻击类型</p></blockquote><p><code>XSS</code> 可以分为<strong>存储型</strong>、<strong>反射型</strong>和 <strong>DOM</strong> 型：</p><ul><li>存储型指的是恶意脚本会存储在目标服务器上，当浏览器请求数据时，脚本从服务器传回并执行。</li><li>反射型指的是攻击者诱导用户访问一个带有恶意代码的 URL 后，服务器端接收数据后处理，然后把带有恶意代码的数据发送到浏览器端，浏览器端解析这段带有 XSS 代码的数据后当做脚本执行，最终完成 XSS 攻击。 </li><li>DOM 型指的通过修改页面的 DOM 节点形成的 XSS。</li></ul><p><strong>1）存储型 XSS 的攻击步骤：</strong></p><ol><li>攻击者将恶意代码提交到⽬标⽹站的数据库中。</li><li>⽤户打开⽬标⽹站时，⽹站服务端将恶意代码从<strong>数据库</strong>取出，拼接在 <code>**HTML**</code> 中返回给浏览器。</li><li>⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。</li><li>恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。</li></ol><p>这种攻击常⻅于带有⽤户保存数据的⽹站功能，如论坛发帖、商品评论、⽤户私信等。</p><p><strong>2）反射型 XSS 的攻击步骤：</strong></p><ol><li>攻击者构造出特殊的 URL，其中包含恶意代码。</li><li>⽤户打开带有恶意代码的 URL 时，⽹站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。</li><li>⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。</li><li>恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。</li></ol><p>反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库⾥，反射型 XSS 的恶意代码存在 <strong>URL</strong> ⾥。</p><p>反射型 XSS 漏洞常⻅于通过 URL 传递参数的功能，如⽹站搜索、跳转等。 由于需要⽤户主动打开恶意的 URL 才能⽣效，攻击者往往会结合多种⼿段诱导⽤户点击。</p><p><strong>3）DOM 型 XSS 的攻击步骤：</strong></p><ol><li>攻击者构造出特殊的 URL，其中包含恶意代码。</li><li>⽤户打开带有恶意代码的 URL。</li><li>⽤户浏览器接收到响应后解析执⾏，<strong>前端</strong> <code>**JavaScript**</code> 取出 URL 中的恶意代码并执⾏。</li><li>恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。</li></ol><p>DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执⾏恶意代码由<strong>浏览器端</strong>完成，属于前端JavaScript ⾃身的安全漏洞，⽽其他两种 XSS 都属于服务端的安全漏洞。</p><h2 id="2-如何防御-XSS-攻击？"><a href="#2-如何防御-XSS-攻击？" class="headerlink" title="2. 如何防御 XSS 攻击？"></a>2. 如何防御 XSS 攻击？</h2><p>可以看到<code>XSS</code>危害如此之大， 那么在开发网站时就要做好防御措施，具体措施如下：</p><ol><li>可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服务器端拼接后返回（不使用服务端渲染）。另一种是对需要插入到 HTML 中的代码做好充分的<strong>转义</strong>。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。</li><li>使用 <code>**CSP**</code> ，CSP 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。</li></ol><ul><li>CSP 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要<strong>配置规则</strong>，如何拦截由浏览器自己来实现。</li><li>通常有两种方式来开启 <code>CSP</code>，一种是设置 HTTP 首部中的 <code>Content-Security-Policy</code>，一种是设置 <code>meta</code> 标签的方式</li></ul><ol start="3"><li>对一些敏感信息进行保护，比如 <code>cookie</code> 使用 <code>http-only</code>，使得脚本无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。</li></ol><h2 id="3-什么是-CSRF-攻击？"><a href="#3-什么是-CSRF-攻击？" class="headerlink" title="3. 什么是 CSRF 攻击？"></a>3. 什么是 CSRF 攻击？</h2><blockquote><p>概念</p></blockquote><p>CSRF 攻击指的是<strong>跨站请求伪造攻击</strong>，攻击者利用受害者在登录状态下访问恶意网站，通过构造一个伪装成受害者已经授权的请求来欺骗服务器执行非法操作，从而实现攻击目的。</p><p>CSRF 攻击通常需要攻击者构造特定的请求，诱使用户点击或触发。</p><blockquote><ol><li>用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；</li><li>在用户信息通过验证后，网站A产生<code>Cookie</code>信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；(比如登录银行网站)</li><li>用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；(网站 B 中含有恶意代码)</li><li>网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A(比如说隐藏的表单, 给账户转钱, 或者修改密码)</li><li>浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。</li></ol></blockquote><p>CSRF 攻击的<strong>本质是利用 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。</strong></p><blockquote><p> 攻击类型</p></blockquote><p>常见的 <code>CSRF</code> 攻击有<strong>三种</strong>：</p><ul><li><code>GET</code> 类型的 <code>CSRF</code> 攻击，比如在网站中的一个 <code>img</code> 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交。</li><li><code>POST</code> 类型的 <code>CSRF</code> 攻击，比如构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。</li><li>链接类型的 <code>CSRF </code>攻击，比如在 <code>a</code> 标签的 <code>href</code> 属性里构建一个请求，然后诱导用户去点击。</li></ul><h2 id="4-如何防御-CSRF-攻击？"><a href="#4-如何防御-CSRF-攻击？" class="headerlink" title="4. 如何防御 CSRF 攻击？"></a>4. 如何防御 CSRF 攻击？</h2><p><strong>CSRF 攻击可以使用以下方法来防护：</strong></p><ol><li><strong>进行同源检测</strong>，服务器根据 <code>http</code> 请求头中 <code>origin</code> 或者 <code>referer</code> 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 <code>origin</code> 或者 <code>referer</code> 信息都不存在的时候，直接阻止请求。这种方式的缺点是有些情况下 <code>referer</code> 可以被伪造，同时还会把搜索引擎的链接也给屏蔽了。所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。（<code>Referer</code> 字段会告诉服务器该网页是从哪个页面链接过来的）</li></ol><p>浏览器同源策略：协议、域名和端口都相同即同源；</p><p>Cookie同源策略：域名相同即同源；</p><p>在HTTP协议中，每个异步请求都会携带两个header, 用来标记来源域名：</p><ul><li><code>Origin Header</code></li><li><code>Referer Header</code></li></ul><ol start="2"><li><strong>使用 CSRF Token 进行验证</strong>，服务器向用户返回一个随机数 Token ，<strong>当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证</strong>。这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果请求经过负载平衡转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证了。这种情况可以通过改变 token 的构建方式来解决。</li></ol><p>请求中携带token </p><ul><li>对于GET请求，将token附在请求地址之后，如：<code>http://url?token=tokenValue</code></li><li>对于POST请求，要在Form表单后面加上 。</li></ul><p>服务端验证token是否正确</p><ul><li>服务端拿到客户端给的token后，先解密token, 再比对随机字符串是否一致、时间是否有效，如果字符串对比一致且在有效期内，则说明token正确。</li></ul><ol start="3"><li><strong>在设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三方使用</strong>，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title class_">Set</span>-<span class="hljs-title class_">Cookie</span>: <span class="hljs-title class_">SameSite</span> = <span class="hljs-title class_">Strict</span>;<br><span class="hljs-title class_">Set</span>-<span class="hljs-title class_">Cookie</span>: <span class="hljs-title class_">SameSite</span> = <span class="hljs-title class_">Lax</span>;<br><span class="hljs-title class_">Set</span>-<span class="hljs-title class_">Cookie</span>: <span class="hljs-title class_">SameSite</span> = <span class="hljs-title class_">None</span>; <span class="hljs-title class_">Secure</span>  <span class="hljs-comment">// 有效</span><br></code></pre></td></tr></table></figure><ul><li>Strict： 最为严格，完全禁止第三方Cookie, 跨站点时，任何情况都不发送Cookie;</li><li>Lax： 限制稍微宽松，大多数情况下时不发送第三方Cookie的，除了a链接、预加载请求和GET表单；</li><li>None： 关闭SameSite属性，但必须同时设置Secure属性</li></ul><ol start="4"><li><strong>对 Cookie 进行双重验证</strong>，服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。并且这种方法比 CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 <code>XSS</code> 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。</li></ol><blockquote><p>除了 XSS 和 CSRF , iframe 的滥用和恶意第三方库也可能引起前端安全的问题, 这里就不叙述了。</p></blockquote><h2 id="5-什么是中间人攻击？如何防范中间人攻击？"><a href="#5-什么是中间人攻击？如何防范中间人攻击？" class="headerlink" title="5. 什么是中间人攻击？如何防范中间人攻击？"></a>5. 什么是中间人攻击？如何防范中间人攻击？</h2><p>中间⼈ (Man-in-the-middle attack, MITM) 是指攻击者与通讯的两端分别创建独⽴的联系, 并交换其所收到的数据, 使通讯的两端认为他们正在通过⼀个私密的连接与对⽅直接对话, 但事实上整个会话都被攻击者完全控制。在中间⼈攻击中，<strong>攻击者可以拦截通讯双方的通话并插⼊新的内容。</strong></p><p>攻击者不仅能获得双方的通信信息，还能修改通信信息。</p><blockquote><p>攻击过程如下:</p></blockquote><ul><li>客户端发送请求到服务端，请求被中间⼈截获</li><li>服务器向客户端发送公钥</li><li>中间⼈截获公钥，保留在⾃⼰⼿上。然后⾃⼰⽣成⼀个<strong>伪造的</strong>公钥，发给客户端</li><li>客户端收到伪造的公钥后，⽣成加密hash值发给服务器</li><li>中间⼈获得加密hash值，⽤⾃⼰的私钥解密获得真秘钥,同时⽣成<strong>假的</strong>加密hash值，发给服务器</li><li>服务器⽤私钥解密获得假密钥,然后加密数据传输给客户端</li></ul><h2 id="6-网络劫持有哪几种，如何防范？"><a href="#6-网络劫持有哪几种，如何防范？" class="headerlink" title="6. 网络劫持有哪几种，如何防范？"></a>6. 网络劫持有哪几种，如何防范？</h2><p>⽹络劫持分为<strong>两种</strong>:</p><p>（1）<strong>DNS劫持</strong>: </p><p>输⼊京东被强制跳转到淘宝这就属于<code>dns</code>劫持</p><ul><li>DNS强制解析: 通过修改运营商的本地DNS记录，来引导⽤户流量到缓存服务器</li><li><code>302</code>跳转的⽅式: 通过监控⽹络出⼝的流量，分析判断哪些内容是可以进⾏劫持处理的,再对劫持的内存发起<code>302</code>跳转的回复，引导⽤户获取内容</li></ul><p>（2）<strong>HTTP劫持</strong>: </p><p>访问⾕歌但是⼀直有贪玩蓝⽉的⼴告 , 由于http明⽂传输,运营商会修改你的http响应内容(即加⼴告)</p><p><code>DNS</code>劫持由于涉嫌违法，已经被监管起来，现在很少会有<code>DNS</code>劫持，⽽<code>http</code>劫持依然⾮常盛⾏，最有效的办法就是全站<code>HTTPS</code>，将<code>HTTP</code>加密，这使得运营商⽆法获取明⽂，就⽆法劫持你的响应内容。</p>]]></content>
    
    
    <categories>
      
      <category>浏览器原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于浏览器的单进程/多进程架构</title>
    <link href="/2023/10/17/%E6%B5%8F%E8%A7%88%E5%99%A8--/"/>
    <url>/2023/10/17/%E6%B5%8F%E8%A7%88%E5%99%A8--/</url>
    
    <content type="html"><![CDATA[<p>Chrome打开一个页面需要启动多少进程？</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310171854683.png" alt="img"></p><p><strong>仅仅打开了1个页面，为什么有4个进程？</strong></p><p>在解答这个问题之前，我们需要了解一下进程与线程的概念。</p><h3 id="1-进程和线程"><a href="#1-进程和线程" class="headerlink" title="1. 进程和线程"></a>1. 进程和线程</h3><p>计算机中的并行处理就是同一时刻处理多个任务, 比如我们要计算三个表达式的值，并显示出结果。</p><ul><li>正常情况下程序可以使用<strong>单线程</strong>来处理，也就是分四步按照顺序分别执行这四个任务。</li><li>但如果采用<strong>多线程</strong>，我们只需分“两步走” : 第一步，使用三个线程同时执行前三个任务；第二步，再执行第四个显示任务。</li></ul><p><strong>通过对比发现用单线程执行需要四步，而使用多线程只需要两步。因此，使用并行处理能大大提升性能。</strong></p><p>多线程可以并行处理任务，但是线程是不能单独存在的，它是由进程来启动和管理的。</p><blockquote><p>什么是进程呢?</p></blockquote><p>一个<strong>进程</strong>就是一个程序的运行实例。</p><p>详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。</p><blockquote><p>单线程与多线程的进程对比图</p></blockquote><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310171854780.png" alt="img"></p><p><strong>从图中可以看到，线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率。</strong></p><p><strong>进程和线程之间的关系有以下4个特点。</strong></p><ol><li><strong>进程中的任意一线程执行出错，都会导致整个进程的崩溃。</strong></li><li><strong>线程之间共享进程中的数据。</strong></li><li><strong>当一个进程关闭之后，操作系统会回收进程所占用的内存。</strong></li></ol><ul><li>当一个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。</li></ul><ol start="4"><li><strong>进程之间的内容相互隔离</strong></li></ol><ul><li>正是因为进程之间的数据是严格隔离的，所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进行数据的通信这时候，就需要使用用于进程间通信（IPC）的机制了。</li></ul><h3 id="2-单进程浏览器时代"><a href="#2-单进程浏览器时代" class="headerlink" title="2. 单进程浏览器时代"></a>2. 单进程浏览器时代</h3><p>单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里些模块包含了网络、插件、JavaScript运行环境、渲染引擎和页面等。<img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310171854877.png" alt="img"></p><p>如此多的功能模块运行在一个进程里，是导致单进程浏览器<strong>不稳定、不流畅和不安全</strong>的一个主要因素。</p><p><strong>不稳定</strong></p><ul><li>早期浏览器需要借助于插件来实现诸如Web视频、Web游戏等各种强大的功能，但是插件是最容易出问题的模块，并且还运行在浏览器进程之中，所以一个插件的意外崩溃会引起整个浏览器的崩溃</li><li>除了插件之外，渲染引擎模块也是不稳定的，通常一些复杂的JavaScript代码就有可能引起渲染引擎模块的崩溃。和插件一样，渲染引擎的崩溃也会导致整个浏览器的崩溃。</li></ul><p><strong>不流畅</strong></p><ul><li>单进程浏览器中所有页面的渲染模块、JavaScript执行环境以及插件都是运行在同一个线程中的，这就意味着同一时刻只能有一个模块可以执行。<strong>当有脚本发生无限循环时，</strong>它会独占整个线程，这样导致其他运行在该线程中的模块就没有机会被执行。因为浏览器中所有的页面都运行在该线程中，所以这些页面都没有机会去执行任务，这样就会导致整个浏览器失去响应，变卡顿。</li><li>除了上述脚本或者插件会让单进程浏览器变卡顿外，<strong>页面的内存泄漏</strong>也是单进程变慢的一个重要原因。通常浏览器的内核都是非常复杂的，运行一个复杂点的页面再关闭页面，会存在内存不能完全回收的情况，这样导致的问题是使用时间越长，内存占用越高，浏览器会变得越慢。</li></ul><p><strong>不安全</strong></p><ul><li>插件可以使用C&#x2F;C++等代码编写，<strong>通过插件可以获取到操作系统的任意资源，</strong>当你在页面运行一个插件时也就意味着这个插件能完全操作你的电脑。如果是个恶意插件，那么它就可以释放病毒、窃取你的账号密码，引发安全性问题。</li><li><strong>页面脚本可以通过浏览器的漏洞来获取系统权限</strong>，这些脚本获取系统权限之后也可以对你的电脑做一些恶意的事情，同样也会引发安全问题。</li></ul><blockquote><p>好在现代浏览器已经解决了这些问题，是如何解决的呢？这就得聊聊我们这个“多进程浏览器时代”了。</p></blockquote><h3 id="3-多进程浏览器时代"><a href="#3-多进程浏览器时代" class="headerlink" title="3. 多进程浏览器时代"></a>3. 多进程浏览器时代</h3><blockquote><p>多进程浏览器架构的特点</p></blockquote><p><strong>稳定</strong></p><ul><li>由于进程是相互隔离的，所以当一个页面或者插件崩溃时，影响到的仅仅是当前的页面进程或者插件进程，并不会影响到浏览器和其他页面，这就完美地解决了页面或者插件的崩溃会导致整个浏览器崩溃，也就是不稳定的问题。</li></ul><p><strong>流畅</strong></p><ul><li>JavaScript也是运行在渲染进程中的，所以即使<strong>JavaScript阻塞了渲染进程</strong>，影响到的也只是当前的渲染页面，而并不会影响浏览器和其他页面，因为其他页面的脚本是运行在它们自己的渲染进程中的。所以即使Chrome中运行上面死循环的脚本时，没有响应的仅仅也是当前的页面。</li><li>对于<strong>内存泄漏的解决方法</strong>那就更简单了，因为当关闭一个页面时，整个渲染进程也会被关闭，之后该进程所占用的内存都会被系统回收，这样就轻松解决了浏览器页面的内存泄漏问题。</li></ul><p><strong>安全</strong></p><ul><li>采用多进程架构的额外好处是可以使用安全沙箱。沙箱可以看成是操作系统给进程上了一把锁，沙箱里面的程序可以运行，但是不能在你的硬盘上写入任何数据，也不能在敏感位置读取任何数据。</li><li>例如你的文档和桌面。Chrome把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。</li></ul><blockquote><p>目前的多进程架构</p></blockquote><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310171854713.png" alt="img"></p><p>从图中可以看出，最新的Chrome浏览器包括：</p><p>1个浏览器（Browser）主进程、1个 GPU 进程、1个网络（NetWork）进程、多个渲染进程和多个插件进程。</p><blockquote><p>下面来逐个分析下这几个进程的功能：</p></blockquote><p><strong>Browser浏览器进程</strong></p><p>主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。</p><p><strong>渲染进程</strong></p><p>核心任务是将 HTML、CSS 和 JS 转换为用户可以与之交互的网页，排版引擎Blink和JS引擎V8都是运行在该进程中，默认情况下，Chrome会为每个Tab标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</p><p><strong>GPU进程</strong></p><p>Chrome刚开始发布的时候是没有GPU进程的。而GPU的使用初衷是为了实现3D CSS的效果，只是随后网页、Chrome的UI界面都选择采用GPU来绘制，这使得GPU成为浏览器普遍的需求。最后，Chrome在其多进程架构上也引入了GPU进程。</p><p><strong>NetWork网络进程</strong></p><p>主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</p><p><strong>插件进程</strong></p><p>主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。</p><p>讲到这里，现在应该就明白文章开头提到的问题了：</p><p><strong>仅仅打开了1个页面，为什么有4个进程？</strong></p><p>开1个页面至少需要1个网络进程、1个浏览器进程、1个GPU进程以及1个渲染进程，共4个；如果打开的页面有运行插件的话，还需要再加上1个插件进程。</p><h3 id="4-渲染进程中的线程"><a href="#4-渲染进程中的线程" class="headerlink" title="4. 渲染进程中的线程"></a>4. 渲染进程中的线程</h3><p>我们平时看到的浏览器呈现出页面过程中，大部分工作都是在渲染进程中完成，所以我们来看一下渲染进程中的线程。</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310171854633.png" alt="img"></p><p><strong>GUI渲染线程：</strong></p><ul><li>负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。</li><li>当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行</li><li>注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时&#x2F;执行完时立即被执行。</li></ul><p><strong>JS引擎线程：</strong></p><ul><li><p>也称为JS内核，负责处理Javascript脚本程序。如V8引擎</p></li><li><p>JS引擎线程负责解析Javascript脚本，运行代码。</p></li><li><p>JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序</p></li><li><p>同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</p></li></ul><p><strong>事件触发线程</strong></p><ul><li>归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）</li><li>当<code>js</code>代码在解析时，遇到事件比如鼠标事件时，会将这些任务添加到事件触发线程中</li><li>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理</li><li>注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）</li></ul><p><strong>定时触发器线程</strong></p><ul><li>指setInterval与setTimeout所在线程</li><li>浏览器定时计数器并不是由JavaScript引擎计数的，因为JS引擎是单线程的，所以如果处于阻塞状态，那么就会影响记计时的准确，所以需要单独的线程来负责计时器工作。</li><li>计时完毕后，添加到事件队列中，等待JS引擎空闲后执行。</li><li>注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。</li></ul><p><strong>异步http请求线程：</strong></p><ul><li>XMLHttpRequest连接后浏览器开的一个线程，比如请求有回调函数，异步线程就会将回调函数加入事件队列，等待JS引擎空闲执行</li><li>将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。</li></ul>]]></content>
    
    
    <categories>
      
      <category>浏览器原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>进程/线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你了解发布-订阅模式吗?</title>
    <link href="/2023/10/16/%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%E5%90%97/"/>
    <url>/2023/10/16/%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%E5%90%97/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是发布订阅模式"><a href="#什么是发布订阅模式" class="headerlink" title="什么是发布订阅模式"></a>什么是发布订阅模式</h3><blockquote><p>在软件架构中，发布&#x2F;订阅（Publish–subscribe pattern）是一种消息范式，消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者）。而是将发布的消息分为不同的类别，无需了解哪些订阅者（如果有的话）可能存在。同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者（如果有的话）存在。</p></blockquote><p>发布-订阅模式的发布和订阅都由统一的一个调度中心来处理，那也就是说这个模式呢是有三部分组成的</p><ul><li>发布者：将消息事件发布到调度中心</li><li>订阅者： 把自己想关注的消息事件，注册到调度中心</li><li>调度中心：处理事件注册与发布</li></ul><blockquote><p>有什么作用呢，就是在异步编程中实现更松的解耦</p></blockquote><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310162023791.png" alt="img"></p><h3 id="与观察者模式的区别❗"><a href="#与观察者模式的区别❗" class="headerlink" title="与观察者模式的区别❗"></a>与观察者模式的区别❗</h3><ul><li><p><strong>实现方式：</strong>在观察者模式中，观察者（Observer）通常会直接订阅（Subscribe）主题（Subject）的更新，而主题则会在状态改变时直接调用观察者的方法。而在发布订阅模式中，发布者（Publisher）和订阅者（Subscriber）通常不会直接交互，而是<strong>通过一个调度中心（Message broker 或 Event bus）来进行通信。</strong></p></li><li><p><strong>耦合性：</strong>观察者模式中的观察者和主题之间的耦合性相对较高，因为观察者需要直接订阅主题。而在发布订阅模式中，由于引入了调度中心，发布者和订阅者之间的耦合性较低。</p></li><li><p><strong>使用场景：</strong>观察者模式通常用于处理较为简单的一对多依赖关系，例如GUI中的事件处理等。而发布订阅模式则更适合处理复杂的异步处理和跨系统通信等场景，例如消息队列、事件驱动架构等。</p></li></ul><p><strong><code>观察者模式：直接和公司签</code></strong><br><strong><code>订阅者模式：签大厂的外包公司</code></strong></p><h3 id="JS实现发布订阅模式"><a href="#JS实现发布订阅模式" class="headerlink" title="JS实现发布订阅模式"></a>JS实现发布订阅模式</h3><blockquote><p>先列举下需要实现发布-订阅模式的思路，目的呢就是实现三个方法，添加、删除、派发</p></blockquote><p>🐾<strong>第一步：</strong> 实现发布订阅模式的第一步是创建一个可以存储事件及其对应回调函数的容器。在JavaScript中，我们可以使用一个对象来作为这个容器。每个事件都是对象的一个属性，其值是一个数组，用来存储所有订阅了该事件的回调函数。</p><p>🐾<strong>第二步</strong>： 第二步是添加一个名为subscribe的方法，该方法允许监听器订阅特定的事件。这个方法需要两个参数：一个是事件名，另一个是当事件被触发时应该调用的回调函数。</p><p>🐾<strong>第三步：</strong> 第三步是实现取消订阅的功能：添加一个名为unsubscribe的方法来实现这个功能。这个方法需要两个参数：一个是事件名，另一个是要取消订阅的回调函数。</p><p>🐾<strong>第四步：</strong> 第四步是实现事件发布的功能，我们可以添加一个名为publish的方法来实现这个功能。这个方法需要两个参数：一个是事件名，另一个是当事件被触发时应该传递给回调函数的数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PubSub</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span> = &#123;&#125;;<br>  &#125;<br><br>  <span class="hljs-title function_">subscribe</span>(<span class="hljs-params">event, callback</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event]) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event] = [];<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event].<span class="hljs-title function_">push</span>(callback);<br>  &#125;<br><br>  <span class="hljs-title function_">unsubscribe</span>(<span class="hljs-params">event, callback</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event]) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;事件无效&#x27;</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event].<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">cb</span> =&gt;</span> cb !== callback);<br>  &#125;<br><br>  <span class="hljs-title function_">publish</span>(<span class="hljs-params">event, data</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event]) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;该事件未注册&#x27;</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event].<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">callback</span> =&gt;</span> <span class="hljs-title function_">callback</span>(...data));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>🐾使用示例： 至此我们已经完成了一个基本的发布订阅模式，下面展示一下它的具体使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建一个新的PubSub实例</span><br><span class="hljs-keyword">const</span> pubsub = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PubSub</span>();<br><br><span class="hljs-comment">// 定义两个回调函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">callback1</span>(<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;这里是第一个回调: &#x27;</span> + data);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">callback2</span>(<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;这里是第二个回调: &#x27;</span> + data);<br>&#125;<br><br><span class="hljs-comment">// 订阅一个事件</span><br>pubsub.<span class="hljs-title function_">subscribe</span>(<span class="hljs-string">&#x27;myEvent&#x27;</span>, callback1);<br>pubsub.<span class="hljs-title function_">subscribe</span>(<span class="hljs-string">&#x27;myEvent&#x27;</span>, callback2);<br><br><span class="hljs-comment">// 输出两个回调函数的 console</span><br>pubsub.<span class="hljs-title function_">publish</span>(<span class="hljs-string">&#x27;myEvent&#x27;</span>, <span class="hljs-string">&#x27;Hello, world!&#x27;</span>); <br><br><span class="hljs-comment">// 取消订阅 callback1</span><br>pubsub.<span class="hljs-title function_">unsubscribe</span>(<span class="hljs-string">&#x27;myEvent&#x27;</span>, callback1);<br><br><span class="hljs-comment">// callback1 的订阅被取消了，仅打印 callback2 的 console</span><br>pubsub.<span class="hljs-title function_">publish</span>(<span class="hljs-string">&#x27;myEvent&#x27;</span>, <span class="hljs-string">&#x27;Hello, world!&#x27;</span>); <br></code></pre></td></tr></table></figure><h3 id="错误处理与功能优化"><a href="#错误处理与功能优化" class="headerlink" title="错误处理与功能优化"></a>错误处理与功能优化</h3><p>首先是类型判断与错误处理，我们应当检查参数的类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PubSub</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span> = &#123;&#125;;<br>  &#125;<br><br>  <span class="hljs-title function_">subscribe</span>(<span class="hljs-params">event, callback</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> event !== <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Event name must be a string&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Callback must be a function&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event]) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event] = [];<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event].<span class="hljs-title function_">push</span>(callback);<br>  &#125;<br><br>  <span class="hljs-title function_">unsubscribe</span>(<span class="hljs-params">event, callback</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> event !== <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Event name must be a string&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Callback must be a function&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event]) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event].<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">cb</span> =&gt;</span> cb !== callback);<br>  &#125;<br><br>  <span class="hljs-title function_">publish</span>(<span class="hljs-params">event, data</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> event !== <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Event name must be a string&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event]) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event].<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">callback</span> =&gt;</span> <span class="hljs-title function_">callback</span>(data));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>开发中我们会遇到一些一次性事件，不会被触发第二次了，我们可以加一个参数来省去手动清除事件的负担：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">publish</span>(<span class="hljs-params">event, data, once = <span class="hljs-literal">false</span></span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> event !== <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Event name must be a string&#x27;</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event]) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event].<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">callback</span> =&gt;</span> <span class="hljs-title function_">callback</span>(data));<br>  <span class="hljs-keyword">if</span>(once) <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event];<br>&#125;<br></code></pre></td></tr></table></figure><p>如果一个回调函数在被调用时订阅了相同的事件，可能会导致<strong>无限循环</strong>。这是因为<code>publish</code>方法会立即调用所有的回调函数，而这些回调函数可能会改变监听器列表。<br>上面的代码并没有考虑这个问题，但测试后发现并不会发生无限循环的情况，这是什么原因呢？问题出在 for 和 forEach 中，<strong>forEach 方法在开始循环时就已经确定了循环的次数，所以，即使在回调函数中添加或删除了元素，也不会影响forEach的循环次数；</strong>而 <strong>for 循环会实时检查</strong>数组的长度，故而会出现上述的情况。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>强制缓存和协商缓存?</title>
    <link href="/2023/10/07/%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98%E5%92%8C%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98/"/>
    <url>/2023/10/07/%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98%E5%92%8C%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<blockquote><p>原文 <a href="https://juejin.cn/post/7127194919235485733?searchId=2023100709440962FECF52597D2C3CBEA0#heading-4">中高级前端工程师都需要熟悉的技能–前端缓存 - 掘金</a></p></blockquote><p>HTTP 缓存可以分为协商缓存和强制缓存两种类型。</p><blockquote><p>强缓存</p></blockquote><p>强制缓存是指浏览器在请求资源时，不会发送任何请求头，直接从本地缓存中读取资源，从⽽提⾼响应速度,  只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。</p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310171848158.png" alt="img" style="zoom:50%;" /><blockquote><p>协商缓存</p></blockquote><ul><li>协商缓存是指浏览器在请求资源时，会发送⼀些请求头到服务器，询问服务器资源是否已经发⽣改变。如果资源未发⽣改变，服务器将返回 304 状态码，告诉浏览器可以从缓存中读取资源，从⽽减少了⽹络带宽的使⽤。强制缓存失效之后，浏览器在请求头中携带相应的缓存字段来向服务器发请求，由服务器根据这个字段，来决定是否使用缓存，这就是协商缓存。</li></ul><h3 id="1-基于-Expires-字段实现的强缓存"><a href="#1-基于-Expires-字段实现的强缓存" class="headerlink" title="1. 基于 Expires 字段实现的强缓存"></a>1. 基于 Expires 字段实现的强缓存</h3><p>使用响应头的<code>Expires</code>字段去实现强缓存</p><p><code>Expires</code> 头部：指定资源过期的时间，如果在过期时间之前再次请求该资源，浏览器将直接从缓存中读取资源。</p><p>比如说将某一资源设置响应头为:<code>Expires:new Date(&quot;2022-7-30 23:59:59&quot;)</code>；</p><p>那么，该资源在2022-7-30 23:59:59 之前，都会去本地的磁盘（或内存）中读取，不会去服务器请求。</p><blockquote><p>Expires判断强缓存是否过期的机制是: 获取本地时间戳，并对先前拿到的资源文件中的Expires字段的时间做比较, 但是Expires<strong>过度依赖本地时间</strong>，如果本地与服务器时间不同步，就会出现资源无法被缓存或者资源永远被缓存的情况。</p></blockquote><h3 id="2-基于-Cache-control-实现的强缓存"><a href="#2-基于-Cache-control-实现的强缓存" class="headerlink" title="2. 基于 Cache-control 实现的强缓存"></a>2. 基于 Cache-control 实现的强缓存</h3><p><code>Cache-Control</code> 头部：可以指定资源的缓存策略，包括 max-age,  public、private、no-cache 等，控制浏览器的缓存⾏为。</p><p>通过在资源的响应头中设置 <code>Cache-Control:max-age=N</code>，N就是需要缓存的秒数。</p><p>那么,  从第一次请求资源的时候开始，往后N秒内，资源若再次请求，则直接从磁盘（或内存中读取），不与服务器做任何交互。</p><blockquote><p>Cache-control中因为max-age后面的值是一个滑动时间，从服务器第一次返回该资源时开始倒计时。所以也就不需要比对客户端和服务端的时间，解决了Expires所存在的巨大漏洞。</p></blockquote><h3 id="3-基于-lasted-modified-实现的协商缓存"><a href="#3-基于-lasted-modified-实现的协商缓存" class="headerlink" title="3. 基于 lasted-modified 实现的协商缓存"></a>3. 基于 lasted-modified 实现的协商缓存</h3><ol><li>浏览器在第一次请求资源时，在服务器端读出文件修改时间，将读出来的修改时间赋给响应头的<code>last-modified</code>字段。然后设置<code>Cache-control:no-cache(跳过强缓存校验，直接进行协商缓存)</code>. </li><li>当客户端读取到<code>last-modified</code>的时候，会在下次的请求标头中携带一个字段<code>If-Modified-Since(这个请求头中的If-Modified-Since就是上一次请求设置在响应头中的 last-modified)</code>。  </li><li>当再次请求资源时, 服务端需要拿到请求头中的 <code>If-Modified-Since</code> 这个时间并再次读取该资源的修改时间, 让他们两个做一个比对来决定是读取缓存还是返回新的资源。如果没有发生变化，返回 304 状态码并读取缓存，否则返回新的资源并将资源修改时间赋值给响应头的<code>last-modified</code> 字段。</li></ol><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310071059690.png" alt="img"></p><p>使用以上方式的协商缓存存在两个非常明显的漏洞。这两个漏洞都是基于文件是通过比较修改时间来判断是否更改而产生的。</p><ol><li>因为是更具文件修改时间来判断的，所以，在文件内容本身不修改的情况下，依然有可能更新文件修改时间（比如修改文件名再改回来），这样，就有可能文件内容明明没有修改，但是缓存依然失效了。</li><li>当文件在极短时间内完成修改的时候（比如几百毫秒）。因为文件修改时间记录的最小单位是秒，所以，如果文件在几百毫秒内完成修改的话，文件修改时间不会改变，这样，即使文件内容修改了，依然不会返回新的文件。</li></ol><blockquote><p>为了解决上述的这两个问题。从http1.1开始新增了一个头信息，ETag(Entity 实体标签)</p></blockquote><h3 id="4-基于-ETag-实现的协商缓存"><a href="#4-基于-ETag-实现的协商缓存" class="headerlink" title="4. 基于 ETag 实现的协商缓存"></a>4. 基于 ETag 实现的协商缓存</h3><ol><li>第一次请求某资源的时候，服务端读取文件并计算出文件指纹，将文件指纹放在响应头的<code>etag</code>字段中跟资源一起返回给客户端。</li><li>第二次请求某资源的时候，客户端自动从缓存中读取出上一次服务端返回的<code>ETag</code>也就是文件指纹。并赋给请求头的<code>if-None-Match</code>字段，让上一次的文件指纹跟随请求一起回到服务端。</li><li>服务端拿到请求头中的<code>if-None-Match</code>字段值（也就是上一次的文件指纹），并再次读取目标资源并生成文件指纹，两个指纹做对比。如果两个文件指纹完全吻合，说明文件没有被改变，则直接返回304状态码和一个空的响应体并<code>return</code>(这个时候已经读取了缓存)。如果两个文件指纹不吻合，则说明文件被更改，那么返回新的资源并将新的文件指纹重新存储到响应头的<code>ETag</code>字段</li></ol><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310071059655.png" alt="img"></p><blockquote><p> ETag 的缺点</p></blockquote><ol><li>ETag需要计算文件指纹这样意味着，服务端需要更多的计算开销。。如果文件尺寸大，数量多，并且计算频繁，那么ETag的计算就会影响服务器的性能。显然，ETag在这样的场景下就不是很适合。</li><li>ETag有强验证和弱验证，所谓将强验证，ETag生成的哈希码深入到每个字节。哪怕文件中只有一个字节改变了，也会生成不同的哈希值，它可以保证文件内容绝对的不变。但是，强验证非常消耗计算量。ETag还有一个弱验证，弱验证是提取文件的部分属性来生成哈希值。因为不必精确到每个字节，所以他的整体速度会比强验证快，但是准确率不高。会降低协商缓存的有效性。</li></ol><h3 id="5-缓存位置"><a href="#5-缓存位置" class="headerlink" title="5. 缓存位置"></a>5. 缓存位置</h3><p>当强缓存命中或者<code>协商缓存</code>中服务器返回304的时候，我们直接从缓存中获取资源。那这些资源究竟缓存在什么位置呢？</p><p>浏览器中的缓存位置一共有四种，按优先级从高到低排列分别是：</p><ul><li>Service Worker</li><li>Memory Cache</li><li>Disk Cache</li><li>Push Cache</li></ul><blockquote><p>Service Worker</p></blockquote><p>Service Worker 借鉴了 Web Worker的 思路，即让 JS 运行在主线程之外，由于它脱离了浏览器的窗体，因此无法直接访问DOM。虽然如此，但它仍然能帮助我们完成很多有用的功能，比如离线缓存、消息推送和网络代理等功能。其中的离线缓存就是 <strong>Service Worker Cache</strong>。</p><blockquote><p> Memory Cache 和 Disk Cache</p></blockquote><p><strong>Memory Cache</strong>指的是内存缓存，从效率上讲它是最快的。但是从存活时间来讲又是最短的，当渲染进程结束后，内存缓存也就不存在了。</p><p><strong>Disk Cache</strong>就是存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，但是他的优势在于存储容量和存储时长。稍微有些计算机基础的应该很好理解，就不展开了。</p><p>好，现在问题来了，既然两者各有优劣，那浏览器如何决定将资源放进内存还是硬盘呢？主要策略如下：</p><ul><li>比较大的JS、CSS文件会直接被丢进磁盘，反之丢进内存</li><li>内存使用率比较高的时候，文件优先进入磁盘</li></ul><blockquote><p>Push Cache</p></blockquote><p>即推送缓存，这是浏览器缓存的最后一道防线。它是 HTTP&#x2F;2 中的内容，虽然现在应用的并不广泛，但随着 HTTP&#x2F;2 的推广，它的应用越来越广泛。</p><h3 id="6-总结一下"><a href="#6-总结一下" class="headerlink" title="6. 总结一下"></a>6. 总结一下</h3><ul><li>需要注意的是，协商缓存虽然可以减少⽹络带宽的使⽤，但是需要服务器进⾏资源⽐较，会增加服务器的负载</li><li>关于强缓存，cache-control是Expires的完全替代方案，在可以使用cache-control的情况下不要使用expires</li><li>关于协商缓存,etag并不是last-modified的完全替代方案，而是补充方案，具体用哪一个，取决于业务场景。</li><li>有哈希值的文件设置强缓存即可。没有哈希值的文件（比如index.html）设置协商缓存</li><li>有些缓存是从磁盘读取，有些缓存是从内存读取，有什么区别？答：从内存读取的缓存更快。</li><li>所有带304的资源都是协商缓存，所有标注（从内存中读取&#x2F;从磁盘中读取）的资源都是强缓存。</li></ul>]]></content>
    
    
    <categories>
      
      <category>浏览器原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kmp算法(JS版)</title>
    <link href="/2023/09/30/kmp%E7%AE%97%E6%B3%95(JS%E7%89%88)/"/>
    <url>/2023/09/30/kmp%E7%AE%97%E6%B3%95(JS%E7%89%88)/</url>
    
    <content type="html"><![CDATA[<h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><p>KMP是一种高效的字符串匹配算法，用来在主字符串中查找模式字符串的位置</p><blockquote><p>比如在“hello,world”主串中查找“world”模式串的位置)。</p></blockquote><h5 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h5><blockquote><p>在失配时,  将模板字符串失配字符的下标退回到前面相应位置 ，这样就可以跳过大多数的失配步骤。而每次p串移动的步数就是通过查找next[ ]数组确定的。比如 : </p><p>父亲字符串 :  aabaabaaf</p><p>模板字符串 :  aabaaf</p><p>当模板字符串的<code>f</code>不匹配父字符串的<code>b</code> 时, 模板字符串中字符<code>f</code> 对应的下标<code>j</code>就会退回到包括前5个字符组成的子串的最长相同前后缀的长度, 也就是2, 于是退回到下标为2的位置, 从模板字符串的<code>b</code>字符继续开始和父字符串进行匹配, 至始至终父字符串的匹配下标都未移动哦~</p></blockquote><p><code>KMP</code> 主要分两步：</p><ol><li>求next数组</li><li>匹配字符串</li></ol><h5 id="举例-详解"><a href="#举例-详解" class="headerlink" title="举例 + 详解"></a>举例 + 详解</h5><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309300214173.png" alt="image-20230930021353085"></p><blockquote><p>详解 : 都在注释中了</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> readline = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;readline&quot;</span>);<br><span class="hljs-keyword">const</span> rl = readline.<span class="hljs-title function_">createInterface</span>(&#123;<br>  <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span>,<br>  <span class="hljs-attr">output</span>: process.<span class="hljs-property">stdout</span>,<br>&#125;);<br><span class="hljs-keyword">const</span> num = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">const</span> rows = [];<br>rl.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;line&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)&#123;<br>  rows.<span class="hljs-title function_">push</span>(data);<br>  <span class="hljs-keyword">if</span> (rows.<span class="hljs-property">length</span> == num) &#123;<br>    <span class="hljs-keyword">const</span> res = [];<br>    <span class="hljs-keyword">const</span> n = <span class="hljs-title class_">Number</span>(rows[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">const</span> m = <span class="hljs-title class_">Number</span>(rows[<span class="hljs-number">2</span>]);<br>    <span class="hljs-keyword">const</span> p = rows[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">const</span> s = rows[<span class="hljs-number">3</span>];<br>    <span class="hljs-comment">// 初始化next数组为0, 单个数字是没有前后缀的, 也没有长度</span><br>    <span class="hljs-keyword">const</span> next = [<span class="hljs-number">0</span>]<br>    <span class="hljs-comment">// 求next数组 : next[i]就是包括i之前这个子串最长相等前后缀的长度</span><br>    <span class="hljs-comment">// j代表前缀的末尾位置, 前缀从下标0开始, i代表后缀的末尾位置, 后缀是从下标1开始, 因为单个数字是没有前后缀的</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br> <span class="hljs-comment">// 关于 j &gt; 0 : 因为下标为0时j无法回退到前一个数字的next值, 也就是数组下标-1也有问题, 所以要进行判定</span><br> <span class="hljs-comment">// 关于 while : 因为j的回退也是需要持续进行的, 直到前后缀一致或者j回退到下标为0的位置, 这个地方也是易错点</span><br> <span class="hljs-comment">// 关于 j = next[j - 1] : 当不匹配时, j要回退到前一个数字的next值的位置, 也就是包括i在内的字符串的最长相同前后缀的长度</span><br>      <span class="hljs-keyword">while</span>(j &amp;&amp; p[i] != p[j]) j = next[j - <span class="hljs-number">1</span>];<br>      <span class="hljs-comment">// 当匹配时, j++, 因为j不仅代表前缀末尾的位置, 也代表着包括i之前这个子串的最长相等前后缀的长度, 此时匹配了肯定要加一</span><br>      <span class="hljs-keyword">if</span>(p[i] === p[j])j++; <br>      <span class="hljs-comment">// 因为j代表着包括i之前这个子串的最长相等前后缀的长度, 也就是我们要求的next[i]的值, 最后赋值即可</span><br>      next[i] = j;<br>    &#125;<br>    <span class="hljs-comment">// 进行匹配</span><br>    <span class="hljs-comment">// 都从第一个数开始匹配, 所以下标都从0开始, i为父字符串下标, j为模板字符串下标</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>  <span class="hljs-comment">// 当j为0时, 无需回退且数组也会越界</span><br>  <span class="hljs-comment">// while的作用: 由于移动后可能仍然失配, 所以目的是要保持匹配</span><br>  <span class="hljs-comment">// 当不匹配时, j回退到前一个数字的next值的位置, 继续下一步匹配, 注意这时候i是不变的, 也就是说i一直向后, 只有j是不断回退</span><br>      <span class="hljs-keyword">while</span> (j &amp;&amp; s[i] != p[j]) j = next[j - <span class="hljs-number">1</span>]; <br>      <span class="hljs-comment">// 当匹配成功时, j++</span><br>      <span class="hljs-keyword">if</span> (s[i] == p[j]) j++;<br>      <span class="hljs-comment">// 如果模板字符串已全匹配完, 则匹配完成</span><br>      <span class="hljs-keyword">if</span> (j == n) &#123;<br>        res.<span class="hljs-title function_">push</span>(i - n + <span class="hljs-number">1</span>);<br>        j = next[j - <span class="hljs-number">1</span>];<br>      &#125;<br>      <span class="hljs-comment">// 如果未匹配完成, 则i++, 继续下一个字符的匹配</span><br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27; &#x27;</span>));<br>    rl.<span class="hljs-title function_">close</span>();<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><blockquote><p>over</p></blockquote><blockquote><p>例子2  + 无注释版</p></blockquote><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309301301231.png" alt="image-20230930130110140"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">haystack</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">needle</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> strStr = <span class="hljs-keyword">function</span>(<span class="hljs-params">haystack, needle</span>) &#123;<br>    <span class="hljs-keyword">let</span> next = [<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>, i = <span class="hljs-number">1</span>; i &lt; needle.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">while</span>(j &amp;&amp; needle[i] != needle[j]) j = next[j - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span>(needle[i] === needle[j]) j++;<br>        next[i] = j;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; haystack.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">while</span>(j &amp;&amp; needle[j] !== haystack[i]) j = next[j - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span>(needle[j] === haystack[i]) j++;<br>        <span class="hljs-keyword">if</span>(j === needle.<span class="hljs-property">length</span>) &#123;<br>            <span class="hljs-keyword">return</span> i - j + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串匹配</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手写Promise!!</title>
    <link href="/2023/09/18/%E6%89%8B%E5%86%99Promise/"/>
    <url>/2023/09/18/%E6%89%8B%E5%86%99Promise/</url>
    
    <content type="html"><![CDATA[<blockquote><p>原文 : <a href="https://juejin.cn/post/7269640045043777576">https://juejin.cn/post/7269640045043777576</a></p></blockquote><p>首先，<code>Promise</code>肯定是一个类，所以我们才可以<code>new</code>它，然后<code>Promise实例化</code>的时候给它传入一个回调我们叫它<code>executor</code>方法，Promise 内部会<code>立即调用</code>这个<code>executor方法</code>，并且会传入<code>resolve</code>和<code>reject</code>两个函数作为调用参数，另外在 Promise 类的原型上应该提供一个<code>then</code>方法，它里面可以传入两个回调，分别为<code>Promise成功的回调</code>和<code>Promise失败的回调</code>。调用<code>resolve</code>后会走入<code>成功的回调中</code>，调用<code>reject</code>后会走入<code>失败的回调中</code>。</p><h2 id="初级版本-Promise"><a href="#初级版本-Promise" class="headerlink" title="初级版本 Promise"></a>初级版本 Promise</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PENDING</span> = <span class="hljs-string">&quot;PENDING&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">FULFILLED</span> = <span class="hljs-string">&quot;FULFILLED&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">REJECTED</span> = <span class="hljs-string">&quot;REJECTED&quot;</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Promise</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-literal">undefined</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = <span class="hljs-literal">undefined</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PENDING</span>;<br>    <span class="hljs-comment">// 定义两个数组解决异步调用resolve或者reject的问题</span><br>    <span class="hljs-comment">// 充当队列把then里边的回调存起来</span><br>    <span class="hljs-comment">// 有的时候，我们会给同一个promise实例执行多次then方法, 那么相应的onFulfilled和onRejected回调必须按照其发起调用的顺序执行。</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onResolvedCallbacks</span> = [];<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span> = [];<br><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">resolve</span> = (<span class="hljs-params">value</span>) =&gt; &#123;<br>      <span class="hljs-comment">// 当状态为pending状态的时候才可以去改变状态，并且分别将value和reason赋值给对应值，并去执行相应回调函数</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">FULFILLED</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onResolvedCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> <span class="hljs-title function_">fn</span>());<br>      &#125;<br>    &#125;;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">reject</span> = (<span class="hljs-params">reason</span>) =&gt; &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = reason;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">REJECTED</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> <span class="hljs-title function_">fn</span>());<br>      &#125;<br>    &#125;;<br>      <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-title function_">executor</span>(resolve,reject)<br>      &#125; <span class="hljs-keyword">catch</span>(err) &#123;<br>        <span class="hljs-title function_">reject</span>(err); <span class="hljs-comment">//有报错会直接执行reject函数将状态变为失败rejected</span><br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-title function_">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>) &#123;<br>    <span class="hljs-comment">//当执行到then的时候，状态已经是fulfilled状态或者是rejected状态，那么就直接执行回调，并且将value/reason作为第一个参数</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">FULFILLED</span>) &#123;<br>      onFulfilled &amp;&amp; <span class="hljs-title function_">onFulfilled</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">REJECTED</span>) &#123;<br>      onRejected &amp;&amp; <span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>);<br>    &#125;<br>     <span class="hljs-comment">//当执行到then的时候，状态还是pending状态，那么需要将回调存起来，等到状态改变的时候再去执行</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">onResolvedCallbacks</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">onFulfilled</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>      &#125;);<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>);<br>      &#125;);<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">Promise</span>;<br></code></pre></td></tr></table></figure><h2 id="链式调用-Promise"><a href="#链式调用-Promise" class="headerlink" title="链式调用 Promise"></a>链式调用 Promise</h2><blockquote><p>内部调用 then 方法时，返回了一个新的 promise，并让这个新的 promise 接管了它下一个 then 方法。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PENDING</span> = <span class="hljs-string">&quot;PENDING&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">FULFILLED</span> = <span class="hljs-string">&quot;FULFILLED&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">REJECTED</span> = <span class="hljs-string">&quot;REJECTED&quot;</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Promise</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-literal">undefined</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = <span class="hljs-literal">undefined</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PENDING</span>;<br>    <span class="hljs-comment">// 定义两个数组解决异步调用resovle或者reject的问题</span><br>    <span class="hljs-comment">// 充当队列把then里边的回调存起来</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onResolvedCallbacks</span> = [];<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span> = [];<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">resolve</span> = (<span class="hljs-params">value</span>) =&gt; &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">FULFILLED</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onResolvedCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> <span class="hljs-title function_">fn</span>());<br>      &#125;<br>    &#125;;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">reject</span> = (<span class="hljs-params">reason</span>) =&gt; &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = reason;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">REJECTED</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> <span class="hljs-title function_">fn</span>());<br>      &#125;<br>    &#125;;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-title function_">executor</span>(resolve, reject);<br>    &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>      <span class="hljs-title function_">reject</span>(err); <span class="hljs-comment">//有报错会直接执行reject函数将状态变为失败rejected</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-title function_">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>) &#123;<br>    <span class="hljs-keyword">const</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">FULFILLED</span>) &#123;<br>        <span class="hljs-comment">// onFulfilled方法可能返回值或者promise</span><br>        <span class="hljs-keyword">const</span> x = <span class="hljs-title function_">onFulfilled</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>        <span class="hljs-title function_">resolvePromise</span>(promise2, x, resolve, reject);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">REJECTED</span>) &#123;<br>        <span class="hljs-comment">// onRejected方法可能返回值或者promise</span><br>        <span class="hljs-keyword">const</span> x = <span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>);<br>        <span class="hljs-title function_">resolvePromise</span>(promise2, x, resolve, reject);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onResolvedCallbacks</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-keyword">const</span> x = <span class="hljs-title function_">onFulfilled</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>          <span class="hljs-title function_">resolvePromise</span>(promise2, x, resolve, reject);<br>        &#125;);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-keyword">const</span> x = <span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>);<br>          <span class="hljs-title function_">resolvePromise</span>(promise2, x, resolve, reject);<br>        &#125;);<br>      &#125;<br>    &#125;);<br>    <span class="hljs-keyword">return</span> promise2;<br>  &#125;<br>&#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">Promise</span>;<br></code></pre></td></tr></table></figure><blockquote><p>这里最主要的就是<code>resolvePromise</code>，来看下它做了什么：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">resolvePromise</span>(<span class="hljs-params">promise2, x, resolve, reject</span>) &#123;<br>  <span class="hljs-keyword">if</span> (promise2 === x) &#123;<br>    <span class="hljs-comment">// 防止循环引用</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">reject</span>(<br>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<br>        <span class="hljs-string">&quot;UnhandledPromiseRejectionWarning: TypeError: Chaining cycle detected for promise #&lt;Promise&gt;&quot;</span><br>      )<br>    );<br>  &#125;<br>  <span class="hljs-keyword">let</span> called; <span class="hljs-comment">// 声明变量called，相当于加了一把锁，让promise只能调用一次成功或者失败回调，防止死循环。</span><br>  <span class="hljs-comment">// 判断x的类型 x是对象或函数才有可能是一个promise</span><br>  <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&quot;object&quot;</span> &amp;&amp; x !== <span class="hljs-literal">null</span>) || <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">const</span> then = x.<span class="hljs-property">then</span>;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>        <span class="hljs-comment">// 只能认为它是一个promise</span><br>        then.<span class="hljs-title function_">call</span>(<br>          x,<br>          <span class="hljs-function">(<span class="hljs-params">y</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span>;<br>            called = <span class="hljs-literal">true</span>;<br>            <span class="hljs-title function_">resolvePromise</span>(promise2, y, resolve, reject); <span class="hljs-comment">// 精髓, 递归解析</span><br>          &#125;,<br>          <span class="hljs-function">(<span class="hljs-params">r</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span>;<br>            called = <span class="hljs-literal">true</span>;<br>            <span class="hljs-title function_">reject</span>(r);<br>          &#125;<br>        );<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(x);<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>      <span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span>;<br>      called = <span class="hljs-literal">true</span>;<br>      <span class="hljs-title function_">reject</span>(e);<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(x);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>因为<code>promise</code>在<code>EventLoop</code>里面是个微任务，不过我们可以简单通过<code>setTimout</code>模拟。</p><p>然后我们再加上一些报错的捕获代码以及一些参数的兼容代码，以及实现<code>catch</code>方法。</p></blockquote><h2 id="完全版本-Promise"><a href="#完全版本-Promise" class="headerlink" title="完全版本 Promise"></a>完全版本 Promise</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PENDING</span> = <span class="hljs-string">&quot;PENDING&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">FULFILLED</span> = <span class="hljs-string">&quot;FULFILLED&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">REJECTED</span> = <span class="hljs-string">&quot;REJECTED&quot;</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Promise</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-literal">undefined</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = <span class="hljs-literal">undefined</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PENDING</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onResolvedCallbacks</span> = [];<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span> = [];<br><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">resolve</span> = (<span class="hljs-params">value</span>) =&gt; &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">FULFILLED</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onResolvedCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> <span class="hljs-title function_">fn</span>());<br>      &#125;<br>    &#125;;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">reject</span> = (<span class="hljs-params">reason</span>) =&gt; &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = reason;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">REJECTED</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> <span class="hljs-title function_">fn</span>());<br>      &#125;<br>    &#125;;<br><br>    <span class="hljs-comment">// executor执行时增加try catch，防止执行用户传入的函数直接就报错了，这时我们应该直接reject promise。</span><br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-title function_">executor</span>(resolve, reject);<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>      <span class="hljs-title function_">reject</span>(e);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-title function_">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>) &#123;<br>    <span class="hljs-comment">// 这里兼容下 onFulfilled 和 onRejected 的传参</span><br>    onFulfilled = <span class="hljs-keyword">typeof</span> onFulfilled === <span class="hljs-string">&quot;function&quot;</span> ? onFulfilled : <span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> v;<br>    onRejected =<br>      <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">&quot;function&quot;</span><br>        ? onRejected<br>        : <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">throw</span> err;<br>          &#125;;<br>    <span class="hljs-comment">// 调用onFulfilled和onRejected时，需要包裹setTimeout</span><br>    <span class="hljs-keyword">const</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">FULFILLED</span>) &#123;<br>        <span class="hljs-comment">// 用 setTimeout 模拟异步</span><br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">const</span> x = <span class="hljs-title function_">onFulfilled</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>            <span class="hljs-title function_">resolvePromise</span>(promise2, x, resolve, reject);<br>          &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>            <span class="hljs-title function_">reject</span>(e);<br>          &#125;<br>        &#125;, <span class="hljs-number">0</span>);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">REJECTED</span>) &#123;<br>        <span class="hljs-comment">// 用 setTimeout 模拟异步</span><br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">const</span> x = <span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>);<br>            <span class="hljs-title function_">resolvePromise</span>(promise2, x, resolve, reject);<br>          &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>            <span class="hljs-title function_">reject</span>(e);<br>          &#125;<br>        &#125;, <span class="hljs-number">0</span>);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onResolvedCallbacks</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-comment">// 用 setTimeout 模拟异步</span><br>          <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>              <span class="hljs-keyword">const</span> x = <span class="hljs-title function_">onFulfilled</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>              <span class="hljs-title function_">resolvePromise</span>(promise2, x, resolve, reject);<br>            &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>              <span class="hljs-title function_">reject</span>(e);<br>            &#125;<br>          &#125;, <span class="hljs-number">0</span>);<br>        &#125;);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-comment">// 用 setTimeout 模拟异步</span><br>          <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>              <span class="hljs-keyword">const</span> x = <span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>);<br>              <span class="hljs-title function_">resolvePromise</span>(promise2, x, resolve, reject);<br>            &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>              <span class="hljs-title function_">reject</span>(e);<br>            &#125;<br>          &#125;, <span class="hljs-number">0</span>);<br>        &#125;);<br>      &#125;<br>    &#125;);<br><br>    <span class="hljs-keyword">return</span> promise2;<br>  &#125;<br>  <span class="hljs-comment">// catch函数实际上里面就是调用了then方法</span><br>  <span class="hljs-keyword">catch</span>(errCallback) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-literal">null</span>, errCallback);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 解决链式调用</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">resolvePromise</span>(<span class="hljs-params">promise2, x, resolve, reject</span>) &#123;<br>  <span class="hljs-keyword">if</span> (promise2 === x) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">reject</span>(<br>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<br>        <span class="hljs-string">&quot;UnhandledPromiseRejectionWarning: TypeError: Chaining cycle detected for promise #&lt;Promise&gt;&quot;</span><br>      )<br>    );<br>  &#125;<br>  <span class="hljs-keyword">let</span> called;<br>  <span class="hljs-comment">// 判断x的类型 x是对象或函数才有可能是一个promise</span><br>  <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&quot;object&quot;</span> &amp;&amp; x !== <span class="hljs-literal">null</span>) || <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">const</span> then = x.<span class="hljs-property">then</span>;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>        <span class="hljs-comment">// 只能认为它是一个promise</span><br>        then.<span class="hljs-title function_">call</span>(<br>          x,<br>          <span class="hljs-function">(<span class="hljs-params">y</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span>;<br>            called = <span class="hljs-literal">true</span>;<br>            <span class="hljs-title function_">resolvePromise</span>(promise2, y, resolve, reject);<br>          &#125;,<br>          <span class="hljs-function">(<span class="hljs-params">r</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span>;<br>            called = <span class="hljs-literal">true</span>;<br>            <span class="hljs-title function_">reject</span>(r);<br>          &#125;<br>        );<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(x);<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>      <span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span>;<br>      called = <span class="hljs-literal">true</span>;<br>      <span class="hljs-title function_">reject</span>(e);<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(x);<br>  &#125;<br>&#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">Promise</span>;<br></code></pre></td></tr></table></figure><h2 id="测试-promise-是否符合规范"><a href="#测试-promise-是否符合规范" class="headerlink" title="测试 promise 是否符合规范"></a>测试 promise 是否符合规范</h2><ol><li><p>首先安装依赖包 <code>npm i promises-aplus-tests -D</code></p></li><li><p>在我们的代码中添加</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">defer</span> = <span class="hljs-title class_">Promise</span>.<span class="hljs-property">deferred</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">let</span> dfd = &#123;&#125;;<br>  dfd.<span class="hljs-property">promise</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>      dfd.<span class="hljs-property">resolve</span> = resolve;<br>      dfd.<span class="hljs-property">reject</span> = reject;<br>  &#125;);<br>  <span class="hljs-keyword">return</span> dfd;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意别忘了 <code>module.exports = Promise;</code></p></blockquote></li><li><p>运行 <code>promises-aplus-tests 文件名</code> 即可</p></li><li><p>有 872 个测试用例，全部通过即可以认为这是一个标准的 promise。</p></li></ol><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309181510458.png" alt="image-20230918151029374"></p><h2 id="实现Promise的各种方法"><a href="#实现Promise的各种方法" class="headerlink" title="实现Promise的各种方法"></a>实现Promise的各种方法</h2><blockquote><p>Promise 的实例方法有 then&#x2F;catch&#x2F;finally 三种，静态方法有 all&#x2F;race&#x2F;allSettled&#x2F;any&#x2F;resolve&#x2F;reject 六种</p><p>then 和 catch 上面已经实现过了</p></blockquote><h3 id="实现-Promise-resolve"><a href="#实现-Promise-resolve" class="headerlink" title="实现 Promise.resolve"></a>实现 Promise.resolve</h3><p>实现 resolve 静态方法有三个要点:</p><ol><li>传参为一个 Promise, 则直接返回它。</li><li>传参为一个 thenable 对象，返回的 Promise 会跟随这个对象，采用它的最终状态作为自己的状态。</li><li>其他情况，直接返回以该值为成功状态的promise对象。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">resolve</span> = <span class="hljs-function">(<span class="hljs-params">param</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span>(param <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) <span class="hljs-keyword">return</span> param;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span>(param &amp;&amp; param.<span class="hljs-property">then</span> &amp;&amp; <span class="hljs-keyword">typeof</span> param.<span class="hljs-property">then</span> === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>      <span class="hljs-comment">// param 状态变为成功会调用resolve，将新 Promise 的状态变为成功，反之亦然</span><br>      param.<span class="hljs-title function_">then</span>(resolve, reject);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_">resolve</span>(param);<br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现-Promise-reject"><a href="#实现-Promise-reject" class="headerlink" title="实现 Promise.reject"></a>实现 Promise.reject</h3><p>Promise.reject 中传入的参数会作为一个 reason 原封不动地往下传, 实现如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">reject</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">reason</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-title function_">reject</span>(reason);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="实现-Promise-prototype-finally"><a href="#实现-Promise-prototype-finally" class="headerlink" title="实现 Promise.prototype.finally"></a>实现 Promise.prototype.finally</h3><p>无论当前 Promise 是成功还是失败，调用finally之后都会执行 finally 中传入的函数，并且将值原封不动的往下传。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">finally</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">callback</span>()).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> value;<br>    &#125;)<br>  &#125;, <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">callback</span>()).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">throw</span> error;<br>    &#125;)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h3 id="实现-Promise-all"><a href="#实现-Promise-all" class="headerlink" title="实现 Promise.all"></a>实现 Promise.all</h3><p>对于 <code>all</code> 方法而言，需要完成下面的核心功能:</p><ol><li>传入参数为一个空的可迭代对象，则直接进行<code>resolve</code>。</li><li>如果参数中有一个<code>promise</code>失败，那么<code>Promise.all</code>返回的<code>promise</code>对象失败。</li><li>在任何情况下，<code>Promise.all</code> 返回的 <code>promise</code> 的完成状态的结果都是一个数组</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">all</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">promises</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> result = [];<br>    <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> len = promises.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">if</span>(len === <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-title function_">resolve</span>(result);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>   <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>      <span class="hljs-comment">// 为什么不直接 promise[i].then, 因为promise[i]可能不是一个promise</span><br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(promise[i]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>        result[i] = data;<br>        index++;<br>        <span class="hljs-keyword">if</span>(index === len) <span class="hljs-title function_">resolve</span>(result);<br>      &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>        <span class="hljs-title function_">reject</span>(err);<br>      &#125;)<br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><h3 id="实现-Promise-allSettled"><a href="#实现-Promise-allSettled" class="headerlink" title="实现 Promise.allSettled"></a>实现 Promise.allSettled</h3><p>Promise.allSettled() 方法只有等到参数数组的所有 Promise 实例都发生状态变更，返回的 Promise 实例才会发生状态变更，无论是执行 resolve 回调还是 reject 回调的状态。<br>打个比方：多名员工分别同时进行多个项目，你要求每个一个项目都必须完成，然后得到所有项目是令你满意还是令你不满意的。强调的是最终结果。</p><p>同时因为 Promise.allSettled() 和 Promise.all() 都是对所有 Promise 实例的一种处理，下面就可以利用 Promise.all() 来实现 Promise.allSettled() 方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">MyPromise</span>.<span class="hljs-property">allSettled</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">promises</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(<br>    promises.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span><br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(item).<span class="hljs-title function_">then</span>(<br>        <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> (&#123; <span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;fulfilled&#x27;</span>, value &#125;),<br>        <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> (&#123; <span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;rejected&#x27;</span>, reason &#125;)<br>      )<br>    )<br>  );<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="实现-Promise-race"><a href="#实现-Promise-race" class="headerlink" title="实现 Promise.race"></a>实现 Promise.race</h3><p><code>race</code> 的实现相比之下就简单一些，只要有一个 <code>promise</code> 执行完，直接 <code>resolve</code> 并停止执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">race</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">promises</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span>(promises.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-title function_">resolve</span>();<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">let</span> len = promises.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">if</span>(len === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(promise[i]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(data);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>        <span class="hljs-title function_">reject</span>(err);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;)<br>    &#125;<br>   &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现-Promise-any"><a href="#实现-Promise-any" class="headerlink" title="实现 Promise.any"></a>实现 Promise.any</h3><p>Promise.any() 方法是返回任意一个最快执行 resolve 回调的 Promise 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">MyPromise</span>.<span class="hljs-property">any</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">promises</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (promises.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">resolve</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">let</span> result = [];<br>      <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; promises.<span class="hljs-property">length</span>; i++) &#123;<br>        promises[i].<span class="hljs-title function_">then</span>(<br>          <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-title function_">resolve</span>(value);<br>          &#125;,<br>          <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;<br>            result[i] = reason;<br>            <span class="hljs-comment">// 如果所有都失败则返回失败</span><br>            <span class="hljs-keyword">if</span> (++index === promises.<span class="hljs-property">length</span>) &#123;<br>              <span class="hljs-keyword">return</span> <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AggregateError</span>(result));<br>            &#125;<br>          &#125;<br>        );<br>      &#125;<br>    &#125;<br>  &#125;);<br>&#125;;<br><br></code></pre></td></tr></table></figure><blockquote><p>over</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>手写</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手写函数汇总</title>
    <link href="/2023/09/15/%E6%89%8B%E5%86%99%E5%87%BD%E6%95%B0/"/>
    <url>/2023/09/15/%E6%89%8B%E5%86%99%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="JavaScript-基础"><a href="#JavaScript-基础" class="headerlink" title="JavaScript 基础"></a>JavaScript 基础</h2><h3 id="1-手写-Object-create"><a href="#1-手写-Object-create" class="headerlink" title="1. 手写 Object.create"></a>1. 手写 Object.create</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">create</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"></span>) &#123;&#125;<br>  F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = obj<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-手写-instanceof-方法"><a href="#2-手写-instanceof-方法" class="headerlink" title="2.  手写 instanceof 方法"></a>2.  手写 instanceof 方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myInstanceof</span>(<span class="hljs-params">left, right</span>) &#123;<br>  <span class="hljs-keyword">let</span> proto = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(left),<br>  prototype = right.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <br> <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!proto) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (proto === prototype) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    proto = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(proto);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-手写-new-操作符"><a href="#3-手写-new-操作符" class="headerlink" title="3. 手写 new 操作符"></a>3. 手写 new 操作符</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">newOperator</span>(<span class="hljs-params">ctor, ...args</span>) &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> ctor !== <span class="hljs-string">&#x27;function&#x27;</span>)&#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;newOperator function the first param must be a function&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">let</span> obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(ctor.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br>    <span class="hljs-keyword">let</span> res = ctor.<span class="hljs-title function_">apply</span>(obj, args);<br><br>    <span class="hljs-comment">// 如果构造函数的返回值 res 是一个对象或函数，则直接返回它。否则，返回新创建的对象 obj</span><br>    <span class="hljs-keyword">let</span> isObject = (<span class="hljs-keyword">typeof</span> res === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; res !== <span class="hljs-literal">null</span>);<br>    <span class="hljs-keyword">let</span> isFunction = (<span class="hljs-keyword">typeof</span> res === <span class="hljs-string">&#x27;function&#x27;</span>);<br>    <span class="hljs-keyword">return</span> (isObect || isFunction ) ? res : obj;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="4-手写-Promise-简洁版"><a href="#4-手写-Promise-简洁版" class="headerlink" title="4. 手写 Promise (简洁版)"></a>4. 手写 Promise (简洁版)</h3><p>详细的可看自己的博客 , 这里未实现链式调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PENDING</span> = <span class="hljs-string">&quot;PENDING&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">FULFILLED</span> = <span class="hljs-string">&quot;FULFILLED&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">REJECTED</span> = <span class="hljs-string">&quot;REJECTED&quot;</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Promise</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-literal">undefined</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = <span class="hljs-literal">undefined</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PENDING</span>;<br>    <span class="hljs-comment">// 定义两个数组解决异步调用resolve或者reject的问题</span><br>    <span class="hljs-comment">// 充当队列把then里边的回调存起来</span><br>    <span class="hljs-comment">// 有的时候，我们会给同一个promise实例执行多次then方法, 那么相应的onFulfilled和onRejected回调必须按照其发起调用的顺序执行。</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onResolvedCallbacks</span> = [];<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span> = [];<br><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">resolve</span> = (<span class="hljs-params">value</span>) =&gt; &#123;<br>      <span class="hljs-comment">// 当状态为pending状态的时候才可以去改变状态，并且分别将value和reason赋值给对应值，并去执行相应回调函数</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">FULFILLED</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onResolvedCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> <span class="hljs-title function_">fn</span>());<br>      &#125;<br>    &#125;;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">reject</span> = (<span class="hljs-params">reason</span>) =&gt; &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = reason;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">REJECTED</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> <span class="hljs-title function_">fn</span>());<br>      &#125;<br>    &#125;;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-title function_">executor</span>(resolve, reject);<br>    &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>      <span class="hljs-title function_">reject</span>(err); <span class="hljs-comment">//有报错会直接执行reject函数将状态变为失败rejected</span><br>    &#125;<br>  &#125;<br><br>  <span class="hljs-title function_">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>) &#123;<br>    <span class="hljs-comment">//当执行到then的时候，状态已经是fulfilled状态或者是rejected状态，那么就直接执行回调，并且将value/reason作为第一个参数</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">FULFILLED</span>) &#123;<br>      onFulfilled &amp;&amp; <span class="hljs-title function_">onFulfilled</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">REJECTED</span>) &#123;<br>      onRejected &amp;&amp; <span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>);<br>    &#125;<br>    <span class="hljs-comment">//当执行到then的时候，状态还是pending状态，那么需要将回调存起来，等到状态改变的时候再去执行</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">onResolvedCallbacks</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">onFulfilled</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>      &#125;);<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>);<br>      &#125;);<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">Promise</span>;<br></code></pre></td></tr></table></figure><h3 id="5-手写-Promise-的各种方法"><a href="#5-手写-Promise-的各种方法" class="headerlink" title="5. 手写 Promise 的各种方法"></a>5. 手写 Promise 的各种方法</h3><p>Promise 的实例方法有 then&#x2F;catch&#x2F;finally 三种，静态方法有 all&#x2F;race&#x2F;allSettled&#x2F;any&#x2F;resolve&#x2F;reject 六种</p><h4 id="5-1-手写-Promise-resolve"><a href="#5-1-手写-Promise-resolve" class="headerlink" title="5.1. 手写 Promise.resolve"></a>5.1. 手写 Promise.resolve</h4><p>以下几种关于 Promise 各种方法实现的具体细节可看<a href="https://www.yuque.com/zweirdo/zxyob8/kg4i04ywgxe469w1#JKyuC">JavaScript八股</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">resolve</span> = <span class="hljs-function">(<span class="hljs-params">param</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span>(param <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) <span class="hljs-keyword">return</span> param;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span>(param &amp;&amp; param.<span class="hljs-property">then</span> &amp;&amp; <span class="hljs-keyword">typeof</span> param.<span class="hljs-property">then</span> === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>      <span class="hljs-comment">// param 状态变为成功会调用resolve，将新 Promise 的状态变为成功，反之亦然</span><br>      param.<span class="hljs-title function_">then</span>(resolve, reject);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_">resolve</span>(param);<br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-2-手写-Promise-reject"><a href="#5-2-手写-Promise-reject" class="headerlink" title="5.2. 手写 Promise.reject"></a>5.2. 手写 Promise.reject</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">reject</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">reason</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-title function_">reject</span>(reason);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-3-手写-Promise-prototype-finally"><a href="#5-3-手写-Promise-prototype-finally" class="headerlink" title="5.3. 手写 Promise.prototype.finally"></a>5.3. 手写 Promise.prototype.finally</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">finally</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">callback</span>()).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> value;<br>    &#125;)<br>  &#125;, <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">callback</span>()).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">throw</span> error;<br>    &#125;)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-4-手写-Promise-all"><a href="#5-4-手写-Promise-all" class="headerlink" title="5.4. 手写 Promise.all"></a>5.4. 手写 Promise.all</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">all</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">promises</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(promises)) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">`promises must be a array`</span>)<br>    <span class="hljs-keyword">let</span> result = [];<br>    <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> len = promises.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">if</span>(len === <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-title function_">resolve</span>(result);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>   <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>      <span class="hljs-comment">// 为什么不直接 promise[i].then, 因为promise[i]可能不是一个promise</span><br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(promise[i]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>        result[i] = data;<br>        index++;<br>        <span class="hljs-keyword">if</span>(index === len) <span class="hljs-title function_">resolve</span>(result);<br>      &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>        <span class="hljs-title function_">reject</span>(err);<br>      &#125;)<br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-5-手写-Promise-allSettled"><a href="#5-5-手写-Promise-allSettled" class="headerlink" title="5.5. 手写 Promise.allSettled"></a>5.5. 手写 Promise.allSettled</h4><p>因为 Promise.allSettled() 和 Promise.all() 都是对<strong>所有 Promise 实例</strong>的一种处理，下面就可以利用 Promise.all() 来实现 Promise.allSettled() 方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">MyPromise</span>.<span class="hljs-property">allSettled</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">promises</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(<br>    promises.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span><br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(item).<span class="hljs-title function_">then</span>(<br>        <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> (&#123; <span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;fulfilled&#x27;</span>, value &#125;),<br>        <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> (&#123; <span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;rejected&#x27;</span>, reason &#125;)<br>      )<br>    )<br>  );<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="5-6-手写-Promise-race"><a href="#5-6-手写-Promise-race" class="headerlink" title="5.6. 手写 Promise.race"></a>5.6. 手写 Promise.race</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">race</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">promises</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> len = promises.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">if</span>(len === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(promise[i]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(data);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>        <span class="hljs-title function_">reject</span>(err);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;)<br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-手写防抖函数"><a href="#6-手写防抖函数" class="headerlink" title="6. 手写防抖函数"></a>6. 手写防抖函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn, delay</span>) &#123;<br>  <span class="hljs-keyword">let</span> timer;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>    timer &amp;&amp; <span class="hljs-built_in">clearTimeout</span>(timer);<br>    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>    &#125;, delay);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-手写节流函数"><a href="#7-手写节流函数" class="headerlink" title="7. 手写节流函数"></a>7. 手写节流函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 定时器版本</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn, delay</span>) &#123;<br>  <span class="hljs-keyword">let</span> timer;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!timer) &#123;<br>      timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>        timer = <span class="hljs-literal">null</span>;<br>      &#125;, delay);<br>    &#125;<br>  &#125;;<br>&#125;<br><br><span class="hljs-comment">// 时间戳版本</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">throole</span>(<span class="hljs-params">fn, delay</span>) &#123;<br>  <span class="hljs-keyword">let</span> st = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-keyword">let</span> now = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>    <span class="hljs-keyword">if</span> (delay - (now - st) &lt;= <span class="hljs-number">0</span>) &#123;<br>      fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>      st = now;<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-手写类型判断函数"><a href="#8-手写类型判断函数" class="headerlink" title="8. 手写类型判断函数"></a>8. 手写类型判断函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getType</span>(<span class="hljs-params">value</span>) &#123;<br>  <span class="hljs-comment">// 判断数据是 null 的情况</span><br>  <span class="hljs-keyword">if</span> (value === <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">return</span> value + <span class="hljs-string">&quot;&quot;</span>;<br>  &#125;<br>  <span class="hljs-comment">// 判断数据是引用类型的情况</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&quot;object&quot;</span>) &#123;<br>    <span class="hljs-keyword">let</span> valueClass = <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(value), <span class="hljs-comment">// 重点</span><br>    type = valueClass.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot; &quot;</span>)[<span class="hljs-number">1</span>].<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    type.<span class="hljs-title function_">pop</span>();<br>    <span class="hljs-keyword">return</span> type.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">toLowerCase</span>();<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 判断数据是基本数据类型的情况和函数的情况</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> value;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-手写-call-函数"><a href="#9-手写-call-函数" class="headerlink" title="9. 手写 call 函数"></a>9. 手写 call 函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 给函数对象添加方法: mycall</span><br><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">mycall</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">thisArg, ...otherArgs</span>) &#123;<br>    <span class="hljs-comment">// this -&gt; 调用的函数对象</span><br>    <span class="hljs-comment">// thisArg -&gt; 传入的第一个参数, 要绑定的this</span><br>    <span class="hljs-comment">// console.log(this) // -&gt; 当前调用的函数对象</span><br><br>    <span class="hljs-comment">// 判断调用对象</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&quot;function&quot;</span>)  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;Error&quot;</span>);<br><br>    <span class="hljs-comment">// 获取thisArg, 并且确保是一个对象类型</span><br>    thisArg = (thisArg === <span class="hljs-literal">null</span> || thisArg === <span class="hljs-literal">undefined</span>)? <span class="hljs-attr">window</span>: <span class="hljs-title class_">Object</span>(thisArg)<br><br>    <span class="hljs-keyword">const</span> fnKey = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;fn&#x27;</span>);<br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(thisArg, fnKey, &#123;<br>        <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 不可枚举</span><br>        <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">value</span>: <span class="hljs-variable language_">this</span><br>    &#125;)<br>    thisArg[fnKey](...otherArgs) <span class="hljs-comment">// 通过thisArg调用方法, 相当于改变了this指向</span><br><br>    <span class="hljs-keyword">delete</span> thisArg[fnKey] <span class="hljs-comment">// 最后要删除</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-手写-apply-函数"><a href="#10-手写-apply-函数" class="headerlink" title="10. 手写 apply 函数"></a>10. 手写 apply 函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hyapply</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">thisArg, otherArgs</span>) &#123;<br><br>  <span class="hljs-comment">// 判断调用对象</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&quot;function&quot;</span>)  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;Error&quot;</span>);<br><br>  <span class="hljs-comment">// 获取thisArg, 并且确保是一个对象类型</span><br>  thisArg = (thisArg === <span class="hljs-literal">null</span> || thisArg === <span class="hljs-literal">undefined</span>)? <span class="hljs-attr">window</span>: <span class="hljs-title class_">Object</span>(thisArg)<br>  <span class="hljs-comment">// 上方的window可以改成globalThis更严谨</span><br><br>  <span class="hljs-keyword">const</span> fnKey = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;fn&#x27;</span>); <span class="hljs-comment">// 防止篡改thisArg原有的属性</span><br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(thisArg, fnKey, &#123;  <br>    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">value</span>: <span class="hljs-variable language_">this</span>    <span class="hljs-comment">// this指向调用者</span><br>  &#125;)<br>  thisArg[fnKey](...otherArgs)   <span class="hljs-comment">// 和call的区别就是后面的参数是数组形式</span><br>  <span class="hljs-keyword">delete</span> thisArg[fnKey];  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="11-手写-bind-函数"><a href="#11-手写-bind-函数" class="headerlink" title="11. 手写 bind 函数"></a>11. 手写 bind 函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hybind</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">thisArg, ...otherArgs</span>) &#123;<br><br>  <span class="hljs-comment">// 判断调用对象</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&quot;function&quot;</span>)  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;Error&quot;</span>);<br><br>  thisArg = thisArg === <span class="hljs-literal">null</span> || thisArg === <span class="hljs-literal">undefined</span> ? <span class="hljs-attr">window</span>: <span class="hljs-title class_">Object</span>(thisArg)<br>  <span class="hljs-keyword">const</span> fnKey = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;fn&#x27;</span>); <span class="hljs-comment">// 防止篡改thisArg原有的属性</span><br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(thisArg, fnKey, &#123;<br>    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">value</span>: <span class="hljs-variable language_">this</span><br>  &#125;)<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...newArgs</span>) =&gt;</span> &#123;  <span class="hljs-comment">// 返回一个函数拿去调用</span><br>    <span class="hljs-keyword">var</span> allArgs = [...otherArgs, ...newArgs]  <span class="hljs-comment">// 可能还会传参数</span><br>    thisArg[fnKey](...allArgs)<br>    <span class="hljs-comment">// 因为下次调用还会使用这个fnKey , 所以不要删除</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="12-手写柯里化函数"><a href="#12-手写柯里化函数" class="headerlink" title="12. 手写柯里化函数"></a>12. 手写柯里化函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a,b,c</span>)&#123;<br>  <span class="hljs-keyword">return</span> a+b+c;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">curring</span>(<span class="hljs-params">fn</span>)&#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">cur</span>(<span class="hljs-params">...args</span>)&#123;<br>    <span class="hljs-keyword">if</span>(args.<span class="hljs-property">length</span>&gt;=fn.<span class="hljs-property">length</span>)&#123;<br>      <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>,args);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...newargs</span>)&#123;<br>        <span class="hljs-keyword">return</span> cur.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>,args.<span class="hljs-title function_">concat</span>(newargs));<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> cur;<br>&#125;<br><span class="hljs-keyword">let</span> add=<span class="hljs-title function_">curring</span>(foo);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)); <span class="hljs-comment">// 6</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)); <span class="hljs-comment">// 6</span><br></code></pre></td></tr></table></figure><h3 id="13-实现AJAX请求"><a href="#13-实现AJAX请求" class="headerlink" title="13. 实现AJAX请求"></a>13. 实现AJAX请求</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">SERVER_URL</span> = <span class="hljs-string">&quot;/server&quot;</span>;<br><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br><span class="hljs-comment">// 创建 Http 请求</span><br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-variable constant_">SERVER_URL</span>, <span class="hljs-literal">true</span>);<br><span class="hljs-comment">// 设置状态监听函数</span><br>xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">readyState</span> !== <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-comment">// 当请求成功时</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>    <span class="hljs-title function_">handle</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">response</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>);<br>  &#125;<br>&#125;;<br><span class="hljs-comment">// 设置请求失败时的监听函数</span><br>xhr.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>);<br>&#125;;<br><span class="hljs-comment">// 设置请求头信息</span><br>xhr.<span class="hljs-property">responseType</span> = <span class="hljs-string">&quot;json&quot;</span>;<br>xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>);<br><span class="hljs-comment">// 发送 Http 请求</span><br>xhr.<span class="hljs-title function_">send</span>(<span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure><h3 id="14-使用Promise封装AJAX请求"><a href="#14-使用Promise封装AJAX请求" class="headerlink" title="14. 使用Promise封装AJAX请求"></a>14. 使用Promise封装AJAX请求</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getJSON</span>(<span class="hljs-params">url</span>) &#123;<br>  <span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>    xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, url, <span class="hljs-literal">true</span>);<br>    xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">readyState</span> !== <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span>;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">response</span>);  <span class="hljs-comment">// 注意</span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>));<br>      &#125;<br>    &#125;;<br>    xhr.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>));<br>    &#125;;<br>    xhr.<span class="hljs-property">responseType</span> = <span class="hljs-string">&quot;json&quot;</span>;<br>    xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>);<br>    xhr.<span class="hljs-title function_">send</span>(<span class="hljs-literal">null</span>);<br>  &#125;);<br>  <span class="hljs-keyword">return</span> promise;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="15-浅拷贝的各种实现方法"><a href="#15-浅拷贝的各种实现方法" class="headerlink" title="15. 浅拷贝的各种实现方法"></a>15. 浅拷贝的各种实现方法</h3><p>手写浅拷贝</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">shallowClone</span> = (<span class="hljs-params">target</span>) =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> target === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; target !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">const</span> cloneTarget = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(target) ? []: &#123;&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> prop <span class="hljs-keyword">in</span> target) &#123;<br>      <span class="hljs-keyword">if</span> (target.<span class="hljs-title function_">hasOwnProperty</span>(prop)) &#123;<br>          cloneTarget[prop] = target[prop];<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cloneTarget;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> target;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Object.assign</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;sy&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span> &#125;;<br><span class="hljs-keyword">const</span> obj2 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, obj, &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;sss&#x27;</span>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2);<span class="hljs-comment">//&#123; name: &#x27;sss&#x27;, age: 18 &#125;</span><br></code></pre></td></tr></table></figure><p>数组方法 concat </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> newArr = arr.<span class="hljs-title function_">concat</span>();<br>newArr[<span class="hljs-number">1</span>] = <span class="hljs-number">100</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<span class="hljs-comment">//[ 1, 2, 3 ]</span><br></code></pre></td></tr></table></figure><p>数组方法 slice</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> newArr = arr.<span class="hljs-title function_">slice</span>();<br>newArr[<span class="hljs-number">0</span>] = <span class="hljs-number">100</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<span class="hljs-comment">//[1, 2, 3]</span><br></code></pre></td></tr></table></figure><p>…展开运算符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> newArr = [...arr];<span class="hljs-comment">//跟arr.slice()是一样的效果</span><br></code></pre></td></tr></table></figure><h3 id="16-深拷贝的实现方法"><a href="#16-深拷贝的实现方法" class="headerlink" title="16. 深拷贝的实现方法"></a>16. 深拷贝的实现方法</h3><p>JSON.parse(JSON.stringify(obj))</p><p>它的原理就是利用JSON.stringify 将js对象序列化（JSON字符串），再使用JSON.parse来反序列化(还原)js对象。这时候两个对象的引用就不相同了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj1 = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">b</span>: &#123;<span class="hljs-attr">c</span>: <span class="hljs-number">0</span>&#125; &#125;;<br><span class="hljs-keyword">let</span> obj2 = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj1));<br>obj1.<span class="hljs-property">a</span> = <span class="hljs-number">1</span>;<br>obj1.<span class="hljs-property">b</span>.<span class="hljs-property">c</span> = <span class="hljs-number">1</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1); <span class="hljs-comment">// &#123;a: 1, b: &#123;c: 1&#125;&#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2); <span class="hljs-comment">// &#123;a: 0, b: &#123;c: 0&#125;&#125;</span><br></code></pre></td></tr></table></figure><p>函数库lodash的_.cloneDeep方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> _ = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;lodash&#x27;</span>);<br><span class="hljs-keyword">var</span> obj1 = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">b</span>: &#123; <span class="hljs-attr">f</span>: &#123; <span class="hljs-attr">g</span>: <span class="hljs-number">1</span> &#125; &#125;,<br>    <span class="hljs-attr">c</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>&#125;;<br><span class="hljs-keyword">var</span> obj2 = _.<span class="hljs-title function_">cloneDeep</span>(obj1);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1.<span class="hljs-property">b</span>.<span class="hljs-property">f</span> === obj2.<span class="hljs-property">b</span>.<span class="hljs-property">f</span>);<span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p><strong>⭐ 手写实现深拷贝函数</strong></p><p>具体优化细节可以看<a href="https://www.yuque.com/zweirdo/zxyob8/mkhhq2eoodzvocnb#ggm18">18_深拷贝-事件总线</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isObject</span>(<span class="hljs-params">originValue</span>) &#123;<br>    <span class="hljs-keyword">const</span> myType = <span class="hljs-keyword">typeof</span> originValue;<br>    <span class="hljs-keyword">return</span> myType != <span class="hljs-literal">null</span> &amp;&amp; (myType === <span class="hljs-string">&quot;function&quot;</span> || myType === <span class="hljs-string">&quot;object&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepCopy</span>(<span class="hljs-params">originValue, map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>()</span>) &#123;<br>  <br>    <span class="hljs-comment">// 1.如果值是Symbol的类型</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> originValue === <span class="hljs-string">&quot;symbol&quot;</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Symbol</span>(originValue.<span class="hljs-property">description</span>)<br>    &#125;<br><br>    <span class="hljs-comment">// 2.如果是原始类型或者promise, 直接返回</span><br>    <span class="hljs-comment">// 如果你深拷贝一个 Promise 对象，可能会破坏其异步行为，并且导致意外行为。</span><br>    <span class="hljs-comment">// 这样可以避免破坏异步行为和意外行为。</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isObject</span>(originValue) || originValue <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) &#123;<br>        <span class="hljs-keyword">return</span> originValue<br>    &#125;<br><br>    <span class="hljs-comment">// 3.如果是set类型</span><br>    <span class="hljs-keyword">if</span> (originValue <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Set</span>) &#123;<br>        <span class="hljs-keyword">const</span> newSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> setItem <span class="hljs-keyword">of</span> originValue) &#123;<br>            newSet.<span class="hljs-title function_">add</span>(<span class="hljs-title function_">deepCopy</span>(setItem))<br>        &#125;<br>        <span class="hljs-keyword">return</span> newSet<br>    &#125;<br><br>    <span class="hljs-comment">// 4. 判断值是否为map类型</span><br>    <span class="hljs-keyword">if</span> (originValue <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Map</span>) &#123;<br>        <span class="hljs-keyword">const</span> newMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [i, j] <span class="hljs-keyword">of</span> originValue) &#123;<br>            newMap.<span class="hljs-title function_">set</span>(<span class="hljs-title function_">deepCopy</span>(i, map), <span class="hljs-title function_">deepCopy</span>(j, map));<br>        &#125;<br>        <span class="hljs-keyword">return</span> newMap;<br>    &#125;<br><br>    <span class="hljs-comment">// 5. 处理日期对象</span><br>    <span class="hljs-keyword">if</span> (originValue <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Date</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(originValue.<span class="hljs-title function_">getTime</span>());<br>    &#125;<br><br>    <span class="hljs-comment">// 6. 处理正则表达式对象</span><br>    <span class="hljs-keyword">if</span> (originValue <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">RegExp</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(originValue);<br>    &#125;<br><br>    <span class="hljs-comment">// 7.如果是函数function类型, 不需要进行深拷贝</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> originValue === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>        <span class="hljs-keyword">return</span> originValue<br>    &#125;<br><br>    <span class="hljs-comment">// 8.处理循环引用</span><br>    <span class="hljs-keyword">if</span> (map.<span class="hljs-title function_">get</span>(originValue)) &#123;<br>        <span class="hljs-keyword">return</span> map.<span class="hljs-title function_">get</span>(originValue)<br>    &#125;<br><br>    <span class="hljs-comment">// 9.判断是对象或者数组类型</span><br>    <span class="hljs-keyword">const</span> newObj = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(originValue) ? []: &#123;&#125;<br>    map.<span class="hljs-title function_">set</span>(originValue, newObj)<br><br>    <span class="hljs-comment">// 遍历普通的key</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> originValue) &#123;<br>        newObj[key] = <span class="hljs-title function_">deepCopy</span>(originValue[key], map);<br>    &#125;<br><br>    <span class="hljs-comment">// 单独遍历symbol</span><br>    <span class="hljs-keyword">const</span> symbolKeys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertySymbols</span>(originValue)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> symbolKey <span class="hljs-keyword">of</span> symbolKeys) &#123;<br>        newObj[<span class="hljs-title class_">Symbol</span>(symbolKey.<span class="hljs-property">description</span>)] = <span class="hljs-title function_">deepCopy</span>(originValue[symbolKey], map)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> newObj<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="17-判断循环引用的方法"><a href="#17-判断循环引用的方法" class="headerlink" title="17. 判断循环引用的方法"></a>17. 判断循环引用的方法</h3><p>原生</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">isCycleObject</span> = (<span class="hljs-params">obj, parent</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> parentArr = parent || [obj]; <span class="hljs-comment">//  如果没有传入父级, parentArr就代表包含当前对象的数组</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(parentArr);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> obj) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj[i] === <span class="hljs-string">&quot;object&quot;</span>) &#123;<br>      <span class="hljs-keyword">let</span> flag = <span class="hljs-literal">false</span>;<br>      parentArr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">pObj</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (pObj === obj[i]) &#123;<br>          flag = <span class="hljs-literal">true</span>;<br>        &#125;<br>      &#125;);<br>      <span class="hljs-keyword">if</span> (flag) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      flag = <span class="hljs-title function_">isCycleObject</span>(obj[i], [...parentArr, obj[i]]); <span class="hljs-comment">// 递归调用这个子对象</span><br>      <span class="hljs-keyword">if</span> (flag) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;;<br><br><span class="hljs-keyword">var</span> a = &#123; <span class="hljs-attr">b</span>: &#123; <span class="hljs-attr">c</span>: &#123;&#125; &#125; &#125;;<br><br>a.<span class="hljs-property">b</span>.<span class="hljs-property">c</span>.<span class="hljs-property">d</span> = a;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">isCycleObject</span>(a));<br><span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>递归 + 哈希表</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isCircular</span>(<span class="hljs-params">obj, hash = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>()</span>) &#123;<br>  <span class="hljs-keyword">if</span> (obj === <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&#x27;object&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>  <span class="hljs-keyword">if</span> (hash.<span class="hljs-title function_">has</span>(obj)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>  hash.<span class="hljs-title function_">set</span>(obj, <span class="hljs-literal">true</span>)<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hasOwnProperty</span>.<span class="hljs-title function_">call</span>(obj, key)) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isCircular</span>(obj[key], hash)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><h3 id="1-实现数组的扁平化"><a href="#1-实现数组的扁平化" class="headerlink" title="1. 实现数组的扁平化"></a>1. 实现数组的扁平化</h3><p>实现数组扁平化有 6 种方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript">ary = ary.<span class="hljs-title function_">flat</span>(<span class="hljs-title class_">Infinity</span>); <span class="hljs-comment">// Infinity 代表扁平多少层</span><br>ary = str.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/(\[|\])/g</span>, <span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;,&#x27;</span>) <span class="hljs-comment">// 把括号全部替换为空字符串</span><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]]];<br><span class="hljs-keyword">let</span> fn = <span class="hljs-keyword">function</span>(<span class="hljs-params">ary</span>) &#123;<br>  <span class="hljs-keyword">let</span> result = [];<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; ary.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">let</span> item = ary[i];<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(item))&#123;<br>      result = result.<span class="hljs-title function_">concat</span>(<span class="hljs-title function_">fn</span>(item));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      result.<span class="hljs-title function_">push</span>(item);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">fn</span>(arr))  <span class="hljs-comment">// [ 1, 2, 3, 4, 5 ]</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">flatten</span>(<span class="hljs-params">ary</span>) &#123;<br>    <span class="hljs-keyword">return</span> ary.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">pre, cur</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> pre.<span class="hljs-title function_">concat</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(cur) ? <span class="hljs-title function_">flatten</span>(cur) : cur);<br>    &#125;, []);<br>&#125;<br><span class="hljs-comment">//只要有一个元素有数组，那么循环继续</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">flatten</span>(<span class="hljs-params">arr</span>) &#123;<br>    <span class="hljs-keyword">while</span> (arr.<span class="hljs-title function_">some</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(item))) &#123;<br>        arr = [].<span class="hljs-title function_">concat</span>(...arr);<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]];<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">flatten</span>(<span class="hljs-params">arr</span>) &#123;<br>    <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;,&#x27;</span>).<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Number</span>);<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">flatten</span>(arr)); <span class="hljs-comment">//  [ 1, 2, 3, 4 ]</span><br></code></pre></td></tr></table></figure><p>以上数组 <code>arr.toString()</code> 之后 直接变成了 <code>1,2,3,4</code></p><h3 id="2-实现数组各个方法"><a href="#2-实现数组各个方法" class="headerlink" title="2. 实现数组各个方法"></a>2. 实现数组各个方法</h3><p>flat</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">_flat</span>(<span class="hljs-params">arr, depth</span>) &#123;<br>  <span class="hljs-keyword">if</span>(!<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(arr) || depth &lt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> arr;<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">prev, cur</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(cur)) &#123;<br>      <span class="hljs-keyword">return</span> prev.<span class="hljs-title function_">concat</span>(<span class="hljs-title function_">_flat</span>(cur, depth - <span class="hljs-number">1</span>))<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> prev.<span class="hljs-title function_">concat</span>(cur);<br>    &#125;<br>  &#125;, []);<br>&#125;<br></code></pre></td></tr></table></figure><p>push</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 简便写法</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">push</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">for</span>( <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span> ; i++)&#123;<br><span class="hljs-variable language_">this</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>] = <span class="hljs-variable language_">arguments</span>[i] ;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>;<br>&#125;<br><br><br><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">push</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">...items</span>) &#123;<br>  <span class="hljs-keyword">let</span> O = <span class="hljs-title class_">Object</span>(<span class="hljs-variable language_">this</span>);<br>  <span class="hljs-keyword">let</span> len = <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span> &gt;&gt;&gt; <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> argCount = items.<span class="hljs-property">length</span> &gt;&gt;&gt; <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 2 ** 53 - 1 为JS能表示的最大正整数</span><br>  <span class="hljs-keyword">if</span> (len + argCount &gt; <span class="hljs-number">2</span> ** <span class="hljs-number">53</span> - <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;The number of array is over the max value restricted!&quot;</span>)<br>  &#125;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; argCount; i++) &#123;<br>    O[len + i] = items[i];<br>  &#125;<br>  <span class="hljs-keyword">let</span> newLength = len + argCount;<br>  O.<span class="hljs-property">length</span> = newLength;<br>  <span class="hljs-keyword">return</span> newLength;<br>&#125;<br></code></pre></td></tr></table></figure><p>pop</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">pop</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> O = <span class="hljs-title class_">Object</span>(<span class="hljs-variable language_">this</span>);<br>  <span class="hljs-keyword">let</span> len = <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span> &gt;&gt;&gt; <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (len === <span class="hljs-number">0</span>) &#123;<br>    O.<span class="hljs-property">length</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;<br>  &#125;<br>  len --;<br>  <span class="hljs-keyword">let</span> value = O[len];<br>  <span class="hljs-keyword">delete</span> O[len];<br>  O.<span class="hljs-property">length</span> = len;<br>  <span class="hljs-keyword">return</span> value;<br>&#125;<br></code></pre></td></tr></table></figure><p>filter</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_filter</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fn !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;参数必须是一个函数&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">const</span> res = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>; i &lt; len; i++) &#123;<br>        <span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">this</span>[i]) &amp;&amp; res.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>map</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 简便写法</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">map</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">cb,thisArg</span>)&#123;<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(<span class="hljs-variable language_">this</span>) || <span class="hljs-keyword">typeof</span> cb != <span class="hljs-string">&#x27;function&#x27;</span>)&#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;has Error, please check!&#x27;</span>)<br>    &#125;<br>    <span class="hljs-keyword">var</span> res = []<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>; i++)&#123;<br>     <span class="hljs-comment">//使用call方法来改变this指向即可</span><br>     res.<span class="hljs-title function_">push</span>(cb.<span class="hljs-title function_">call</span>(thisArg,<span class="hljs-variable language_">this</span>[i],i,<span class="hljs-variable language_">this</span>))<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br><br><br><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_map</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">fn</span>) &#123;<br>   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fn !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;参数必须是一个函数&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">const</span> res = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>; i &lt; len; i++) &#123;<br>        res.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">this</span>[i]));<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>reduce</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">reduce</span>  = <span class="hljs-keyword">function</span>(<span class="hljs-params">callbackfn, initialValue</span>) &#123;<br>  <span class="hljs-comment">// 异常处理，和 map 一样</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span> === <span class="hljs-literal">null</span> || <span class="hljs-variable language_">this</span> === <span class="hljs-literal">undefined</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;Cannot read property &#x27;reduce&#x27; of null or undefined&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(callbackfn) != <span class="hljs-string">&quot;[object Function]&quot;</span>) &#123; <span class="hljs-comment">//注意中间无逗号</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(callbackfn + <span class="hljs-string">&#x27; is not a function&#x27;</span>)<br>  &#125;<br>  <span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 后面要重复利用</span><br>  <span class="hljs-keyword">let</span> O = <span class="hljs-title class_">Object</span>(<span class="hljs-variable language_">this</span>);  <span class="hljs-comment">// 先将调用者转为对象</span><br>  <span class="hljs-keyword">let</span> len = O.<span class="hljs-property">length</span> &gt;&gt;&gt; <span class="hljs-number">0</span>;  <span class="hljs-comment">// 确认为整数</span><br>  <span class="hljs-keyword">let</span> accumulator = initialValue; <span class="hljs-comment">// 积累值</span><br>  <span class="hljs-keyword">if</span> (accumulator === <span class="hljs-literal">undefined</span>) &#123;   <span class="hljs-comment">// 没传初始值</span><br>    <span class="hljs-keyword">for</span>(; k &lt; len ; k++) &#123;<br>      <span class="hljs-keyword">if</span> (k <span class="hljs-keyword">in</span> O) &#123;  <br>        accumulator = O[k];<br>        k++;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 表示数组全为空</span><br>  <span class="hljs-keyword">if</span>(k === len &amp;&amp; accumulator === <span class="hljs-literal">undefined</span>) <br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Each element of the array is empty&#x27;</span>);<br>  <br>  <span class="hljs-keyword">for</span>(;k &lt; len; k++) &#123;<br>    <span class="hljs-keyword">if</span> (k <span class="hljs-keyword">in</span> O) &#123;<br>      accumulator = callbackfn.<span class="hljs-title function_">call</span>(<span class="hljs-literal">undefined</span>, accumulator, O[k], k, O);   <span class="hljs-comment">// 注意，核心！</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> accumulator;<br>&#125;<br></code></pre></td></tr></table></figure><p>sort</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> quick_sort = <span class="hljs-keyword">function</span>(<span class="hljs-params">a, l, r</span>)&#123;<br>    <span class="hljs-keyword">if</span>(l &gt;= r)<span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">let</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> x = a[mid];<br>    <span class="hljs-keyword">while</span>(i &lt; j)&#123;<br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span>(a[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span>(a[j] &gt; x);<br>        <span class="hljs-keyword">if</span>(i &lt; j)&#123;<br>            <span class="hljs-keyword">let</span> z = a[i];<br>            a[i] = a[j];<br>            a[j] = z;<br>        &#125;<br>    &#125;<br>    <span class="hljs-title function_">quick_sort</span>(a, l, j);<br>    <span class="hljs-title function_">quick_sort</span>(a, j + <span class="hljs-number">1</span>, r);<br>&#125;<br><span class="hljs-keyword">var</span> q = [<span class="hljs-number">1</span>,<span class="hljs-number">44</span>,<span class="hljs-number">6</span>,<span class="hljs-number">713</span>,<span class="hljs-number">76</span>];<br><span class="hljs-title function_">quick_sort</span>(q, <span class="hljs-number">0</span>, q.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(q);  <span class="hljs-comment">// [ 1, 6, 44, 76, 713 ]</span><br></code></pre></td></tr></table></figure><p>splice 方法(了解原理)</p><details class="lake-collapse"><summary id="u3d2e2d29"><span class="ne-text">代码</span></summary><pre data-language="javascript" id="YT8RU" class="ne-codeblock language-javascript" style="border: 1px solid #e8e8e8; border-radius: 2px; background: #f9f9f9; padding: 16px; font-size: 13px; color: #595959"><code>Array.prototype.splice = function(startIndex, deleteCount, ...addElements)  &#123;  // 1. 初始工作  let argumentsLen = arguments.length;  let array = Object(this);  let len = array.length;  let deleteArr = new Array(deleteCount);<pre><code class="hljs">// 2. 参数的清洗工作</code></pre><p>  &#x2F;&#x2F; 当用户传来非法的 startIndex 和 deleteCount 或者负索引的时候，需要我们做出特殊的处理。<br>  if (startIndex &lt; 0) {<br>    startIndex &#x3D; startIndex + len &gt; 0 ? startIndex + len: 0;<br>  }<br>  else startIndex &#x3D; startIndex &gt;&#x3D; len ? len: startIndex;</p><p>  &#x2F;&#x2F; 删除数目没有传，默认删除startIndex及后面所有的<br>  if (argumentsLen &#x3D;&#x3D;&#x3D; 1)  deleteCount &#x3D; len - startIndex;<br>  else if (deleteCount &lt; 0) deleteCount &#x3D; 0 &#x2F;&#x2F; 删除数目过小<br>  else if (deleteCount &gt; len - startIndex) deletCount &#x3D; len - startIndex; &#x2F;&#x2F;删除数目过大</p><pre><code class="hljs">// 3. 判断 sealed 对象和 frozen 对象, 即 密封对象 和 冻结对象if (Object.isSealed(array) &amp;amp;&amp;amp; deleteCount !== addElements.length) &#123;throw new TypeError(&#39;the object is a sealed object!&#39;)</code></pre><p>  } else if(Object.isFrozen(array) &amp;&amp; (deleteCount &gt; 0 || addElements.length &gt; 0)) {<br>    throw new TypeError(‘the object is a frozen object!’)<br>  }</p><p>  &#x2F;&#x2F; 4.拷贝删除的元素<br>  for (let i &#x3D; 0; i &lt; deleteCount; i++) {<br>    let index &#x3D; startIndex + i;<br>    if (index in array) {<br>      let current &#x3D; array[index];<br>      deleteArr[i] &#x3D; current;<br>    }<br>  }</p><p>  &#x2F;&#x2F; 5.移动删除元素后面的元素</p><p>  &#x2F;&#x2F; 对删除元素后面的元素进行挪动, 挪动分为三种情况:<br>  &#x2F;&#x2F; * 添加的元素和删除的元素个数相等<br>  &#x2F;&#x2F; * 添加的元素个数小于删除的元素<br>  &#x2F;&#x2F; * 添加的元素个数大于删除的元素</p><p>  if (deleteCount &#x3D;&#x3D;&#x3D; addElements.length) &#x2F;&#x2F; 就什么也不管<br>  else if(deleteCount &gt; addElements.length) {<br>    &#x2F;&#x2F; 删除的元素比新增的元素多，那么后面的元素整体向前挪动<br>    for (let i &#x3D; startIndex + deleteCount; i &lt; len; i++) {<br>      let fromIndex &#x3D; i; &#x2F;&#x2F; 移动元素的起始位置<br>      let toIndex &#x3D; i - (deleteCount - addElements.length); &#x2F;&#x2F; 将要挪动到的目标位置<br>      if (fromIndex in array) {<br>        array[toIndex] &#x3D; array[fromIndex];<br>      } else {<br>        delete array[toIndex];<br>      }<br>    }<br>    &#x2F;&#x2F; 注意注意！这里我们把后面的元素向前挪，相当于数组长度减小了，需要删除冗余元素<br>    &#x2F;&#x2F; 目前长度为 len + addElements - deleteCount<br>    for (let i &#x3D; len - 1; i &gt;&#x3D; len + addElements.length - deleteCount; i –) {<br>      delete array[i];<br>    }<br>  }<br>     else if(deleteCount &lt; addElements.length) {<br>    &#x2F;&#x2F; 删除的元素比新增的元素少，那么后面的元素整体向后挪动<br>    &#x2F;&#x2F; 思考一下: 这里为什么要从后往前遍历？从前往后会产生什么问题？<br>    for (let i &#x3D; len - 1; i &gt;&#x3D; startIndex + deleteCount; i–) {<br>      let fromIndex &#x3D; i;  &#x2F;&#x2F; 挪动元素的初始位置<br>      let toIndex &#x3D; i + (addElements.length - deleteCount); &#x2F;&#x2F; 将要挪动到的目标位置<br>      if (fromIndex in array) {<br>        array[toIndex] &#x3D; array[fromIndex];<br>      } else {<br>        delete array[toIndex];<br>      }<br>    }<br>  }</p><p>  &#x2F;&#x2F; 6.插入新元素<br>  for (let i &#x3D; 0; i &lt; addElements.length; i++) {<br>    array[startIndex + i] &#x3D; addElements[i];<br>  }<br>  array.length &#x3D; len - deleteCount + addElements.length;</p><p>  &#x2F;&#x2F; 7.返回被删除元素组成的数组<br>  return deleteArr;<br>}</code></pre></details></p><h3 id="实现数组的乱序输出"><a href="#实现数组的乱序输出" class="headerlink" title="实现数组的乱序输出"></a>实现数组的乱序输出</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>  <span class="hljs-comment">// 注意最后加i就行, 否则会重复输出同一个值</span><br>  <span class="hljs-keyword">const</span> randomIndex = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * (arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span> - i)) + i; <br>  [arr[i], arr[randomIndex]] = [arr[randomIndex], arr[i]];<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr)<br></code></pre></td></tr></table></figure><h3 id="实现字符串的-repeat-方法"><a href="#实现字符串的-repeat-方法" class="headerlink" title="实现字符串的 repeat 方法"></a>实现字符串的 repeat 方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">repeat</span>(<span class="hljs-params">s, n</span>) &#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(n + <span class="hljs-number">1</span>)).<span class="hljs-title function_">join</span>(s);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-实现字符串各个方法"><a href="#3-实现字符串各个方法" class="headerlink" title="3. 实现字符串各个方法"></a>3. 实现字符串各个方法</h3><p>repeat</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">repeat</span>(<span class="hljs-params">s, n</span>) &#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(n + <span class="hljs-number">1</span>)).<span class="hljs-title function_">join</span>(s);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-将数字每千分位用逗号隔开"><a href="#4-将数字每千分位用逗号隔开" class="headerlink" title="4. 将数字每千分位用逗号隔开"></a>4. 将数字每千分位用逗号隔开</h3><p>数字无小数版本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">format</span> = n =&gt; &#123;<br>    <span class="hljs-keyword">let</span> num = n.<span class="hljs-title function_">toString</span>() <br>    <span class="hljs-keyword">let</span> len = num.<span class="hljs-property">length</span><br>    <span class="hljs-keyword">if</span> (len &lt;= <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-keyword">return</span> num<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">let</span> remainder = len % <span class="hljs-number">3</span><br>        <span class="hljs-keyword">if</span> (remainder &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 不是3的整数倍</span><br>          <span class="hljs-comment">// 每隔三个数字用逗号分隔为字符串</span><br>          <span class="hljs-keyword">return</span> num.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, remainder) + <span class="hljs-string">&#x27;,&#x27;</span> + num.<span class="hljs-title function_">slice</span>(remainder, len).<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\d&#123;3&#125;/g</span>).<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;,&#x27;</span>) <br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 是3的整数倍</span><br>            <span class="hljs-keyword">return</span> num.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, len).<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\d&#123;3&#125;/g</span>).<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;,&#x27;</span>) <br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-title function_">format</span>(<span class="hljs-number">1232323</span>)  <span class="hljs-comment">// &#x27;1,232,323&#x27;</span><br></code></pre></td></tr></table></figure><p>数字有小数版本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">format</span> = n =&gt; &#123;<br>    <span class="hljs-keyword">let</span> num = n.<span class="hljs-title function_">toString</span>() <span class="hljs-comment">// 转成字符串</span><br>    <span class="hljs-keyword">let</span> decimals = <span class="hljs-string">&#x27;&#x27;</span><br>        <span class="hljs-comment">// 判断是否有小数</span><br>    num.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;.&#x27;</span>) &gt; -<span class="hljs-number">1</span> ? decimals = num.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;.&#x27;</span>)[<span class="hljs-number">1</span>] : decimals<br>    <span class="hljs-keyword">let</span> len = num.<span class="hljs-property">length</span><br>    <span class="hljs-keyword">if</span> (len &lt;= <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-keyword">return</span> num<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">let</span> temp = <span class="hljs-string">&#x27;&#x27;</span><br>        <span class="hljs-keyword">let</span> remainder = len % <span class="hljs-number">3</span><br>        decimals ? temp = <span class="hljs-string">&#x27;.&#x27;</span> + decimals : temp<br>        <span class="hljs-keyword">if</span> (remainder &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 不是3的整数倍</span><br>            <span class="hljs-keyword">return</span> num.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, remainder) + <span class="hljs-string">&#x27;,&#x27;</span> + num.<span class="hljs-title function_">slice</span>(remainder, len).<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\d&#123;3&#125;/g</span>).<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;,&#x27;</span>) + temp<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 是3的整数倍</span><br>            <span class="hljs-keyword">return</span> num.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, len).<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\d&#123;3&#125;/g</span>).<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;,&#x27;</span>) + temp <br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-title function_">format</span>(<span class="hljs-number">12323.33</span>)  <span class="hljs-comment">// &#x27;12,323.33&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="5-手写日期格式化函数"><a href="#5-手写日期格式化函数" class="headerlink" title="5. 手写日期格式化函数"></a>5. 手写日期格式化函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">dateFormat</span> = (<span class="hljs-params">dateInput, format</span>)=&gt;&#123;<br>    <span class="hljs-keyword">var</span> day = dateInput.<span class="hljs-title function_">getDate</span>() <br>    <span class="hljs-keyword">var</span> month = dateInput.<span class="hljs-title function_">getMonth</span>() + <span class="hljs-number">1</span>  <br>    <span class="hljs-keyword">var</span> year = dateInput.<span class="hljs-title function_">getFullYear</span>()   <br>    format = format.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/yyyy/</span>, year)<br>    format = format.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/MM/</span>,month)<br>    format = format.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/dd/</span>,day)<br>    <span class="hljs-keyword">return</span> format<br>&#125;<br><span class="hljs-title function_">dateFormat</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-string">&#x27;2020-12-01&#x27;</span>), <span class="hljs-string">&#x27;yyyy/MM/dd&#x27;</span>) <span class="hljs-comment">// 2020/12/01</span><br><span class="hljs-title function_">dateFormat</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-string">&#x27;2020-04-01&#x27;</span>), <span class="hljs-string">&#x27;yyyy/MM/dd&#x27;</span>) <span class="hljs-comment">// 2020/04/01</span><br><span class="hljs-title function_">dateFormat</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-string">&#x27;2020-04-01&#x27;</span>), <span class="hljs-string">&#x27;yyyy年MM月dd日&#x27;</span>) <span class="hljs-comment">// 2020年04月01日</span><br></code></pre></td></tr></table></figure><h3 id="6-实现大整数相加"><a href="#6-实现大整数相加" class="headerlink" title="6. 实现大整数相加"></a>6. 实现大整数相加</h3><p>来自算法篇章</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-string">&#x27;13124342343353535235&#x27;</span><br><span class="hljs-keyword">let</span> b = <span class="hljs-string">&#x27;34423434234234243233&#x27;</span><br><span class="hljs-comment">// 两个字符串a, b</span><br><span class="hljs-keyword">let</span> arr1 = a.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Number</span>);<br><span class="hljs-keyword">let</span> arr2 = b.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Number</span>);<br><span class="hljs-keyword">let</span> res = [];<br><span class="hljs-keyword">let</span> flag = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(arr1.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span> || arr2.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>  <span class="hljs-keyword">let</span> t1 = arr1.<span class="hljs-title function_">pop</span>() || <span class="hljs-number">0</span>;  <span class="hljs-comment">// 判断arr1是否已经为空</span><br>  <span class="hljs-keyword">let</span> t2 = arr2.<span class="hljs-title function_">pop</span>() || <span class="hljs-number">0</span>;  <span class="hljs-comment">// 判断arr2是否已经为空</span><br>  <span class="hljs-keyword">let</span> tmp = t1 + t2 + flag;<br>  flag = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(tmp / <span class="hljs-number">10</span>)<br>  res.<span class="hljs-title function_">unshift</span>(tmp % <span class="hljs-number">10</span>)<br>&#125;<br><span class="hljs-keyword">if</span>(flag) res.<span class="hljs-title function_">unshift</span>(flag);<br>res = res.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res); <span class="hljs-comment">// 47547776577587778468</span><br></code></pre></td></tr></table></figure><h3 id="7-解析-URL-Params-为对象"><a href="#7-解析-URL-Params-为对象" class="headerlink" title="7. 解析 URL Params 为对象"></a>7. 解析 URL Params 为对象</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> url = <span class="hljs-string">&#x27;http://www.domain.com/?user=anonymous&amp;id=123&amp;id=456&amp;city=%E5%8C%97%E4%BA%AC&amp;enabled&#x27;</span>;<br><span class="hljs-title function_">parseParam</span>(url)<br><span class="hljs-comment">/* 结果</span><br><span class="hljs-comment">&#123; user: &#x27;anonymous&#x27;,</span><br><span class="hljs-comment">  id: [ 123, 456 ], // 重复出现的 key 要组装成数组，能被转成数字的就转成数字类型</span><br><span class="hljs-comment">  city: &#x27;北京&#x27;, // 中文需解码</span><br><span class="hljs-comment">  enabled: true, // 未指定值得 key 约定为 true</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>exec 是正则的方法</p><p>exec() 方法在一个指定字符串中执行一个搜索匹配。返回一个结果数组或 null。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">parseParam</span>(<span class="hljs-params">url</span>) &#123;<br>  <span class="hljs-keyword">const</span> paramsStr = <span class="hljs-regexp">/.+\?(.+)$/</span>.<span class="hljs-title function_">exec</span>(url)[<span class="hljs-number">1</span>]; <span class="hljs-comment">// 将 ? 后面的字符串取出来❗</span><br>  <span class="hljs-keyword">const</span> paramsArr = paramsStr.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&amp;&#x27;</span>); <span class="hljs-comment">// 将字符串以 &amp; 分割后存到数组中</span><br>  <span class="hljs-keyword">let</span> paramsObj = &#123;&#125;;<br>  <span class="hljs-comment">// 将 params 存到对象中</span><br>  paramsArr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">param</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/=/</span>.<span class="hljs-title function_">test</span>(param)) &#123; <span class="hljs-comment">// 处理有 value 的参数, 存在 &#x27;=&#x27;</span><br>      <span class="hljs-keyword">let</span> [key, val] = param.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;=&#x27;</span>); <span class="hljs-comment">// 分割 key 和 value</span><br>      val = <span class="hljs-built_in">decodeURIComponent</span>(val); <span class="hljs-comment">// 解码❗ 注意还需解码</span><br>      val = <span class="hljs-regexp">/^\d+$/</span>.<span class="hljs-title function_">test</span>(val) ? <span class="hljs-built_in">parseFloat</span>(val) : val; <span class="hljs-comment">// 判断是否转为数字</span><br>      <span class="hljs-keyword">if</span> (paramsObj.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123; <span class="hljs-comment">// 如果对象有 key，则添加一个值</span><br>        paramsObj[key] = [].<span class="hljs-title function_">concat</span>(paramsObj[key], val); <span class="hljs-comment">// 将其变为数组, 因为有多个值, 就用数组存起来</span><br>      &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 如果对象没有这个 key，创建 key 并设置值</span><br>        paramsObj[key] = val;<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 处理没有 value 的参数</span><br>      paramsObj[param] = <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;)<br>  <span class="hljs-keyword">return</span> paramsObj;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>手写</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue响应式原理</title>
    <link href="/2023/09/12/Vue%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"/>
    <url>/2023/09/12/Vue%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="1-认识响应式逻辑"><a href="#1-认识响应式逻辑" class="headerlink" title="1. 认识响应式逻辑"></a>1. 认识响应式逻辑</h2><blockquote><p>抽象描绘</p></blockquote><ul><li>假如你有一个变量m , 你的某一段代码使用了变量m , 如果某个时刻变量m发生了改变, 那么这段代码也会重新执行.</li><li>但实际上执行的代码中可能不止一行代码，所以我们可以将这些代码放到一个函数中, 于是就变成了, <strong>你有一个对象, 你的某个函数使用了对象的某个属性, 如果某个时候这个属性发生改变, 这个函数也会重新执行</strong></li></ul><blockquote><p>具体描述</p></blockquote><p>数据驱动视图 </p><p>简洁版 :</p><p>在 Vue 实例创建过程中，首先对所有属性进行劫持 ( vue2 &#x2F; vue3 方法和原理都不同, 注意辨别 ) ,   同时会为每个数据属性创建一个 <code>Dep</code>（依赖），Dep 用于收集所有订阅了该属性的 <code>Watcher</code>。当属性值发生变化时，Vue 会通知该属性对应的这些 <code>Watcher</code> 实例进行相应的更新操作。</p><ul><li>数据响应式</li></ul><p>Vue采用的是<strong>数据劫持</strong>结合<strong>发布和-订阅者模式</strong>的方式</p><blockquote><p> 通过拦截对数据的操作，在数据变动时发布消息给订阅者，触发相应的监听回调。</p></blockquote><h3 id=""><a href="#" class="headerlink" title=""></a></h3><ul><li>数据劫持</li></ul><blockquote><p>vue2数据劫持</p></blockquote><p>vue2通过<code>Object.defineProperty</code>对<code>data</code>上的数据<strong>递归地</strong>进行(转为)<code>getter</code>和<code>setter</code>操作。也就是对属性的读取、修改进行拦截（数据劫持）</p><p>注意是将 data 中的所有属性进行监听</p><blockquote><p>vue3 数据劫持</p></blockquote><p>vue3通过<code>Proxy</code>对象创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。<code>Proxy</code>的监听是深层次的，<strong>监听整个对象，而不是某个属性。</strong></p><p>这里是将 reactive () 中的所有属性进行监听</p><ul><li>发布者-订阅者模式</li></ul><p>简单地说，发布者-订阅者模式的流程就是，监听器<code>**Observer**</code>监听数据状态变化, 一旦数据发生变化，则会通知(数据)对应的订阅者<code>**Watcher**</code>，让订阅者执行对应的业务逻辑 。</p><ul><li>整个响应式执行过程</li></ul><ol><li>在 Vue 实例初始化过程中， 我们设置了一个监听器<code>**Observer**</code>，此实例的所有相关属性会被监听(也就是上方的数据劫持)  . 在此过程中，Vue 会对<strong>每个属性</strong>创建一个 <code>dep</code> 实例</li></ol><ul><li>vue2 对 data 中的属性进行遍历生成 <code>dep</code> 实例</li><li>vue3 中对 <code>reactive()</code> 中的对象进行遍历生成 <code>dep</code> 实例</li><li><code>dep</code> 实例会收集所有订阅了该属性的 <code>Watcher 订阅者</code>, 并将该 <code>Watcher</code> 绑定更新函数</li><li>这些更新函数可能会执行一些操作，比如更新模板中的文本、计算新的值等</li></ul><ol><li>通过<code>Compile</code>解析模板指令，将模板中的数据和方法与真实 DOM 节点关联起来，使得数据和方法能够被视图访问和使用, 然后再初始化渲染页面视图.</li><li>一旦属性发生变化，Vue 会通知所有订阅了当前属性的的订阅者<code>Watcher</code>(这些 <code>Watcher</code> 放在属性对应的 <code>dep</code> 实例当中), 来执行此订阅者对应的更新函数,  从而更新视图.</li></ol><blockquote><p> MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</p></blockquote><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309210946810.png" alt="image-20230921094628751"></p><h2 id="2-响应式依赖收集"><a href="#2-响应式依赖收集" class="headerlink" title="2. 响应式依赖收集"></a>2. 响应式依赖收集</h2><h3 id="2-1-响应式函数的实现watchFn"><a href="#2-1-响应式函数的实现watchFn" class="headerlink" title="2.1. 响应式函数的实现watchFn"></a>2.1. 响应式函数的实现watchFn</h3><p>我们现在实现一个响应式函数</p><p>◼ 但是我们怎么区分呢？</p><ul><li>这个时候我们封装一个新的函数<code>watchFn</code>；</li><li><strong>凡是传入到watchFn的函数，就是需要响应式的；</strong></li><li>其他默认定义的函数都是不需要响应式的；</li></ul><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927280.png" alt="img"></p><p>如图, foo以及bar都是需要响应式的</p><p>我们将这些函数在响应之前先执行一次</p><p>当obj的某个属性发生变化时, 就依次执行reactiveFns中的函数</p><p>目前当然是极为不完善, 待后续优化hhh</p><h3 id="2-2-响应式依赖的收集-类"><a href="#2-2-响应式依赖的收集-类" class="headerlink" title="2.2. 响应式依赖的收集__类"></a>2.2. 响应式依赖的收集__类</h3><p>◼ 目前我们收集的依赖是放到一个数组中来保存的，但是这里会存在数据管理的问题：</p><ul><li> 我们在实际开发中<strong>需要监听很多对象的响应式；</strong></li><li> 这些对象需要监听的不只是一个属性，它们很多属性的变化，都会有对应的响应式函数；</li><li> 我们不<strong>可能在全局维护一大堆的数组来保存这些响应函数；</strong></li></ul><p>◼ 所以我们要<strong>设计一个类，这个类用于管理某一个对象的某一个属性的所有响应式函数：</strong></p><ul><li> 相当于替代了原来的简单 reactiveFns 的数组；</li></ul><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927189.png" alt="img"></p><p>这个类记住</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927257.png" alt="img"></p><p>当我们某个属性发生变化时, 只需执行dep.notify()就行了, 无需一个一个的遍历函数</p><p>这个obj对象就对应Depend类所创建出来的对象</p><p>当然, 还需大大的优化</p><p>现在我们每次修改了一个属性之后都是手动的去调用, 这样太麻烦了, 我们想要让它自动去调用响应函数,</p><p>因此我们要去监听属性的变化</p><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h2 id="3-Object-defineProperty-监听属性变化"><a href="#3-Object-defineProperty-监听属性变化" class="headerlink" title="3. Object.defineProperty()监听属性变化"></a>3. Object.defineProperty()监听属性变化</h2><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927250.png" alt="img"></p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927238.png" alt="img"></p><p>再记一遍这个类</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927292.png" alt="img"></p><p>注意看注释</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927814.png" alt="img"></p><p>这里在属性变化后就不用手动给它通知了, 自动响应实现</p><p>不过这种收集方式其实是错误的hhhhh</p><h2 id="4-自动收集依赖-🔥"><a href="#4-自动收集依赖-🔥" class="headerlink" title="4. 自动收集依赖 🔥"></a>4. 自动收集依赖 🔥</h2><p>我们现在发现了一个问题 , obj 对象的两个属性都依赖于 同一个dep对象的reactiveFns,</p><p>这样就会造成我们根本没办法区分它们</p><p>对于同一个对象来说, 我们还是给它放到了同一个dep里面, 这会造成无法将它的属性区分</p><p><strong>如何解决这个问题呢 ?</strong> </p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927843.png" alt="img"></p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927050.png" alt="img"></p><p>比如我们要获取obj对象的name属性的依赖</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> dep = objMap.<span class="hljs-title function_">get</span>(obj).<span class="hljs-title function_">get</span>(name);<br>dep.<span class="hljs-title function_">notifiy</span>();<br></code></pre></td></tr></table></figure><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927155.png" alt="img"></p><ul><li><p>dep对象数据结构的管理</p></li><li><p>每一个对象的每一个属性都会对应一个dep对象</p></li><li><p>同一个对象的多个属性的dep对象是存放一个map对象中</p></li><li><p>多个对象的map对象, 会被存放到一个objMap的对象中</p></li><li><p>当执行get函数, 自动的添加fn函数</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Depend</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span> = []<br>  &#125;<br><br>  <span class="hljs-title function_">addDepend</span>(<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-keyword">if</span> (fn) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span>.<span class="hljs-title function_">push</span>(fn)<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-title function_">notify</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> &#123;<br>      <span class="hljs-title function_">fn</span>()<br>    &#125;)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span><br>&#125;<br><br><span class="hljs-comment">// 设置一个专门执行响应式函数的一个函数</span><br><span class="hljs-keyword">let</span> reactiveFn = <span class="hljs-literal">null</span> <span class="hljs-comment">// </span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">watchFn</span>(<span class="hljs-params">fn</span>) &#123;<br>  reactiveFn = fn<br>  <span class="hljs-title function_">fn</span>() <span class="hljs-comment">// 执行下方的get方法 , 使得间接的把函数加到特定的dep对象上</span><br>  <span class="hljs-comment">//(因为函数中会有一些对象会有一些属性)</span><br>  reactiveFn = <span class="hljs-literal">null</span> <span class="hljs-comment">// 使用完后再置为null, 不然可能会造成影响</span><br>&#125;<br><br><span class="hljs-comment">// 封装一个函数: 负责通过obj的key获取对应的Depend对象</span><br><span class="hljs-comment">// 我们用一个WeakMap对所有对象进行管理, 我们不需要对里面进行强引用, </span><br><span class="hljs-comment">// 如果有一天obj为null,那就无法销毁了</span><br><span class="hljs-keyword">const</span> objMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>()<br><br><br><span class="hljs-comment">// 这个函数的作用是通过对象的key找到它的dep对象</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getDepend</span>(<span class="hljs-params">obj, key</span>) &#123;<br>  <br>  <span class="hljs-comment">// 1.根据对象obj, 找到对应的map对象</span><br>  <span class="hljs-keyword">let</span> map = objMap.<span class="hljs-title function_">get</span>(obj) <span class="hljs-comment">// 没有就new一个</span><br>  <span class="hljs-keyword">if</span> (!map) &#123;<br>    map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br>    objMap.<span class="hljs-title function_">set</span>(obj, map)<br>  &#125;<br><br>  <span class="hljs-comment">// 2.根据key, 找到对应的depend对象</span><br>  <span class="hljs-keyword">let</span> dep = map.<span class="hljs-title function_">get</span>(key)<br>  <span class="hljs-keyword">if</span> (!dep) &#123;<br>    dep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Depend</span>()<br>    map.<span class="hljs-title function_">set</span>(key, dep)<br>  &#125;<br>  <span class="hljs-keyword">return</span> dep<br>&#125;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> value = obj[key]<br><br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, key, &#123;<br>    <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">newValue</span>) &#123;<br>      value = newValue<br>      <span class="hljs-comment">// 拿到这个对象的属性的dep对象</span><br>      <span class="hljs-keyword">const</span> dep = <span class="hljs-title function_">getDepend</span>(obj, key)<br>      dep.<span class="hljs-title function_">notify</span>()  <span class="hljs-comment">// 对这些</span><br>    &#125;,<br>    <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-comment">// 在函数中拿到obj 和 key 就会调用这个get方法</span><br>      <span class="hljs-comment">// console.log(&quot;get函数中:&quot;, obj, key)</span><br>      <span class="hljs-comment">// 找到对应的obj对象的key对应的dep对象</span><br>      <span class="hljs-keyword">const</span> dep = <span class="hljs-title function_">getDepend</span>(obj, key) <br>      <span class="hljs-comment">// 意味着我们只会创建obj对象的key属性的dep对象</span><br>      dep.<span class="hljs-title function_">addDepend</span>(reactiveFn) <br>      <span class="hljs-comment">// 精髓 : 在这个dep对象上放入跟特有对象的特有属性相关的函数,即reactiveFn</span><br>      <span class="hljs-comment">// dep这个对象就是保存了跟这个特有对象特有属性相关的一些函数</span><br>      <br>      <span class="hljs-keyword">return</span> value<br>    &#125;<br>  &#125;)<br>&#125;)<br><br><span class="hljs-title function_">watchFn</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;foo function&quot;</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;foo:&quot;</span>, obj.<span class="hljs-property">name</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;foo&quot;</span>, obj.<span class="hljs-property">age</span>)<br>&#125;)<br><br><span class="hljs-title function_">watchFn</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;bar function&quot;</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;bar:&quot;</span>, obj.<span class="hljs-property">age</span> + <span class="hljs-number">10</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>注意看注释 !!!!!</p><p>你用了我的数据, 我就收集你的依赖, 你没用, 我就不收集 —</p><p>我们还有可以优化的点 : </p><p>当我们执行下面这段代码时</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927937.png" alt="img"></p><p>age发生变化时, 它会执行两次函数</p><p>我们可以这样操作</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927105.png" alt="img"></p><p>我们的reactiveFns是一个Set, 这样它就不会添加相同的函数到这里面去</p><p>然后下方的push改为add</p><p>还有一个地方是我们可以给<img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927328.png" alt="img">这个地方换个写法</p><p>我们并不希望将reactiveFn添加放到get中，因为它是属于Dep的行为 (也可以不换, 看自己 )</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927511.png" alt="img"></p><p>我们直接在类中添加一个方法自动获取收集的函数<code>depend()</code></p><p>相当于利用到这个自由变量<code>reactiveFn</code></p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927495.png" alt="img"></p><p>然后直接<code>dep.depen()</code>调用即可</p><p>不过这两种写法都可以 hhh</p><p>但这个代码还有不足, 关于<strong>多个对象</strong>, 我们如何给它挨个来自动收集依赖, 因为我们这里是写死给obj对象自动收集依赖的</p><p>如何解决呢? </p><p>方法如下hhh —- 多个对象响应式</p><h2 id="5-多个对象响应式"><a href="#5-多个对象响应式" class="headerlink" title="5. 多个对象响应式"></a>5. 多个对象响应式</h2><p>我们只需要将监听对象属性的这一串代码封装为一个函数</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927710.png" alt="img"></p><p>这里我们将这一串代码封装为一个函数reactive, 我们创建的对象就可以作为参数传递进去, 那么这个对象的所有属性就能被监听到了, 然后我们<strong>返回一个被监听的对象</strong></p><p>注意 : 需要返回这个对象哈, 别搞忘了</p><p>然后我们在创建对象时使用这个函数, 那么对象的所有属性就能被监听到了</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927717.png" alt="img"></p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927766.png" alt="img"></p><p>以上都是vue2响应式原理(也就是defineProperty), 接下来我们用vue3对代码进行重构</p><p>特别easy</p><h2 id="6-vue3-监听对象-proxy"><a href="#6-vue3-监听对象-proxy" class="headerlink" title="6. vue3__监听对象__proxy"></a>6. vue3__监听对象__proxy</h2><p>我们直接将</p><p>Object.defineProperty</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927710.png" alt="img"></p><p>这部分代码改成</p><p>proxy</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927876.png" alt="img"></p><p>在我们调用了Proxy的get捕获器时, 收集依赖</p><p>因为如果一个函数中使用了某个对象的key，那么它应该被收集依赖；</p><p>这部分代码即可</p><p>都是学过的东西 , 忘了就翻翻前面的笔记 </p><h2 id="7-完整响应式代码"><a href="#7-完整响应式代码" class="headerlink" title="7. 完整响应式代码"></a>7. 完整响应式代码</h2><p>完整响应式代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Depend</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()<br>  &#125;<br><br>  <span class="hljs-title function_">addDepend</span>(<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-keyword">if</span> (fn) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span>.<span class="hljs-title function_">add</span>(fn)<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-title function_">depend</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (reactiveFn) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span>.<span class="hljs-title function_">add</span>(reactiveFn)<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-title function_">notify</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> &#123;<br>      <span class="hljs-title function_">fn</span>()<br>    &#125;)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> reactiveFn = <span class="hljs-literal">null</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">watchFn</span>(<span class="hljs-params">fn</span>) &#123;<br>  reactiveFn = fn<br>  <span class="hljs-title function_">fn</span>()<br>  reactiveFn = <span class="hljs-literal">null</span><br>&#125;<br><br><span class="hljs-keyword">const</span> objMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>()<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getDepend</span>(<span class="hljs-params">obj, key</span>) &#123;<br>  <span class="hljs-comment">// 1.根据对象obj, 找到对应的map对象</span><br>  <span class="hljs-keyword">let</span> map = objMap.<span class="hljs-title function_">get</span>(obj)<br>  <span class="hljs-keyword">if</span> (!map) &#123;<br>    map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br>    objMap.<span class="hljs-title function_">set</span>(obj, map)<br>  &#125;<br><br>  <span class="hljs-comment">// 2.根据key, 找到对应的depend对象</span><br>  <span class="hljs-keyword">let</span> dep = map.<span class="hljs-title function_">get</span>(key)<br>  <span class="hljs-keyword">if</span> (!dep) &#123;<br>    dep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Depend</span>()<br>    map.<span class="hljs-title function_">set</span>(key, dep)<br>  &#125;<br>  <span class="hljs-keyword">return</span> dep<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">reactive</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">const</span> objProxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;<br>    <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">target, key, newValue, receiver</span>) &#123;<br>      <span class="hljs-comment">// target[key] = newValue</span><br>      <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, newValue, receiver)<br>      <span class="hljs-keyword">const</span> dep = <span class="hljs-title function_">getDepend</span>(target, key)<br>      dep.<span class="hljs-title function_">notify</span>()<br>    &#125;,<br>    <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">target, key, receiver</span>) &#123;<br>      <span class="hljs-keyword">const</span> dep = <span class="hljs-title function_">getDepend</span>(target, key)<br>      dep.<span class="hljs-title function_">depend</span>()<br>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver)<br>    &#125;<br>  &#125;)<br>  <span class="hljs-keyword">return</span> objProxy <br>&#125;<br></code></pre></td></tr></table></figure><p>业务代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = <span class="hljs-title function_">reactive</span>(&#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>  <span class="hljs-attr">address</span>: <span class="hljs-string">&quot;广州市&quot;</span><br>&#125;)<br><br><span class="hljs-title function_">watchFn</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">name</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">age</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">age</span>)<br>&#125;)<br><br><span class="hljs-comment">// 修改name</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;--------------&quot;</span>)<br><span class="hljs-comment">// obj.name = &quot;kobe&quot;</span><br>obj.<span class="hljs-property">age</span> = <span class="hljs-number">20</span><br><span class="hljs-comment">// obj.address = &quot;上海市&quot;</span><br><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;=============== user =================&quot;</span>)<br><span class="hljs-keyword">const</span> user = <span class="hljs-title function_">reactive</span>(&#123;<br>  <span class="hljs-attr">nickname</span>: <span class="hljs-string">&quot;abc&quot;</span>,<br>  <span class="hljs-attr">level</span>: <span class="hljs-number">100</span><br>&#125;)<br><br><span class="hljs-title function_">watchFn</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;nickname:&quot;</span>, user.<span class="hljs-property">nickname</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;level:&quot;</span>, user.<span class="hljs-property">level</span>)<br>&#125;)<br><br>user.<span class="hljs-property">nickname</span> = <span class="hljs-string">&quot;cba&quot;</span><br></code></pre></td></tr></table></figure><p>执行结果</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927019.png" alt="img"></p><p>总结 : </p><ul><li>Vue3主要是通过Proxy来监听数据的变化以及收集相关的依赖的；</li><li>ue2中通过我们前面学习过的Object.defineProerty的方式来实现对象属性的监听；</li></ul>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>手写</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>后端抽象理解</title>
    <link href="/2023/06/19/%E5%90%8E%E7%AB%AF%E5%BD%A2%E8%B1%A1%E7%90%86%E8%A7%A3%E7%AF%87/"/>
    <url>/2023/06/19/%E5%90%8E%E7%AB%AF%E5%BD%A2%E8%B1%A1%E7%90%86%E8%A7%A3%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h2 id="如何形象的理解-spring"><a href="#如何形象的理解-spring" class="headerlink" title="如何形象的理解 spring?"></a>如何形象的理解 spring?</h2><blockquote><p>依赖注入框架，帮助你管理 Java 对象，集成一些其他的内容</p></blockquote><p>让我们用通俗易懂的语言来解释Spring框架。</p><p>想象一下你在组装一台电脑。你需要连接各个硬件组件，如CPU、内存、硬盘等，并确保它们能够协同工作。Spring框架就像是电脑组装的助手，它帮助你管理和组织各个组件，并提供一些便捷的功能。</p><p>在这个比喻中：</p><ul><li>你可以将硬件组件看作是你的应用程序中的不同部分，如服务、数据访问对象、控制器等。</li><li>Spring框架则扮演了管理和组织这些组件的角色，确保它们能够协同工作。</li><li>框架提供了一种便捷的方式来连接和配置这些组件，就像你将硬件组件插入主板上的插槽一样。</li><li>框架还提供了一些额外的功能，如依赖注入（DI），就像是帮助你将各个硬件组件连接在一起，使它们可以相互通信和协作。</li><li>你可以使用框架提供的功能来实现业务逻辑，就像在电脑上运行软件应用程序一样。</li></ul><p>总的来说，Spring框架是一个帮助你管理和组织应用程序组件的工具。它简化了开发过程，提供了便捷的连接和配置方式，并提供了一些额外的功能来增强应用程序的灵活性和可维护性。使用Spring框架，你可以更轻松地构建和管理复杂的应用程序，并提供高效、可靠的功能。</p><h2 id="如何形象的理解依赖注入"><a href="#如何形象的理解依赖注入" class="headerlink" title="如何形象的理解依赖注入?"></a>如何形象的理解依赖注入?</h2><p>让我们用一个日常生活的比喻来形象地理解依赖注入。</p><p>假设你是一个厨师，需要准备一道菜。为了完成这道菜，你需要使用一些食材，如蔬菜、肉类、调味料等。</p><p>在没有依赖注入的情况下，你可能需要自己去购买这些食材，并将它们携带到厨房。这意味着你要亲自管理食材的采购、携带和使用过程。这可能会增加你的负担和工作量，还可能导致混乱和错误。</p><p>现在，假设你有一个厨师助手，他负责为你提供所需的食材。这就是依赖注入的概念在生活中的体现。</p><p>在这个比喻中：</p><ul><li>你是主厨，负责菜的制作，即应用程序的核心逻辑。</li><li>食材是你所需要的依赖对象，如服务、数据访问对象等。</li><li>厨师助手是依赖注入的机制，负责将食材提供给你，以供你使用。</li><li>依赖注入让你从繁琐的采购和管理任务中解放出来，专注于菜的制作。</li></ul><p>在编程中，依赖注入的概念类似。它是一种设计模式，通过在需要使用某个对象的地方将其注入（提供）给目标对象，减少了目标对象与依赖对象之间的耦合性。这样，目标对象可以专注于自己的业务逻辑，而不需要关心如何创建或获取依赖对象。</p><p>总而言之，依赖注入就像是一个厨师助手为你提供所需食材一样，它让你从繁琐的依赖管理中解放出来，让你的代码更加清晰、模块化和可维护。它使代码的组织和协作更加灵活和简单。</p><h2 id="如何形象的理解-springmvc"><a href="#如何形象的理解-springmvc" class="headerlink" title="如何形象的理解 springmvc ?"></a>如何形象的理解 springmvc ?</h2><blockquote><p>web 框架，提供接口访问、restful接口等能力</p></blockquote><p>让我们用一个类比来形象地理解Spring MVC。</p><p>假设你是一家快餐店的服务员，负责接待顾客并处理他们的点餐请求。</p><p>在没有Spring MVC的情况下，你可能需要一个人来处理所有的任务，包括接待顾客、记录点餐、取餐、上菜等。这样的情况下，你可能会感到忙碌和混乱，很难有效地处理顾客的需求。</p><p>现在，假设快餐店引入了Spring MVC框架来协助你进行工作。这就是Spring MVC的作用。</p><p>在这个比喻中：</p><ul><li>你是服务员，负责处理顾客的点餐请求，即处理Web请求的控制器。</li><li>顾客是Web应用的用户，发送请求给服务器。</li><li>Spring MVC框架则扮演了一个协调者的角色，负责接收请求、路由请求到适当的控制器，并将结果返回给用户。</li><li>框架提供了一些便捷的功能，如请求路由、参数绑定、视图渲染等，使你能够更加高效地处理顾客的点餐请求。</li></ul><p>使用Spring MVC，你可以将业务逻辑分散到不同的控制器中，每个控制器负责处理特定类型的请求。这样，你可以更好地组织和管理代码，并提供更好的用户体验。</p><p>总而言之，Spring MVC就像是一个服务员的协助工具，帮助你更好地处理Web请求，分散和管理业务逻辑，并提供高效的处理方式。它简化了开发过程，提供了便捷的路由和控制功能，使得Web应用的开发更加模块化、可维护和可扩展。</p><h2 id="如何形象的理解-mybatis"><a href="#如何形象的理解-mybatis" class="headerlink" title="如何形象的理解 mybatis ?"></a>如何形象的理解 mybatis ?</h2><blockquote><p>Java 操作数据库的框架，持久层框架，对 jdbc 的封装</p></blockquote><p>让我们用一个类比来形象地理解MyBatis。</p><p>假设你是一个图书管理员，负责管理图书馆的图书和借阅记录。</p><p>在没有MyBatis的情况下，你可能需要手动管理图书和借阅记录的存储、查询和更新。这意味着你需要编写大量的SQL语句来执行数据库操作，并处理与数据库的连接、事务等细节。这样的工作可能会非常繁琐和复杂。</p><p>现在，假设你有一个智能助手，他帮助你<strong>自动化处理图书和借阅记录的管理</strong>。这就是MyBatis的作用。</p><p>在这个比喻中：</p><ul><li>你是图书管理员，负责处理图书和借阅记录的管理，即数据访问对象（DAO）。</li><li>图书和借阅记录是数据库中的数据，需要进行存储、查询和更新。</li><li>MyBatis框架则扮演了一个智能助手的角色，负责处理与数据库的交互和操作。</li><li>框架提供了一种便捷的方式来映射数据库表和<code>Java</code>对象，并提供了一些SQL执行和结果映射的功能。</li></ul><p>使用MyBatis，你可以通过简单的配置文件和注解来定义SQL语句和参数映射，而无需手动编写大量的SQL语句。框架会自动处理与数据库的连接、事务和结果集的映射，让你更专注于业务逻辑的实现。</p><p>总而言之，MyBatis就像是一个智能助手，帮助你简化和自动化与数据库的交互和操作。它减少了手动编写SQL语句的工作量，提供了便捷的数据访问方式，并帮助你更好地组织和管理数据库操作的代码。使用MyBatis，你可以更轻松地进行数据库操作，并提供高效和可维护的数据访问层。</p><h2 id="如何形象的理解-mybatis-plus"><a href="#如何形象的理解-mybatis-plus" class="headerlink" title="如何形象的理解 mybatis - plus ?"></a>如何形象的理解 mybatis - plus ?</h2><blockquote><p>对 mybatis 的增强，不用写 sql 也能实现增删改查</p></blockquote><p>让我们用一个类比来形象地理解MyBatis-Plus。</p><p>假设你是一位室内设计师，负责设计客户的家居装修方案。</p><p>在没有MyBatis-Plus的情况下，你可能需要从头开始设计和实施每个客户的装修方案。这意味着你需要考虑并编写各种细节，如房间布局、材料选择、色彩搭配等。这样的工作可能会非常繁琐和耗时。</p><p>现在，假设你有一个装修助手，他为你提供了一套标准化的装修方案和设计模板。这就是MyBatis-Plus的作用。</p><p>在这个比喻中：</p><ul><li>你是室内设计师，负责设计和实施装修方案，即数据访问对象（DAO）。</li><li>客户是数据库中的表，每个客户对应一张表，需要进行增删改查等操作。</li><li>MyBatis-Plus框架则扮演了一个装修助手的角色，提供了一系列标准化的操作和设计模板。</li><li>框架提供了一种简单的方式来定义实体类和数据库表的映射关系，并提供了一些通用的数据访问功能。</li></ul><p>使用MyBatis-Plus，你可以通过简单的注解和配置来定义实体类和数据库表的映射关系，而无需手动编写繁琐的SQL语句。框架会自动处理与数据库的连接、事务和CRUD操作，让你更专注于业务逻辑的实现。</p><p>总而言之，MyBatis-Plus就像是一个装修助手，为你提供了一套标准化的操作和设计模板。它简化了数据访问层的开发过程，提供了便捷的数据访问方式，并帮助你更好地组织和管理数据库操作的代码。使用MyBatis-Plus，你可以更轻松地进行数据库操作，并提供高效和可维护的数据访问层。</p><h2 id="如何形象的理解-springboot"><a href="#如何形象的理解-springboot" class="headerlink" title="如何形象的理解 springboot ?"></a>如何形象的理解 springboot ?</h2><blockquote><p>快速启动 &#x2F; 快速集成项目。不用自己管理 spring 配置，不用自己整合各种框架</p></blockquote><p>让我们用一个类比来形象地理解Spring Boot。</p><p>假设你是一位厨师，需要准备一道复杂的菜肴。</p><p>在没有Spring Boot的情况下，你需要从头开始购买食材、准备厨房、研究菜谱、调整烹饪参数等。这意味着你需要花费大量的时间和精力来完成每个环节，才能最终完成菜肴的制作。</p><p>现在，假设你有一套现成的厨房设备和标准化的食谱，这就是Spring Boot的作用。</p><p>在这个比喻中：</p><ul><li>你是厨师，负责设计和制作菜肴，即应用程序的开发者。</li><li>菜肴是应用程序，需要进行配置、开发和部署等操作。</li><li>Spring Boot框架则扮演了一个现成的厨房设备和标准化的食谱的角色，提供了一套预定义的配置和开发规范。</li><li>框架帮助你简化了应用程序的搭建和开发过程，提供了自动配置、内嵌服务器、依赖管理等功能。</li></ul><p>使用Spring Boot，你可以通过简单的配置和约定来快速搭建和开发应用程序，无需手动处理繁琐的配置和依赖管理。框架会自动处理与服务器的集成、配置的加载和管理，让你更专注于业务逻辑的实现。</p><p>总而言之，Spring Boot就像是一个现成的厨房设备和标准化的食谱，帮助你快速搭建和开发应用程序。它简化了应用程序的搭建和开发过程，提供了自动化的配置和依赖管理，让你能够更轻松地构建高效和可维护的应用程序。</p><blockquote><p>Spring Boot是Spring的一个子项目，旨在简化Spring应用程序的搭建和开发过程，通过自动配置和约定大于配置的原则，提供了一套预定义的规范和配置，使得开发者能够更快速地创建独立的、自包含的应用程序。</p></blockquote><h2 id="什么是-junit-单元测试库"><a href="#什么是-junit-单元测试库" class="headerlink" title="什么是 junit 单元测试库?"></a>什么是 junit 单元测试库?</h2><p>JUnit是一个Java单元测试库，用于编写和执行单元测试。它提供了一组用于编写测试用例的注解和断言方法，可以帮助开发者进行自动化的单元测试。</p><p>JUnit的主要作用是帮助开发者验证代码的正确性和稳定性。通过编写单元测试用例，开发者可以针对代码的不同模块、方法或类编写测试代码，用于验证其预期行为是否符合预期。单元测试可以帮助开发者发现和修复代码中的bug，减少代码出错的可能性，并提高代码的质量和可维护性。</p><p>JUnit提供了一些常用的注解，如<code>@Test</code>用于标记测试方法，<code>@Before</code>和<code>@After</code>用于在测试方法执行前后执行一些初始化和清理操作，<code>@BeforeClass</code>和<code>@AfterClass</code>用于在所有测试方法执行前后执行一次初始化和清理操作。此外，JUnit还提供了一系列的断言方法，如<code>assertEquals</code>、<code>assertTrue</code>、<code>assertFalse</code>等，用于验证测试结果是否符合预期。</p><p>使用JUnit，开发者可以编写简洁、可重复运行的测试用例，并通过运行JUnit测试来自动执行这些测试用例，获取测试结果。这样可以提高开发效率，减少手动测试的工作量，并保证代码的可靠性和稳定性。</p><p>总之，JUnit是一个Java单元测试库，它提供了注解和断言方法，用于编写和执行单元测试，帮助开发者验证代码的正确性和稳定性，并提高代码的质量和可维护性。</p><h2 id="关于用户登录状态管理的详细过程："><a href="#关于用户登录状态管理的详细过程：" class="headerlink" title="关于用户登录状态管理的详细过程："></a>关于用户登录状态管理的详细过程：</h2><ol><li><p>客户端与服务器建立连接后，服务器为客户端创建一个会话（session），并返回会话的标识符（session ID）给客户端。这个会话可以是匿名会话，表示客户端尚未登录。</p></li><li><p>当用户成功登录时，服务器会为该用户创建一个具有用户信息的会话对象，并将会话对象存储在服务器端。通常会将用户信息存储在会话对象的属性中，例如，将用户ID、用户名等信息存储为会话属性。</p></li><li><p>服务器将会话的标识符（session ID）发送给客户端，并要求客户端将其存储为一个 cookie。这个 cookie 的作用是在客户端保存会话标识符，以便在后续的请求中携带该会话标识符。</p></li><li><p>客户端接收到服务器返回的会话标识符后，将其存储为 cookie，保存在客户端浏览器中。</p></li><li><p>当客户端再次向服务器发送请求时，在请求头中会包含该域名下的所有 cookie 信息，包括会话标识符。</p></li><li><p>服务器接收到请求后，从请求头中提取出会话标识符，通过该标识符在服务器端查找对应的会话对象。</p></li><li><p>服务器根据会话标识符找到对应的会话对象后，可以从会话对象中获取存储的用户信息，如用户的登录名等。</p></li></ol><p>总结：通过将会话标识符存储在客户端的 cookie 中，客户端在后续的请求中携带该会话标识符，使服务器能够识别客户端，并通过会话对象管理用户的登录状态和其他相关信息。</p><p>需要注意的是，上述过程是一种常见的用户登录状态管理方式，但实际上，还有其他方法可以实现用户登录状态的管理，如使用 JSON Web Token (JWT) 等。具体的实现方式可能因框架和技术选型而有所差异。</p><h2 id="简单说明cookie和session"><a href="#简单说明cookie和session" class="headerlink" title="简单说明cookie和session"></a><strong>简单说明cookie和session</strong></h2><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcode">🪔 以最常见的登陆案例讲解cookie的使用过程：<br>（<span class="hljs-number">1</span>）首先用户在客户端浏览器向服务器首次发起登陆请求<br>（<span class="hljs-number">2</span>）登陆成功后，服务端会把登陆的用户信息设置在cookie 中，并将cookie返回给客户端浏览器<br>（<span class="hljs-number">3</span>）客户端浏览器接收到 cookie 请求后，会把 cookie 保存到本地<span class="hljs-comment">(可能是内存，也可能是磁盘，看具体使用情况而定)</span><br>（<span class="hljs-number">4</span>）以后再次访问该 web 应用时，客户端浏览器就会把本地的 cookie 带上，这样服务端就能根据 cookie 获得用户信息了<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">🪔 同样以登陆案例为例子讲解 <span class="hljs-keyword">session</span> 的使用过程：<br>（<span class="hljs-number">1</span>）首先用户在客户端浏览器发起登陆请求<br>（<span class="hljs-number">2</span>）登陆成功后，服务端会把用户信息保存在服务端，并返回一个唯一的 <span class="hljs-keyword">session</span> 标识给客户端浏览器。<br>（<span class="hljs-number">3</span>）客户端浏览器会把这个唯一的 <span class="hljs-keyword">session</span> 标识保存在起来<br>（<span class="hljs-number">4</span>）以后再次访问 web 应用时，客户端浏览器会把这个唯一的 <span class="hljs-keyword">session</span> 标识带上，这样服务端就能根据这个唯一标识找到用户信息。<br></code></pre></td></tr></table></figure><p><strong>看到这里可能会引起疑问：把唯一的 session 标识返回给客户端浏览器，然后保存起来，以后访问时带上，这难道不是 cookie 吗？</strong></p><blockquote><p>没错，session 只是一种会话机制，在许多 web 应用中，session 机制就是通过 cookie 来实现的。也就是说它只是使用了 cookie 的功能，并不是使用 cookie完成会话保存。与 cookie 在保存客户端保存会话的机制相反，session 通过 cookie 的功能把会话信息保存到了服务端。</p></blockquote><p><strong>session和cookie有什么区别？</strong></p><ol><li><p>cookie 是浏览器提供的一种缓存机制，它可以用于维持客户端与服务端之间的会话</p></li><li><p>session 指的是维持客户端与服务端会话的一种机制，它可以通过 cookie 实现，也可以通过别的手段实现。</p></li><li><p>如果用 cookie 实现会话，那么会话会保存在客户端浏览器中</p></li><li><p>而 session 机制提供的会话是保存在服务端的。</p></li></ol><p><strong>举个小例子说明Cookie和Session之间的区别和联系</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">🦥 <br>假如一个咖啡店有喝五杯赠一杯咖啡的优惠，但是一次性消费<span class="hljs-number">5</span>杯咖啡的客人很少，这时就需要某种方式来记录某位顾客的消费数量。无外乎下面的几种方案：<br><span class="hljs-number">1</span>、该店的店员很厉害，能记住每位顾客的消费数量，只要顾客一走进咖啡店，店员就知道该怎么对待了。这种做法就是协议本身支持状态。但是<span class="hljs-keyword">http</span>协议本身是无状态的。<br><span class="hljs-number">2</span>、发给顾客一张卡片，上面记录着消费的数量，一般还有个有效期限。每次消费时，如果顾客出示这张卡片，则此次消费就会与以前或以后的消费相联系起来。这种做法就是在客户端保持状态，也就是cookie，顾客就相当于浏览器。<br><span class="hljs-number">3</span>、发给顾客一张会员卡，除了卡号之外什么信息也不纪录，每次消费时，如果顾客出示该卡片，则店员在店里的记录本上找到这个卡号对应的记录添加一些消费信息。这种做法就是在服务器端保持状态。<br></code></pre></td></tr></table></figure><h2 id="正向代理和反向代理的区别是什么"><a href="#正向代理和反向代理的区别是什么" class="headerlink" title="正向代理和反向代理的区别是什么?"></a>正向代理和反向代理的区别是什么?</h2><p><a href="https://www.cnblogs.com/taostaryu/p/10547132.html">原文</a></p><blockquote><p>代理其实就是一个中介，A和B本来可以直连，中间插入一个C，C就是中介。<br>刚开始的时候，代理多数是帮助内网client访问外网server用的<br>后来出现了反向代理，”反向”这个词在这儿的意思其实是指方向相反，即代理将来自外网客户端的请求转发到内网服务器，从外到内.</p></blockquote><h4 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h4><p>正向代理类似一个跳板机，代理访问外部资源 .</p><p>比如我们国内访问谷歌，直接访问访问不到，我们可以通过一个正向代理服务器，请求发到代理服，代理服务器能够访问谷歌，这样由代理去谷歌取到返回数据，再返回给我们，这样我们就能访问谷歌了 .</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202306181011210.png" alt="image-20230618101113110"></p><p><strong>正向代理的用途：</strong></p><ol><li>访问原来无法访问的资源，如google</li><li>可以做缓存，加速访问资源</li><li>对客户端访问授权，上网进行认证</li><li>代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息</li></ol><h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><p>反向代理（Reverse Proxy）实际运行方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202306181011725.png" alt="image-20230618101124689"></p><p><strong>反向代理的作用：</strong></p><ol><li>保证内网的安全，阻止web攻击，大型网站，通常将反向代理作为公网访问地址，Web服务器是内网 . </li><li>负载均衡，通过反向代理服务器来优化网站的负载</li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>正向代理即是客户端代理, 代理客户端, 服务端不知道实际发起请求的客户端.</strong></p><p><strong>反向代理即是服务端代理, 代理服务端, 客户端不知道实际提供服务的服务端</strong></p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202306181014100.png" alt="image-20230618101447052"></p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202306181013811.png" alt="image-20230618101318766"></p><h2 id="java项目中target文件是什么文件"><a href="#java项目中target文件是什么文件" class="headerlink" title="java项目中target文件是什么文件?"></a>java项目中target文件是什么文件?</h2><p><code>target</code> 文件夹通常是在构建过程中由构建工具生成的默认输出目录，例如 Maven 或 Gradle。在 Maven 项目中，<code>target</code> 文件夹用于存储编译后的类文件、资源文件和生成的构建产物（如 JAR 文件）等。</p><p>当你执行 Maven 的构建命令（如 <code>mvn package</code>）时，Maven 会将项目的源代码编译成字节码，并将编译后的类文件和其他资源文件输出到 <code>target</code> 文件夹中。此外，构建工具还会在 <code>target</code> 文件夹中生成其他与构建过程相关的临时文件和日志文件。</p><p>通常情况下，<code>target</code> 文件夹的内容应该是可以被忽略的，不应该被版本控制系统（如 Git）所跟踪。这是因为 <code>target</code> 文件夹的内容可以通过重新构建项目来生成，而不需要将生成的文件包含在版本控制中。</p><p>需要注意的是，<code>target</code> 文件夹的名称可以在 Maven 或 Gradle 的配置文件中进行自定义，但通常情况下，<code>target</code> 是默认的输出目录名称。</p><h2 id="java项目中controller文件的作用是什么"><a href="#java项目中controller文件的作用是什么" class="headerlink" title="java项目中controller文件的作用是什么?"></a>java项目中controller文件的作用是什么?</h2><p>在Java项目中，控制器（Controller）的作用是处理客户端发起的请求并返回响应。它充当了应用程序的入口点，协调不同的组件来完成特定的业务逻辑。控制器主要负责以下几个方面的工作：</p><ol><li><p><strong>接收请求</strong>：控制器监听特定的URL路径或请求方法，并接收来自客户端的请求。它充当了请求的入口，接收并解析请求参数、路径、请求体等信息。</p></li><li><p><strong>处理业务逻辑</strong>：一旦接收到请求，控制器会调用相应的服务（Service）或业务逻辑组件来处理具体的业务逻辑。它可以从数据库、外部服务或其他组件中获取数据，并对数据进行处理、转换或验证。</p></li><li><p><strong>调用服务层</strong>：控制器通常与服务层（Service Layer）进行交互，通过依赖注入或手动创建实例来调用服务层提供的方法。服务层负责封装业务逻辑，处理数据持久化、事务管理、业务规则等操作。</p></li><li><p><strong>返回响应</strong>：控制器根据请求处理的结果生成相应的响应，并将其返回给客户端。响应可以是HTML页面、JSON数据、文件下载等形式。控制器负责将响应数据封装成适当的格式，并设置响应头和状态码。</p></li><li><p><strong>路由和URL映射</strong>：控制器根据不同的URL路径和请求方法来映射到相应的处理方法。它通过使用路由配置或注解来定义URL与处理方法之间的映射关系，以便将请求正确地分发到对应的处理方法。</p></li><li><p><strong>控制流程和验证</strong>：控制器可以处理用户输入的验证和数据校验，确保数据的合法性和完整性。它还可以根据业务需求决定请求的流程，例如重定向、转发或错误处理等。</p></li></ol><p>总之，控制器在Java项目中起着连接用户界面、业务逻辑和数据持久化层的桥梁作用。它接收并处理请求，协调其他组件完成特定的业务功能，并将处理结果返回给客户端。控制器的设计良好与否对于项目的可维护性、可测试性和灵活性具有重要影响。</p><h2 id="java项目里mapper的作用是什么"><a href="#java项目里mapper的作用是什么" class="headerlink" title="java项目里mapper的作用是什么?"></a>java项目里mapper的作用是什么?</h2><p>在Java项目中，Mapper（或称为数据访问对象，DAO）的作用是封装对数据库的访问操作。它充当了应用程序和数据库之间的桥梁，负责执行数据库查询、更新、插入和删除等操作。Mapper的主要作用如下：</p><ol><li><p><strong>数据库访问</strong>：Mapper负责与数据库进行交互，执行SQL语句或调用数据库的API来完成数据的读取、写入和修改操作。它封装了对数据库的底层访问细节，使开发人员可以以面向对象的方式操作数据库，而无需直接编写原始的SQL语句。</p></li><li><p><strong>对象关系映射</strong>（ORM）：Mapper将数据库中的表和实体对象进行映射，实现了对象与关系数据库之间的转换。它通过配置或注解定义实体类和数据库表之间的映射关系，使开发人员可以以面向对象的方式操作数据，而不需要关注数据库的具体实现细节。</p></li><li><p><strong>数据库事务管理</strong>：Mapper可以处理数据库事务，确保一组数据库操作要么全部成功提交，要么全部回滚。它提供了事务的开始、提交和回滚等操作，使开发人员能够在一致的状态下操作数据库，保持数据的完整性和一致性。</p></li><li><p><strong>查询优化和性能调优</strong>：Mapper可以通过编写高效的SQL语句或使用数据库的特定特性来优化查询性能。它可以利用数据库的索引、缓存机制、分页查询等功能来提高数据访问的效率，减少数据库的负载和响应时间。</p></li><li><p><strong>数据库访问的抽象层</strong>：Mapper提供了对数据库访问的高层抽象，使开发人员能够以面向对象的方式对数据进行操作，而不必关注数据库的细节。它提供了一组通用的CRUD（创建、读取、更新、删除）方法，简化了对数据的操作。</p></li></ol><p>总之，Mapper在Java项目中起着与数据库交互的角色，负责执行数据库操作、实现对象与数据库之间的映射以及提供事务管理等功能。它使开发人员能够以面向对象的方式操作数据库，提高了开发效率和代码的可维护性。通过使用Mapper，可以将数据库操作与业务逻辑解耦，提供了灵活性和可扩展性，使得数据访问更加方便和高效。</p><h2 id="IService和BaseMapper它们的区别是什么"><a href="#IService和BaseMapper它们的区别是什么" class="headerlink" title="IService和BaseMapper它们的区别是什么?"></a>IService<T>和BaseMapper<T>它们的区别是什么?</h2><p><code>IService&lt;T&gt;</code> 和 <code>BaseMapper&lt;T&gt;</code> 是 MyBatis-Plus 框架中的两个核心接口，它们在功能和作用上有一些区别。</p><p><code>IService&lt;T&gt;</code> 接口是用于定义通用的业务操作方法的接口，提供了对数据库表进行常见的增删改查操作的方法定义。它包含了一系列的方法，如保存实体对象、删除记录、更新记录、查询记录等。开发人员可以通过实现 <code>IService&lt;T&gt;</code> 接口或继承该接口来自定义业务逻辑操作。</p><p><code>BaseMapper&lt;T&gt;</code> 接口是 MyBatis-Plus 框架提供的基础映射器接口，用于定义数据库表的基本操作方法。它继承了 MyBatis 中的 <code>Mapper&lt;T&gt;</code> 接口，并额外添加了一些常见的数据库操作方法，如插入记录、删除记录、更新记录、查询记录等。<code>BaseMapper&lt;T&gt;</code> 接口提供了对数据库表进行基本操作的能力。</p><p>区别总结如下：</p><ul><li><code>IService&lt;T&gt;</code> 是定义通用业务操作方法的接口，用于封装和定义业务逻辑，提供了更高层次的抽象，使得业务逻辑更加简洁和易于维护。</li><li><code>BaseMapper&lt;T&gt;</code> 是基础映射器接口，用于定义数据库表的基本操作方法，提供了对数据库的增删改查能力。</li><li><code>IService&lt;T&gt;</code> 可以自定义业务逻辑方法，对数据库操作进行封装，而 <code>BaseMapper&lt;T&gt;</code> 主要提供了一些基本的数据库操作方法。</li><li><code>IService&lt;T&gt;</code> 可以根据具体业务需求进行扩展和定制，而 <code>BaseMapper&lt;T&gt;</code> 主要用于执行基本的数据库操作。</li></ul><p>在实际开发中，通常会同时使用 <code>IService&lt;T&gt;</code> 和 <code>BaseMapper&lt;T&gt;</code> 接口。<code>IService&lt;T&gt;</code> 可以作为业务层的接口，定义具体业务操作方法，而 <code>BaseMapper&lt;T&gt;</code> 则作为数据访问层的接口，提供基本的数据库操作方法。这样可以将业务逻辑和数据访问操作进行解耦，并提高代码的可读性和可维护性。</p><h2 id="Autowired注解的作用是什么"><a href="#Autowired注解的作用是什么" class="headerlink" title="@Autowired注解的作用是什么?"></a>@Autowired注解的作用是什么?</h2><p><code>@Autowired</code> 注解是 Spring 框架提供的依赖注入注解，用于自动装配对象。</p><p>作用如下：</p><ol><li>自动装配依赖对象：<code>@Autowired</code> 注解可以自动将标注的属性、构造函数或方法参数与容器中匹配的 bean 进行关联，完成依赖对象的注入。</li><li>简化配置：通过 <code>@Autowired</code> 注解，可以省去手动配置依赖对象的步骤，由 Spring 容器自动查找并注入所需的对象。</li><li>解决对象之间的耦合：通过依赖注入，对象之间的关系由容器管理，减少了对象之间的直接依赖，降低了耦合性，提高了代码的灵活性和可维护性。</li><li>提高代码的可测试性：使用依赖注入可以方便进行单元测试，可以轻松替换依赖对象或使用模拟对象进行测试。</li></ol><p>要注意的是，使用 <code>@Autowired</code> 注解进行自动装配时，需要保证容器中存在匹配的 bean 对象。如果存在多个匹配的 bean 对象，可以结合使用 <code>@Qualifier</code> 注解或通过指定 bean 的名称进行限定，以确定要注入的具体对象。</p><p>另外，<code>@Autowired</code> 注解可以用于字段、构造函数、Setter 方法以及一些特殊的注入场景，例如 <code>@Autowired</code> 与 <code>@Qualifier</code> 的组合使用，以及与 <code>@Value</code> 注解一起使用等。</p><p>当用户使用网上零食商城的零食分类模块时，以下是一个具体的流程示例：</p><ol><li>用户进入网上零食商城的零食分类页面。</li><li>用户提供分类条件，例如选择特定的食品类别、价格范围或品牌等。</li><li>用户点击”搜索”或类似的按钮，将输入条件传递给零食分类模块。</li><li>零食分类模块接收用户输入的条件。</li><li>模块开始处理用户输入的条件，进行以下步骤：<ul><li>分析用户选择的食品类别、价格范围或品牌等条件。</li><li>查询数据库或调用相关接口，获取与用户条件匹配的零食列表。</li><li>对零食列表进行筛选和排序，根据用户的排序要求或其他标准进行处理。</li><li>生成经过分类和排序的零食列表。</li></ul></li><li>零食分类模块将处理结果返回给用户界面。</li><li>用户界面展示分类结果，包括零食的名称、价格、图片等信息（O1）。</li><li>用户可以浏览所展示的零食列表，查看详细信息，并选择感兴趣的零食进行购买。</li><li>用户可以选择特定的分类结果，例如点击特定的分类标签。</li><li>用户界面将用户选择的分类结果传递给零食分类模块。</li><li>模块接收用户选择的分类结果并进行处理，展示与选择分类匹配的零食列表（O2）。</li><li>用户界面展示根据</li><li>用户选择的分类结果所筛选出的零食列表，供用户浏览和购买。</li><li>用户可以继续浏览和购买感兴趣的零食，或者返回重新选择分类条件。</li></ol>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>费曼学习法</title>
    <link href="/2023/06/10/%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95/"/>
    <url>/2023/06/10/%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="关于费曼学习法"><a href="#关于费曼学习法" class="headerlink" title="关于费曼学习法"></a>关于费曼学习法</h2><blockquote><p>前两天偶然间了解到了费曼学习法, 算是拓宽了我对学习方法的认知. </p><p>它可以简化为四个单词 </p></blockquote><p><code>Concept</code> (概念) – <code>Teach</code> (教给别人) – <code>Review</code> (回顾) – <code>Simplify</code> (简化)</p><ol><li>第一步 : 假装把一个知识(概念) 教给一个小孩子 .</li></ol><p>尽量用最基础的词汇, 以使得这些小孩子刚好能理解这些基本的概念和知识, 当你卡壳了, 也就是不知道如何解释某个概念或与其它知识的联系的时候 – 预示着学习的机会到来了. </p><ol start="2"><li>第二步 : 回顾</li></ol><p>你已经发现了你大脑知识库的边缘, 懂得自己能力的界限也是一种能力. 你需要回到自己的原始材料, 重新学习, 直到你可以用基本的术语解释这一概念. </p><ol start="3"><li>第三步: 将语言条理化 , 简化</li></ol><p>要保证你的手上有一套自己的手写笔记 , 检查一下确保自己没有从原材料中借用任何行话. 请阅读一遍自己的手写笔记 , 如果听起来比较混乱 , 这意味着你还需要更深入的理解该领域 . 这时候你需要重新回到第二步 —— 一直重复直到你的手写笔记解释得通俗易懂且有条理性 . </p><ol start="4"><li>第四步(可选) : 传授</li></ol><p>如果你真的确保你的理解没什么问题, 检测知识最终的途径就是你能有能力把它传播给另一个人 , 如果没有这样一个具象的人 , 那你可以将自己的笔记分享出去 , 通过大家的反馈以使得自己对知识的理解更加通透. </p><blockquote><p>昨天基本上一整天时间都花在搭建博客上了, 这个学习方法也没有得到应用, 从今儿开始, 尝试这种学习方法~🎆</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>日常琐碎</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习方法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的第一篇博客</title>
    <link href="/2023/06/09/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/06/09/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="我的第一篇博客"><a href="#我的第一篇博客" class="headerlink" title="我的第一篇博客"></a>我的第一篇博客</h1><blockquote><p>分享琐碎</p></blockquote><p>忙里偷闲, 或者说闲来无事吧, 实际上, 时间已经来到期末, 可是呢, 我还是保留着对技术的疯狂热情, 搭建这个博客是因为偶然间在星球冲浪时, 看见一位大佬所写的hexo搭建博客系列. 正是这一契机让我花了大半天时间搞了这一个博客.</p><p>其实之前也有花时间搭过一个博客, 是通过 <code>VuePress</code> 搭建的 </p><p>(刚刚搞了好久的图床哈哈哈哈哈哈哈哈哈哈, 主要是通过 阿里云 + Pikgo + Typora 构建的)<br><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202306092321545.png" alt="image-20230609232105109"></p><p>这界面还是略显花哨 , 相比呢以下界面就显得非常滴简约好看</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202306092322286.png" alt="image-20230609232220960"> </p><p>话不多说, 准备优化博客咯 —— hh</p>]]></content>
    
    
    <categories>
      
      <category>日常琐碎</category>
      
    </categories>
    
    
    <tags>
      
      <tag>感想</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
