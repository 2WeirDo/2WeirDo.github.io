<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>关于浏览器的单进程/多进程架构</title>
    <link href="/2023/10/17/%E6%B5%8F%E8%A7%88%E5%99%A8--/"/>
    <url>/2023/10/17/%E6%B5%8F%E8%A7%88%E5%99%A8--/</url>
    
    <content type="html"><![CDATA[<p>Chrome打开一个页面需要启动多少进程？</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310171854683.png" alt="img"></p><p><strong>仅仅打开了1个页面，为什么有4个进程？</strong></p><p>在解答这个问题之前，我们需要了解一下进程与线程的概念。</p><h3 id="1-进程和线程"><a href="#1-进程和线程" class="headerlink" title="1. 进程和线程"></a>1. 进程和线程</h3><p>计算机中的并行处理就是同一时刻处理多个任务, 比如我们要计算三个表达式的值，并显示出结果。</p><ul><li>正常情况下程序可以使用<strong>单线程</strong>来处理，也就是分四步按照顺序分别执行这四个任务。</li><li>但如果采用<strong>多线程</strong>，我们只需分“两步走” : 第一步，使用三个线程同时执行前三个任务；第二步，再执行第四个显示任务。</li></ul><p><strong>通过对比发现用单线程执行需要四步，而使用多线程只需要两步。因此，使用并行处理能大大提升性能。</strong></p><p>多线程可以并行处理任务，但是线程是不能单独存在的，它是由进程来启动和管理的。</p><blockquote><p>什么是进程呢?</p></blockquote><p>一个<strong>进程</strong>就是一个程序的运行实例。</p><p>详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。</p><blockquote><p>单线程与多线程的进程对比图</p></blockquote><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310171854780.png" alt="img"></p><p><strong>从图中可以看到，线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率。</strong></p><p><strong>进程和线程之间的关系有以下4个特点。</strong></p><ol><li><strong>进程中的任意一线程执行出错，都会导致整个进程的崩溃。</strong></li><li><strong>线程之间共享进程中的数据。</strong></li><li><strong>当一个进程关闭之后，操作系统会回收进程所占用的内存。</strong></li></ol><ul><li>当一个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。</li></ul><ol start="4"><li><strong>进程之间的内容相互隔离</strong></li></ol><ul><li>正是因为进程之间的数据是严格隔离的，所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进行数据的通信这时候，就需要使用用于进程间通信（IPC）的机制了。</li></ul><h3 id="2-单进程浏览器时代"><a href="#2-单进程浏览器时代" class="headerlink" title="2. 单进程浏览器时代"></a>2. 单进程浏览器时代</h3><p>单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里些模块包含了网络、插件、JavaScript运行环境、渲染引擎和页面等。<img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310171854877.png" alt="img"></p><p>如此多的功能模块运行在一个进程里，是导致单进程浏览器<strong>不稳定、不流畅和不安全</strong>的一个主要因素。</p><p><strong>不稳定</strong></p><ul><li>早期浏览器需要借助于插件来实现诸如Web视频、Web游戏等各种强大的功能，但是插件是最容易出问题的模块，并且还运行在浏览器进程之中，所以一个插件的意外崩溃会引起整个浏览器的崩溃</li><li>除了插件之外，渲染引擎模块也是不稳定的，通常一些复杂的JavaScript代码就有可能引起渲染引擎模块的崩溃。和插件一样，渲染引擎的崩溃也会导致整个浏览器的崩溃。</li></ul><p><strong>不流畅</strong></p><ul><li>单进程浏览器中所有页面的渲染模块、JavaScript执行环境以及插件都是运行在同一个线程中的，这就意味着同一时刻只能有一个模块可以执行。<strong>当有脚本发生无限循环时，</strong>它会独占整个线程，这样导致其他运行在该线程中的模块就没有机会被执行。因为浏览器中所有的页面都运行在该线程中，所以这些页面都没有机会去执行任务，这样就会导致整个浏览器失去响应，变卡顿。</li><li>除了上述脚本或者插件会让单进程浏览器变卡顿外，<strong>页面的内存泄漏</strong>也是单进程变慢的一个重要原因。通常浏览器的内核都是非常复杂的，运行一个复杂点的页面再关闭页面，会存在内存不能完全回收的情况，这样导致的问题是使用时间越长，内存占用越高，浏览器会变得越慢。</li></ul><p><strong>不安全</strong></p><ul><li>插件可以使用C&#x2F;C++等代码编写，<strong>通过插件可以获取到操作系统的任意资源，</strong>当你在页面运行一个插件时也就意味着这个插件能完全操作你的电脑。如果是个恶意插件，那么它就可以释放病毒、窃取你的账号密码，引发安全性问题。</li><li><strong>页面脚本可以通过浏览器的漏洞来获取系统权限</strong>，这些脚本获取系统权限之后也可以对你的电脑做一些恶意的事情，同样也会引发安全问题。</li></ul><blockquote><p>好在现代浏览器已经解决了这些问题，是如何解决的呢？这就得聊聊我们这个“多进程浏览器时代”了。</p></blockquote><h3 id="3-多进程浏览器时代"><a href="#3-多进程浏览器时代" class="headerlink" title="3. 多进程浏览器时代"></a>3. 多进程浏览器时代</h3><blockquote><p>多进程浏览器架构的特点</p></blockquote><p><strong>稳定</strong></p><ul><li>由于进程是相互隔离的，所以当一个页面或者插件崩溃时，影响到的仅仅是当前的页面进程或者插件进程，并不会影响到浏览器和其他页面，这就完美地解决了页面或者插件的崩溃会导致整个浏览器崩溃，也就是不稳定的问题。</li></ul><p><strong>流畅</strong></p><ul><li>JavaScript也是运行在渲染进程中的，所以即使<strong>JavaScript阻塞了渲染进程</strong>，影响到的也只是当前的渲染页面，而并不会影响浏览器和其他页面，因为其他页面的脚本是运行在它们自己的渲染进程中的。所以即使Chrome中运行上面死循环的脚本时，没有响应的仅仅也是当前的页面。</li><li>对于<strong>内存泄漏的解决方法</strong>那就更简单了，因为当关闭一个页面时，整个渲染进程也会被关闭，之后该进程所占用的内存都会被系统回收，这样就轻松解决了浏览器页面的内存泄漏问题。</li></ul><p><strong>安全</strong></p><ul><li>采用多进程架构的额外好处是可以使用安全沙箱。沙箱可以看成是操作系统给进程上了一把锁，沙箱里面的程序可以运行，但是不能在你的硬盘上写入任何数据，也不能在敏感位置读取任何数据。</li><li>例如你的文档和桌面。Chrome把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。</li></ul><blockquote><p>目前的多进程架构</p></blockquote><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310171854713.png" alt="img"></p><p>从图中可以看出，最新的Chrome浏览器包括：</p><p>1个浏览器（Browser）主进程、1个 GPU 进程、1个网络（NetWork）进程、多个渲染进程和多个插件进程。</p><blockquote><p>下面来逐个分析下这几个进程的功能：</p></blockquote><p><strong>Browser浏览器进程</strong></p><p>主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。</p><p><strong>渲染进程</strong></p><p>核心任务是将 HTML、CSS 和 JS 转换为用户可以与之交互的网页，排版引擎Blink和JS引擎V8都是运行在该进程中，默认情况下，Chrome会为每个Tab标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</p><p><strong>GPU进程</strong></p><p>Chrome刚开始发布的时候是没有GPU进程的。而GPU的使用初衷是为了实现3D CSS的效果，只是随后网页、Chrome的UI界面都选择采用GPU来绘制，这使得GPU成为浏览器普遍的需求。最后，Chrome在其多进程架构上也引入了GPU进程。</p><p><strong>NetWork网络进程</strong></p><p>主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</p><p><strong>插件进程</strong></p><p>主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。</p><p>讲到这里，现在应该就明白文章开头提到的问题了：</p><p><strong>仅仅打开了1个页面，为什么有4个进程？</strong></p><p>开1个页面至少需要1个网络进程、1个浏览器进程、1个GPU进程以及1个渲染进程，共4个；如果打开的页面有运行插件的话，还需要再加上1个插件进程。</p><h3 id="4-渲染进程中的线程"><a href="#4-渲染进程中的线程" class="headerlink" title="4. 渲染进程中的线程"></a>4. 渲染进程中的线程</h3><p>我们平时看到的浏览器呈现出页面过程中，大部分工作都是在渲染进程中完成，所以我们来看一下渲染进程中的线程。</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310171854633.png" alt="img"></p><p><strong>GUI渲染线程：</strong></p><ul><li>负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。</li><li>当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行</li><li>注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时&#x2F;执行完时立即被执行。</li></ul><p><strong>JS引擎线程：</strong></p><ul><li><p>也称为JS内核，负责处理Javascript脚本程序。如V8引擎</p></li><li><p>JS引擎线程负责解析Javascript脚本，运行代码。</p></li><li><p>JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序</p></li><li><p>同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</p></li></ul><p><strong>事件触发线程</strong></p><ul><li>归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）</li><li>当<code>js</code>代码在解析时，遇到事件比如鼠标事件时，会将这些任务添加到事件触发线程中</li><li>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理</li><li>注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）</li></ul><p><strong>定时触发器线程</strong></p><ul><li>指setInterval与setTimeout所在线程</li><li>浏览器定时计数器并不是由JavaScript引擎计数的，因为JS引擎是单线程的，所以如果处于阻塞状态，那么就会影响记计时的准确，所以需要单独的线程来负责计时器工作。</li><li>计时完毕后，添加到事件队列中，等待JS引擎空闲后执行。</li><li>注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。</li></ul><p><strong>异步http请求线程：</strong></p><ul><li>XMLHttpRequest连接后浏览器开的一个线程，比如请求有回调函数，异步线程就会将回调函数加入事件队列，等待JS引擎空闲执行</li><li>将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。</li></ul>]]></content>
    
    
    <categories>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你了解发布-订阅模式吗?</title>
    <link href="/2023/10/16/%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%E5%90%97/"/>
    <url>/2023/10/16/%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%E5%90%97/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是发布订阅模式"><a href="#什么是发布订阅模式" class="headerlink" title="什么是发布订阅模式"></a>什么是发布订阅模式</h3><blockquote><p>在软件架构中，发布&#x2F;订阅（Publish–subscribe pattern）是一种消息范式，消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者）。而是将发布的消息分为不同的类别，无需了解哪些订阅者（如果有的话）可能存在。同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者（如果有的话）存在。</p></blockquote><p>发布-订阅模式的发布和订阅都由统一的一个调度中心来处理，那也就是说这个模式呢是有三部分组成的</p><ul><li>发布者：将消息事件发布到调度中心</li><li>订阅者： 把自己想关注的消息事件，注册到调度中心</li><li>调度中心：处理事件注册与发布</li></ul><blockquote><p>有什么作用呢，就是在异步编程中实现更松的解耦</p></blockquote><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310162023791.png" alt="img"></p><h3 id="与观察者模式的区别❗"><a href="#与观察者模式的区别❗" class="headerlink" title="与观察者模式的区别❗"></a>与观察者模式的区别❗</h3><ul><li><p><strong>实现方式：</strong>在观察者模式中，观察者（Observer）通常会直接订阅（Subscribe）主题（Subject）的更新，而主题则会在状态改变时直接调用观察者的方法。而在发布订阅模式中，发布者（Publisher）和订阅者（Subscriber）通常不会直接交互，而是<strong>通过一个调度中心（Message broker 或 Event bus）来进行通信。</strong></p></li><li><p><strong>耦合性：</strong>观察者模式中的观察者和主题之间的耦合性相对较高，因为观察者需要直接订阅主题。而在发布订阅模式中，由于引入了调度中心，发布者和订阅者之间的耦合性较低。</p></li><li><p><strong>使用场景：</strong>观察者模式通常用于处理较为简单的一对多依赖关系，例如GUI中的事件处理等。而发布订阅模式则更适合处理复杂的异步处理和跨系统通信等场景，例如消息队列、事件驱动架构等。</p></li></ul><p><strong><code>观察者模式：直接和公司签</code></strong><br><strong><code>订阅者模式：签大厂的外包公司</code></strong></p><h3 id="JS实现发布订阅模式"><a href="#JS实现发布订阅模式" class="headerlink" title="JS实现发布订阅模式"></a>JS实现发布订阅模式</h3><blockquote><p>先列举下需要实现发布-订阅模式的思路，目的呢就是实现三个方法，添加、删除、派发</p></blockquote><p>🐾<strong>第一步：</strong> 实现发布订阅模式的第一步是创建一个可以存储事件及其对应回调函数的容器。在JavaScript中，我们可以使用一个对象来作为这个容器。每个事件都是对象的一个属性，其值是一个数组，用来存储所有订阅了该事件的回调函数。</p><p>🐾<strong>第二步</strong>： 第二步是添加一个名为subscribe的方法，该方法允许监听器订阅特定的事件。这个方法需要两个参数：一个是事件名，另一个是当事件被触发时应该调用的回调函数。</p><p>🐾<strong>第三步：</strong> 第三步是实现取消订阅的功能：添加一个名为unsubscribe的方法来实现这个功能。这个方法需要两个参数：一个是事件名，另一个是要取消订阅的回调函数。</p><p>🐾<strong>第四步：</strong> 第四步是实现事件发布的功能，我们可以添加一个名为publish的方法来实现这个功能。这个方法需要两个参数：一个是事件名，另一个是当事件被触发时应该传递给回调函数的数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PubSub</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span> = &#123;&#125;;<br>  &#125;<br><br>  <span class="hljs-title function_">subscribe</span>(<span class="hljs-params">event, callback</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event]) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event] = [];<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event].<span class="hljs-title function_">push</span>(callback);<br>  &#125;<br><br>  <span class="hljs-title function_">unsubscribe</span>(<span class="hljs-params">event, callback</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event]) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;事件无效&#x27;</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event].<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">cb</span> =&gt;</span> cb !== callback);<br>  &#125;<br><br>  <span class="hljs-title function_">publish</span>(<span class="hljs-params">event, data</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event]) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;该事件未注册&#x27;</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event].<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">callback</span> =&gt;</span> <span class="hljs-title function_">callback</span>(...data));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>🐾使用示例： 至此我们已经完成了一个基本的发布订阅模式，下面展示一下它的具体使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建一个新的PubSub实例</span><br><span class="hljs-keyword">const</span> pubsub = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PubSub</span>();<br><br><span class="hljs-comment">// 定义两个回调函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">callback1</span>(<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;这里是第一个回调: &#x27;</span> + data);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">callback2</span>(<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;这里是第二个回调: &#x27;</span> + data);<br>&#125;<br><br><span class="hljs-comment">// 订阅一个事件</span><br>pubsub.<span class="hljs-title function_">subscribe</span>(<span class="hljs-string">&#x27;myEvent&#x27;</span>, callback1);<br>pubsub.<span class="hljs-title function_">subscribe</span>(<span class="hljs-string">&#x27;myEvent&#x27;</span>, callback2);<br><br><span class="hljs-comment">// 输出两个回调函数的 console</span><br>pubsub.<span class="hljs-title function_">publish</span>(<span class="hljs-string">&#x27;myEvent&#x27;</span>, <span class="hljs-string">&#x27;Hello, world!&#x27;</span>); <br><br><span class="hljs-comment">// 取消订阅 callback1</span><br>pubsub.<span class="hljs-title function_">unsubscribe</span>(<span class="hljs-string">&#x27;myEvent&#x27;</span>, callback1);<br><br><span class="hljs-comment">// callback1 的订阅被取消了，仅打印 callback2 的 console</span><br>pubsub.<span class="hljs-title function_">publish</span>(<span class="hljs-string">&#x27;myEvent&#x27;</span>, <span class="hljs-string">&#x27;Hello, world!&#x27;</span>); <br></code></pre></td></tr></table></figure><h3 id="错误处理与功能优化"><a href="#错误处理与功能优化" class="headerlink" title="错误处理与功能优化"></a>错误处理与功能优化</h3><p>首先是类型判断与错误处理，我们应当检查参数的类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PubSub</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span> = &#123;&#125;;<br>  &#125;<br><br>  <span class="hljs-title function_">subscribe</span>(<span class="hljs-params">event, callback</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> event !== <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Event name must be a string&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Callback must be a function&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event]) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event] = [];<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event].<span class="hljs-title function_">push</span>(callback);<br>  &#125;<br><br>  <span class="hljs-title function_">unsubscribe</span>(<span class="hljs-params">event, callback</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> event !== <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Event name must be a string&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Callback must be a function&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event]) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event].<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">cb</span> =&gt;</span> cb !== callback);<br>  &#125;<br><br>  <span class="hljs-title function_">publish</span>(<span class="hljs-params">event, data</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> event !== <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Event name must be a string&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event]) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event].<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">callback</span> =&gt;</span> <span class="hljs-title function_">callback</span>(data));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>开发中我们会遇到一些一次性事件，不会被触发第二次了，我们可以加一个参数来省去手动清除事件的负担：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">publish</span>(<span class="hljs-params">event, data, once = <span class="hljs-literal">false</span></span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> event !== <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Event name must be a string&#x27;</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event]) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event].<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">callback</span> =&gt;</span> <span class="hljs-title function_">callback</span>(data));<br>  <span class="hljs-keyword">if</span>(once) <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event];<br>&#125;<br></code></pre></td></tr></table></figure><p>如果一个回调函数在被调用时订阅了相同的事件，可能会导致<strong>无限循环</strong>。这是因为<code>publish</code>方法会立即调用所有的回调函数，而这些回调函数可能会改变监听器列表。<br>上面的代码并没有考虑这个问题，但测试后发现并不会发生无限循环的情况，这是什么原因呢？问题出在 for 和 forEach 中，<strong>forEach 方法在开始循环时就已经确定了循环的次数，所以，即使在回调函数中添加或删除了元素，也不会影响forEach的循环次数；</strong>而 <strong>for 循环会实时检查</strong>数组的长度，故而会出现上述的情况。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>强制缓存和协商缓存?</title>
    <link href="/2023/10/07/%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98%E5%92%8C%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98/"/>
    <url>/2023/10/07/%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98%E5%92%8C%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<blockquote><p>原文 <a href="https://juejin.cn/post/7127194919235485733?searchId=2023100709440962FECF52597D2C3CBEA0#heading-4">中高级前端工程师都需要熟悉的技能–前端缓存 - 掘金</a></p></blockquote><p>HTTP 缓存可以分为协商缓存和强制缓存两种类型。</p><blockquote><p>强缓存</p></blockquote><p>强制缓存是指浏览器在请求资源时，不会发送任何请求头，直接从本地缓存中读取资源，从⽽提⾼响应速度,  只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。</p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310171848158.png" alt="img" style="zoom:50%;" /><blockquote><p>协商缓存</p></blockquote><ul><li>协商缓存是指浏览器在请求资源时，会发送⼀些请求头到服务器，询问服务器资源是否已经发⽣改变。如果资源未发⽣改变，服务器将返回 304 状态码，告诉浏览器可以从缓存中读取资源，从⽽减少了⽹络带宽的使⽤。强制缓存失效之后，浏览器在请求头中携带相应的缓存字段来向服务器发请求，由服务器根据这个字段，来决定是否使用缓存，这就是协商缓存。</li></ul><h3 id="1-基于-Expires-字段实现的强缓存"><a href="#1-基于-Expires-字段实现的强缓存" class="headerlink" title="1. 基于 Expires 字段实现的强缓存"></a>1. 基于 Expires 字段实现的强缓存</h3><p>使用响应头的<code>Expires</code>字段去实现强缓存</p><p><code>Expires</code> 头部：指定资源过期的时间，如果在过期时间之前再次请求该资源，浏览器将直接从缓存中读取资源。</p><p>比如说将某一资源设置响应头为:<code>Expires:new Date(&quot;2022-7-30 23:59:59&quot;)</code>；</p><p>那么，该资源在2022-7-30 23:59:59 之前，都会去本地的磁盘（或内存）中读取，不会去服务器请求。</p><blockquote><p>Expires判断强缓存是否过期的机制是: 获取本地时间戳，并对先前拿到的资源文件中的Expires字段的时间做比较, 但是Expires<strong>过度依赖本地时间</strong>，如果本地与服务器时间不同步，就会出现资源无法被缓存或者资源永远被缓存的情况。</p></blockquote><h3 id="2-基于-Cache-control-实现的强缓存"><a href="#2-基于-Cache-control-实现的强缓存" class="headerlink" title="2. 基于 Cache-control 实现的强缓存"></a>2. 基于 Cache-control 实现的强缓存</h3><p><code>Cache-Control</code> 头部：可以指定资源的缓存策略，包括 max-age,  public、private、no-cache 等，控制浏览器的缓存⾏为。</p><p>通过在资源的响应头中设置 <code>Cache-Control:max-age=N</code>，N就是需要缓存的秒数。</p><p>那么,  从第一次请求资源的时候开始，往后N秒内，资源若再次请求，则直接从磁盘（或内存中读取），不与服务器做任何交互。</p><blockquote><p>Cache-control中因为max-age后面的值是一个滑动时间，从服务器第一次返回该资源时开始倒计时。所以也就不需要比对客户端和服务端的时间，解决了Expires所存在的巨大漏洞。</p></blockquote><h3 id="3-基于-lasted-modified-实现的协商缓存"><a href="#3-基于-lasted-modified-实现的协商缓存" class="headerlink" title="3. 基于 lasted-modified 实现的协商缓存"></a>3. 基于 lasted-modified 实现的协商缓存</h3><ol><li>浏览器在第一次请求资源时，在服务器端读出文件修改时间，将读出来的修改时间赋给响应头的<code>last-modified</code>字段。然后设置<code>Cache-control:no-cache(跳过强缓存校验，直接进行协商缓存)</code>. </li><li>当客户端读取到<code>last-modified</code>的时候，会在下次的请求标头中携带一个字段<code>If-Modified-Since(这个请求头中的If-Modified-Since就是上一次请求设置在响应头中的 last-modified)</code>。  </li><li>当再次请求资源时, 服务端需要拿到请求头中的 <code>If-Modified-Since</code> 这个时间并再次读取该资源的修改时间, 让他们两个做一个比对来决定是读取缓存还是返回新的资源。如果没有发生变化，返回 304 状态码并读取缓存，否则返回新的资源并将资源修改时间赋值给响应头的<code>last-modified</code> 字段。</li></ol><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310071059690.png" alt="img"></p><p>使用以上方式的协商缓存存在两个非常明显的漏洞。这两个漏洞都是基于文件是通过比较修改时间来判断是否更改而产生的。</p><ol><li>因为是更具文件修改时间来判断的，所以，在文件内容本身不修改的情况下，依然有可能更新文件修改时间（比如修改文件名再改回来），这样，就有可能文件内容明明没有修改，但是缓存依然失效了。</li><li>当文件在极短时间内完成修改的时候（比如几百毫秒）。因为文件修改时间记录的最小单位是秒，所以，如果文件在几百毫秒内完成修改的话，文件修改时间不会改变，这样，即使文件内容修改了，依然不会返回新的文件。</li></ol><blockquote><p>为了解决上述的这两个问题。从http1.1开始新增了一个头信息，ETag(Entity 实体标签)</p></blockquote><h3 id="4-基于-ETag-实现的协商缓存"><a href="#4-基于-ETag-实现的协商缓存" class="headerlink" title="4. 基于 ETag 实现的协商缓存"></a>4. 基于 ETag 实现的协商缓存</h3><ol><li>第一次请求某资源的时候，服务端读取文件并计算出文件指纹，将文件指纹放在响应头的<code>etag</code>字段中跟资源一起返回给客户端。</li><li>第二次请求某资源的时候，客户端自动从缓存中读取出上一次服务端返回的<code>ETag</code>也就是文件指纹。并赋给请求头的<code>if-None-Match</code>字段，让上一次的文件指纹跟随请求一起回到服务端。</li><li>服务端拿到请求头中的<code>if-None-Match</code>字段值（也就是上一次的文件指纹），并再次读取目标资源并生成文件指纹，两个指纹做对比。如果两个文件指纹完全吻合，说明文件没有被改变，则直接返回304状态码和一个空的响应体并<code>return</code>(这个时候已经读取了缓存)。如果两个文件指纹不吻合，则说明文件被更改，那么返回新的资源并将新的文件指纹重新存储到响应头的<code>ETag</code>字段</li></ol><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310071059655.png" alt="img"></p><blockquote><p> ETag 的缺点</p></blockquote><ol><li>ETag需要计算文件指纹这样意味着，服务端需要更多的计算开销。。如果文件尺寸大，数量多，并且计算频繁，那么ETag的计算就会影响服务器的性能。显然，ETag在这样的场景下就不是很适合。</li><li>ETag有强验证和弱验证，所谓将强验证，ETag生成的哈希码深入到每个字节。哪怕文件中只有一个字节改变了，也会生成不同的哈希值，它可以保证文件内容绝对的不变。但是，强验证非常消耗计算量。ETag还有一个弱验证，弱验证是提取文件的部分属性来生成哈希值。因为不必精确到每个字节，所以他的整体速度会比强验证快，但是准确率不高。会降低协商缓存的有效性。</li></ol><h3 id="5-缓存位置"><a href="#5-缓存位置" class="headerlink" title="5. 缓存位置"></a>5. 缓存位置</h3><p>当强缓存命中或者<code>协商缓存</code>中服务器返回304的时候，我们直接从缓存中获取资源。那这些资源究竟缓存在什么位置呢？</p><p>浏览器中的缓存位置一共有四种，按优先级从高到低排列分别是：</p><ul><li>Service Worker</li><li>Memory Cache</li><li>Disk Cache</li><li>Push Cache</li></ul><blockquote><p>Service Worker</p></blockquote><p>Service Worker 借鉴了 Web Worker的 思路，即让 JS 运行在主线程之外，由于它脱离了浏览器的窗体，因此无法直接访问DOM。虽然如此，但它仍然能帮助我们完成很多有用的功能，比如离线缓存、消息推送和网络代理等功能。其中的离线缓存就是 <strong>Service Worker Cache</strong>。</p><blockquote><p> Memory Cache 和 Disk Cache</p></blockquote><p><strong>Memory Cache</strong>指的是内存缓存，从效率上讲它是最快的。但是从存活时间来讲又是最短的，当渲染进程结束后，内存缓存也就不存在了。</p><p><strong>Disk Cache</strong>就是存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，但是他的优势在于存储容量和存储时长。稍微有些计算机基础的应该很好理解，就不展开了。</p><p>好，现在问题来了，既然两者各有优劣，那浏览器如何决定将资源放进内存还是硬盘呢？主要策略如下：</p><ul><li>比较大的JS、CSS文件会直接被丢进磁盘，反之丢进内存</li><li>内存使用率比较高的时候，文件优先进入磁盘</li></ul><blockquote><p>Push Cache</p></blockquote><p>即推送缓存，这是浏览器缓存的最后一道防线。它是 HTTP&#x2F;2 中的内容，虽然现在应用的并不广泛，但随着 HTTP&#x2F;2 的推广，它的应用越来越广泛。</p><h3 id="6-总结一下"><a href="#6-总结一下" class="headerlink" title="6. 总结一下"></a>6. 总结一下</h3><ul><li>需要注意的是，协商缓存虽然可以减少⽹络带宽的使⽤，但是需要服务器进⾏资源⽐较，会增加服务器的负载</li><li>关于强缓存，cache-control是Expires的完全替代方案，在可以使用cache-control的情况下不要使用expires</li><li>关于协商缓存,etag并不是last-modified的完全替代方案，而是补充方案，具体用哪一个，取决于业务场景。</li><li>有哈希值的文件设置强缓存即可。没有哈希值的文件（比如index.html）设置协商缓存</li><li>有些缓存是从磁盘读取，有些缓存是从内存读取，有什么区别？答：从内存读取的缓存更快。</li><li>所有带304的资源都是协商缓存，所有标注（从内存中读取&#x2F;从磁盘中读取）的资源都是强缓存。</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kmp算法(JS版)</title>
    <link href="/2023/09/30/kmp%E7%AE%97%E6%B3%95(JS%E7%89%88)/"/>
    <url>/2023/09/30/kmp%E7%AE%97%E6%B3%95(JS%E7%89%88)/</url>
    
    <content type="html"><![CDATA[<h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><p>KMP是一种高效的字符串匹配算法，用来在主字符串中查找模式字符串的位置</p><blockquote><p>比如在“hello,world”主串中查找“world”模式串的位置)。</p></blockquote><h5 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h5><blockquote><p>在失配时,  将模板字符串失配字符的下标退回到前面相应位置 ，这样就可以跳过大多数的失配步骤。而每次p串移动的步数就是通过查找next[ ]数组确定的。比如 : </p><p>父亲字符串 :  aabaabaaf</p><p>模板字符串 :  aabaaf</p><p>当模板字符串的<code>f</code>不匹配父字符串的<code>b</code> 时, 模板字符串中字符<code>f</code> 对应的下标<code>j</code>就会退回到包括前5个字符组成的子串的最长相同前后缀的长度, 也就是2, 于是退回到下标为2的位置, 从模板字符串的<code>b</code>字符继续开始和父字符串进行匹配, 至始至终父字符串的匹配下标都未移动哦~</p></blockquote><p><code>KMP</code> 主要分两步：</p><ol><li>求next数组</li><li>匹配字符串</li></ol><h5 id="举例-详解"><a href="#举例-详解" class="headerlink" title="举例 + 详解"></a>举例 + 详解</h5><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309300214173.png" alt="image-20230930021353085"></p><blockquote><p>详解 : 都在注释中了</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> readline = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;readline&quot;</span>);<br><span class="hljs-keyword">const</span> rl = readline.<span class="hljs-title function_">createInterface</span>(&#123;<br>  <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span>,<br>  <span class="hljs-attr">output</span>: process.<span class="hljs-property">stdout</span>,<br>&#125;);<br><span class="hljs-keyword">const</span> num = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">const</span> rows = [];<br>rl.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;line&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)&#123;<br>  rows.<span class="hljs-title function_">push</span>(data);<br>  <span class="hljs-keyword">if</span> (rows.<span class="hljs-property">length</span> == num) &#123;<br>    <span class="hljs-keyword">const</span> res = [];<br>    <span class="hljs-keyword">const</span> n = <span class="hljs-title class_">Number</span>(rows[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">const</span> m = <span class="hljs-title class_">Number</span>(rows[<span class="hljs-number">2</span>]);<br>    <span class="hljs-keyword">const</span> p = rows[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">const</span> s = rows[<span class="hljs-number">3</span>];<br>    <span class="hljs-comment">// 初始化next数组为0, 单个数字是没有前后缀的, 也没有长度</span><br>    <span class="hljs-keyword">const</span> next = [<span class="hljs-number">0</span>]<br>    <span class="hljs-comment">// 求next数组 : next[i]就是包括i之前这个子串最长相等前后缀的长度</span><br>    <span class="hljs-comment">// j代表前缀的末尾位置, 前缀从下标0开始, i代表后缀的末尾位置, 后缀是从下标1开始, 因为单个数字是没有前后缀的</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br> <span class="hljs-comment">// 关于 j &gt; 0 : 因为下标为0时j无法回退到前一个数字的next值, 也就是数组下标-1也有问题, 所以要进行判定</span><br> <span class="hljs-comment">// 关于 while : 因为j的回退也是需要持续进行的, 直到前后缀一致或者j回退到下标为0的位置, 这个地方也是易错点</span><br> <span class="hljs-comment">// 关于 j = next[j - 1] : 当不匹配时, j要回退到前一个数字的next值的位置, 也就是包括i在内的字符串的最长相同前后缀的长度</span><br>      <span class="hljs-keyword">while</span>(j &amp;&amp; p[i] != p[j]) j = next[j - <span class="hljs-number">1</span>];<br>      <span class="hljs-comment">// 当匹配时, j++, 因为j不仅代表前缀末尾的位置, 也代表着包括i之前这个子串的最长相等前后缀的长度, 此时匹配了肯定要加一</span><br>      <span class="hljs-keyword">if</span>(p[i] === p[j])j++; <br>      <span class="hljs-comment">// 因为j代表着包括i之前这个子串的最长相等前后缀的长度, 也就是我们要求的next[i]的值, 最后赋值即可</span><br>      next[i] = j;<br>    &#125;<br>    <span class="hljs-comment">// 进行匹配</span><br>    <span class="hljs-comment">// 都从第一个数开始匹配, 所以下标都从0开始, i为父字符串下标, j为模板字符串下标</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>  <span class="hljs-comment">// 当j为0时, 无需回退且数组也会越界</span><br>  <span class="hljs-comment">// while的作用: 由于移动后可能仍然失配, 所以目的是要保持匹配</span><br>  <span class="hljs-comment">// 当不匹配时, j回退到前一个数字的next值的位置, 继续下一步匹配, 注意这时候i是不变的, 也就是说i一直向后, 只有j是不断回退</span><br>      <span class="hljs-keyword">while</span> (j &amp;&amp; s[i] != p[j]) j = next[j - <span class="hljs-number">1</span>]; <br>      <span class="hljs-comment">// 当匹配成功时, j++</span><br>      <span class="hljs-keyword">if</span> (s[i] == p[j]) j++;<br>      <span class="hljs-comment">// 如果模板字符串已全匹配完, 则匹配完成</span><br>      <span class="hljs-keyword">if</span> (j == n) &#123;<br>        res.<span class="hljs-title function_">push</span>(i - n + <span class="hljs-number">1</span>);<br>        j = next[j - <span class="hljs-number">1</span>];<br>      &#125;<br>      <span class="hljs-comment">// 如果未匹配完成, 则i++, 继续下一个字符的匹配</span><br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27; &#x27;</span>));<br>    rl.<span class="hljs-title function_">close</span>();<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><blockquote><p>over</p></blockquote><blockquote><p>例子2  + 无注释版</p></blockquote><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309301301231.png" alt="image-20230930130110140"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">haystack</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">needle</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> strStr = <span class="hljs-keyword">function</span>(<span class="hljs-params">haystack, needle</span>) &#123;<br>    <span class="hljs-keyword">let</span> next = [<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>, i = <span class="hljs-number">1</span>; i &lt; needle.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">while</span>(j &amp;&amp; needle[i] != needle[j]) j = next[j - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span>(needle[i] === needle[j]) j++;<br>        next[i] = j;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; haystack.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">while</span>(j &amp;&amp; needle[j] !== haystack[i]) j = next[j - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span>(needle[j] === haystack[i]) j++;<br>        <span class="hljs-keyword">if</span>(j === needle.<span class="hljs-property">length</span>) &#123;<br>            <span class="hljs-keyword">return</span> i - j + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手写Promise!!</title>
    <link href="/2023/09/18/%E6%89%8B%E5%86%99Promise/"/>
    <url>/2023/09/18/%E6%89%8B%E5%86%99Promise/</url>
    
    <content type="html"><![CDATA[<blockquote><p>原文 : <a href="https://juejin.cn/post/7269640045043777576">https://juejin.cn/post/7269640045043777576</a></p></blockquote><p>首先，<code>Promise</code>肯定是一个类，所以我们才可以<code>new</code>它，然后<code>Promise实例化</code>的时候给它传入一个回调我们叫它<code>executor</code>方法，Promise 内部会<code>立即调用</code>这个<code>executor方法</code>，并且会传入<code>resolve</code>和<code>reject</code>两个函数作为调用参数，另外在 Promise 类的原型上应该提供一个<code>then</code>方法，它里面可以传入两个回调，分别为<code>Promise成功的回调</code>和<code>Promise失败的回调</code>。调用<code>resolve</code>后会走入<code>成功的回调中</code>，调用<code>reject</code>后会走入<code>失败的回调中</code>。</p><h2 id="初级版本-Promise"><a href="#初级版本-Promise" class="headerlink" title="初级版本 Promise"></a>初级版本 Promise</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PENDING</span> = <span class="hljs-string">&quot;PENDING&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">FULFILLED</span> = <span class="hljs-string">&quot;FULFILLED&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">REJECTED</span> = <span class="hljs-string">&quot;REJECTED&quot;</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Promise</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-literal">undefined</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = <span class="hljs-literal">undefined</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PENDING</span>;<br>    <span class="hljs-comment">// 定义两个数组解决异步调用resolve或者reject的问题</span><br>    <span class="hljs-comment">// 充当队列把then里边的回调存起来</span><br>    <span class="hljs-comment">// 有的时候，我们会给同一个promise实例执行多次then方法, 那么相应的onFulfilled和onRejected回调必须按照其发起调用的顺序执行。</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onResolvedCallbacks</span> = [];<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span> = [];<br><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">resolve</span> = (<span class="hljs-params">value</span>) =&gt; &#123;<br>      <span class="hljs-comment">// 当状态为pending状态的时候才可以去改变状态，并且分别将value和reason赋值给对应值，并去执行相应回调函数</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">FULFILLED</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onResolvedCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> <span class="hljs-title function_">fn</span>());<br>      &#125;<br>    &#125;;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">reject</span> = (<span class="hljs-params">reason</span>) =&gt; &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = reason;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">REJECTED</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> <span class="hljs-title function_">fn</span>());<br>      &#125;<br>    &#125;;<br>      <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-title function_">executor</span>(resolve,reject)<br>      &#125; <span class="hljs-keyword">catch</span>(err) &#123;<br>        <span class="hljs-title function_">reject</span>(err); <span class="hljs-comment">//有报错会直接执行reject函数将状态变为失败rejected</span><br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-title function_">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>) &#123;<br>    <span class="hljs-comment">//当执行到then的时候，状态已经是fulfilled状态或者是rejected状态，那么就直接执行回调，并且将value/reason作为第一个参数</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">FULFILLED</span>) &#123;<br>      onFulfilled &amp;&amp; <span class="hljs-title function_">onFulfilled</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">REJECTED</span>) &#123;<br>      onRejected &amp;&amp; <span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>);<br>    &#125;<br>     <span class="hljs-comment">//当执行到then的时候，状态还是pending状态，那么需要将回调存起来，等到状态改变的时候再去执行</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">onResolvedCallbacks</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">onFulfilled</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>      &#125;);<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>);<br>      &#125;);<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">Promise</span>;<br></code></pre></td></tr></table></figure><h2 id="链式调用-Promise"><a href="#链式调用-Promise" class="headerlink" title="链式调用 Promise"></a>链式调用 Promise</h2><blockquote><p>内部调用 then 方法时，返回了一个新的 promise，并让这个新的 promise 接管了它下一个 then 方法。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PENDING</span> = <span class="hljs-string">&quot;PENDING&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">FULFILLED</span> = <span class="hljs-string">&quot;FULFILLED&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">REJECTED</span> = <span class="hljs-string">&quot;REJECTED&quot;</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Promise</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-literal">undefined</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = <span class="hljs-literal">undefined</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PENDING</span>;<br>    <span class="hljs-comment">// 定义两个数组解决异步调用resovle或者reject的问题</span><br>    <span class="hljs-comment">// 充当队列把then里边的回调存起来</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onResolvedCallbacks</span> = [];<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span> = [];<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">resolve</span> = (<span class="hljs-params">value</span>) =&gt; &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">FULFILLED</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onResolvedCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> <span class="hljs-title function_">fn</span>());<br>      &#125;<br>    &#125;;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">reject</span> = (<span class="hljs-params">reason</span>) =&gt; &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = reason;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">REJECTED</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> <span class="hljs-title function_">fn</span>());<br>      &#125;<br>    &#125;;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-title function_">executor</span>(resolve, reject);<br>    &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>      <span class="hljs-title function_">reject</span>(err); <span class="hljs-comment">//有报错会直接执行reject函数将状态变为失败rejected</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-title function_">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>) &#123;<br>    <span class="hljs-keyword">const</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">FULFILLED</span>) &#123;<br>        <span class="hljs-comment">// onFulfilled方法可能返回值或者promise</span><br>        <span class="hljs-keyword">const</span> x = <span class="hljs-title function_">onFulfilled</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>        <span class="hljs-title function_">resolvePromise</span>(promise2, x, resolve, reject);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">REJECTED</span>) &#123;<br>        <span class="hljs-comment">// onRejected方法可能返回值或者promise</span><br>        <span class="hljs-keyword">const</span> x = <span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>);<br>        <span class="hljs-title function_">resolvePromise</span>(promise2, x, resolve, reject);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onResolvedCallbacks</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-keyword">const</span> x = <span class="hljs-title function_">onFulfilled</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>          <span class="hljs-title function_">resolvePromise</span>(promise2, x, resolve, reject);<br>        &#125;);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-keyword">const</span> x = <span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>);<br>          <span class="hljs-title function_">resolvePromise</span>(promise2, x, resolve, reject);<br>        &#125;);<br>      &#125;<br>    &#125;);<br>    <span class="hljs-keyword">return</span> promise2;<br>  &#125;<br>&#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">Promise</span>;<br></code></pre></td></tr></table></figure><blockquote><p>这里最主要的就是<code>resolvePromise</code>，来看下它做了什么：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">resolvePromise</span>(<span class="hljs-params">promise2, x, resolve, reject</span>) &#123;<br>  <span class="hljs-keyword">if</span> (promise2 === x) &#123;<br>    <span class="hljs-comment">// 防止循环引用</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">reject</span>(<br>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<br>        <span class="hljs-string">&quot;UnhandledPromiseRejectionWarning: TypeError: Chaining cycle detected for promise #&lt;Promise&gt;&quot;</span><br>      )<br>    );<br>  &#125;<br>  <span class="hljs-keyword">let</span> called; <span class="hljs-comment">// 声明变量called，相当于加了一把锁，让promise只能调用一次成功或者失败回调，防止死循环。</span><br>  <span class="hljs-comment">// 判断x的类型 x是对象或函数才有可能是一个promise</span><br>  <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&quot;object&quot;</span> &amp;&amp; x !== <span class="hljs-literal">null</span>) || <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">const</span> then = x.<span class="hljs-property">then</span>;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>        <span class="hljs-comment">// 只能认为它是一个promise</span><br>        then.<span class="hljs-title function_">call</span>(<br>          x,<br>          <span class="hljs-function">(<span class="hljs-params">y</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span>;<br>            called = <span class="hljs-literal">true</span>;<br>            <span class="hljs-title function_">resolvePromise</span>(promise2, y, resolve, reject); <span class="hljs-comment">// 精髓, 递归解析</span><br>          &#125;,<br>          <span class="hljs-function">(<span class="hljs-params">r</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span>;<br>            called = <span class="hljs-literal">true</span>;<br>            <span class="hljs-title function_">reject</span>(r);<br>          &#125;<br>        );<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(x);<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>      <span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span>;<br>      called = <span class="hljs-literal">true</span>;<br>      <span class="hljs-title function_">reject</span>(e);<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(x);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>因为<code>promise</code>在<code>EventLoop</code>里面是个微任务，不过我们可以简单通过<code>setTimout</code>模拟。</p><p>然后我们再加上一些报错的捕获代码以及一些参数的兼容代码，以及实现<code>catch</code>方法。</p></blockquote><h2 id="完全版本-Promise"><a href="#完全版本-Promise" class="headerlink" title="完全版本 Promise"></a>完全版本 Promise</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PENDING</span> = <span class="hljs-string">&quot;PENDING&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">FULFILLED</span> = <span class="hljs-string">&quot;FULFILLED&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">REJECTED</span> = <span class="hljs-string">&quot;REJECTED&quot;</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Promise</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-literal">undefined</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = <span class="hljs-literal">undefined</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PENDING</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onResolvedCallbacks</span> = [];<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span> = [];<br><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">resolve</span> = (<span class="hljs-params">value</span>) =&gt; &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">FULFILLED</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onResolvedCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> <span class="hljs-title function_">fn</span>());<br>      &#125;<br>    &#125;;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">reject</span> = (<span class="hljs-params">reason</span>) =&gt; &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = reason;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">REJECTED</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> <span class="hljs-title function_">fn</span>());<br>      &#125;<br>    &#125;;<br><br>    <span class="hljs-comment">// executor执行时增加try catch，防止执行用户传入的函数直接就报错了，这时我们应该直接reject promise。</span><br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-title function_">executor</span>(resolve, reject);<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>      <span class="hljs-title function_">reject</span>(e);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-title function_">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>) &#123;<br>    <span class="hljs-comment">// 这里兼容下 onFulfilled 和 onRejected 的传参</span><br>    onFulfilled = <span class="hljs-keyword">typeof</span> onFulfilled === <span class="hljs-string">&quot;function&quot;</span> ? onFulfilled : <span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> v;<br>    onRejected =<br>      <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">&quot;function&quot;</span><br>        ? onRejected<br>        : <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">throw</span> err;<br>          &#125;;<br>    <span class="hljs-comment">// 调用onFulfilled和onRejected时，需要包裹setTimeout</span><br>    <span class="hljs-keyword">const</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">FULFILLED</span>) &#123;<br>        <span class="hljs-comment">// 用 setTimeout 模拟异步</span><br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">const</span> x = <span class="hljs-title function_">onFulfilled</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>            <span class="hljs-title function_">resolvePromise</span>(promise2, x, resolve, reject);<br>          &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>            <span class="hljs-title function_">reject</span>(e);<br>          &#125;<br>        &#125;, <span class="hljs-number">0</span>);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">REJECTED</span>) &#123;<br>        <span class="hljs-comment">// 用 setTimeout 模拟异步</span><br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">const</span> x = <span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>);<br>            <span class="hljs-title function_">resolvePromise</span>(promise2, x, resolve, reject);<br>          &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>            <span class="hljs-title function_">reject</span>(e);<br>          &#125;<br>        &#125;, <span class="hljs-number">0</span>);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onResolvedCallbacks</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-comment">// 用 setTimeout 模拟异步</span><br>          <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>              <span class="hljs-keyword">const</span> x = <span class="hljs-title function_">onFulfilled</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>              <span class="hljs-title function_">resolvePromise</span>(promise2, x, resolve, reject);<br>            &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>              <span class="hljs-title function_">reject</span>(e);<br>            &#125;<br>          &#125;, <span class="hljs-number">0</span>);<br>        &#125;);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-comment">// 用 setTimeout 模拟异步</span><br>          <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>              <span class="hljs-keyword">const</span> x = <span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>);<br>              <span class="hljs-title function_">resolvePromise</span>(promise2, x, resolve, reject);<br>            &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>              <span class="hljs-title function_">reject</span>(e);<br>            &#125;<br>          &#125;, <span class="hljs-number">0</span>);<br>        &#125;);<br>      &#125;<br>    &#125;);<br><br>    <span class="hljs-keyword">return</span> promise2;<br>  &#125;<br>  <span class="hljs-comment">// catch函数实际上里面就是调用了then方法</span><br>  <span class="hljs-keyword">catch</span>(errCallback) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-literal">null</span>, errCallback);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 解决链式调用</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">resolvePromise</span>(<span class="hljs-params">promise2, x, resolve, reject</span>) &#123;<br>  <span class="hljs-keyword">if</span> (promise2 === x) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">reject</span>(<br>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<br>        <span class="hljs-string">&quot;UnhandledPromiseRejectionWarning: TypeError: Chaining cycle detected for promise #&lt;Promise&gt;&quot;</span><br>      )<br>    );<br>  &#125;<br>  <span class="hljs-keyword">let</span> called;<br>  <span class="hljs-comment">// 判断x的类型 x是对象或函数才有可能是一个promise</span><br>  <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&quot;object&quot;</span> &amp;&amp; x !== <span class="hljs-literal">null</span>) || <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">const</span> then = x.<span class="hljs-property">then</span>;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>        <span class="hljs-comment">// 只能认为它是一个promise</span><br>        then.<span class="hljs-title function_">call</span>(<br>          x,<br>          <span class="hljs-function">(<span class="hljs-params">y</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span>;<br>            called = <span class="hljs-literal">true</span>;<br>            <span class="hljs-title function_">resolvePromise</span>(promise2, y, resolve, reject);<br>          &#125;,<br>          <span class="hljs-function">(<span class="hljs-params">r</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span>;<br>            called = <span class="hljs-literal">true</span>;<br>            <span class="hljs-title function_">reject</span>(r);<br>          &#125;<br>        );<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(x);<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>      <span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span>;<br>      called = <span class="hljs-literal">true</span>;<br>      <span class="hljs-title function_">reject</span>(e);<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(x);<br>  &#125;<br>&#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">Promise</span>;<br></code></pre></td></tr></table></figure><h2 id="测试-promise-是否符合规范"><a href="#测试-promise-是否符合规范" class="headerlink" title="测试 promise 是否符合规范"></a>测试 promise 是否符合规范</h2><ol><li><p>首先安装依赖包 <code>npm i promises-aplus-tests -D</code></p></li><li><p>在我们的代码中添加</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">defer</span> = <span class="hljs-title class_">Promise</span>.<span class="hljs-property">deferred</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">let</span> dfd = &#123;&#125;;<br>  dfd.<span class="hljs-property">promise</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>      dfd.<span class="hljs-property">resolve</span> = resolve;<br>      dfd.<span class="hljs-property">reject</span> = reject;<br>  &#125;);<br>  <span class="hljs-keyword">return</span> dfd;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意别忘了 <code>module.exports = Promise;</code></p></blockquote></li><li><p>运行 <code>promises-aplus-tests 文件名</code> 即可</p></li><li><p>有 872 个测试用例，全部通过即可以认为这是一个标准的 promise。</p></li></ol><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309181510458.png" alt="image-20230918151029374"></p><h2 id="实现Promise的各种方法"><a href="#实现Promise的各种方法" class="headerlink" title="实现Promise的各种方法"></a>实现Promise的各种方法</h2><blockquote><p>Promise 的实例方法有 then&#x2F;catch&#x2F;finally 三种，静态方法有 all&#x2F;race&#x2F;allSettled&#x2F;any&#x2F;resolve&#x2F;reject 六种</p><p>then 和 catch 上面已经实现过了</p></blockquote><h3 id="实现-Promise-resolve"><a href="#实现-Promise-resolve" class="headerlink" title="实现 Promise.resolve"></a>实现 Promise.resolve</h3><p>实现 resolve 静态方法有三个要点:</p><ol><li>传参为一个 Promise, 则直接返回它。</li><li>传参为一个 thenable 对象，返回的 Promise 会跟随这个对象，采用它的最终状态作为自己的状态。</li><li>其他情况，直接返回以该值为成功状态的promise对象。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">resolve</span> = <span class="hljs-function">(<span class="hljs-params">param</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span>(param <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) <span class="hljs-keyword">return</span> param;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span>(param &amp;&amp; param.<span class="hljs-property">then</span> &amp;&amp; <span class="hljs-keyword">typeof</span> param.<span class="hljs-property">then</span> === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>      <span class="hljs-comment">// param 状态变为成功会调用resolve，将新 Promise 的状态变为成功，反之亦然</span><br>      param.<span class="hljs-title function_">then</span>(resolve, reject);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_">resolve</span>(param);<br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现-Promise-reject"><a href="#实现-Promise-reject" class="headerlink" title="实现 Promise.reject"></a>实现 Promise.reject</h3><p>Promise.reject 中传入的参数会作为一个 reason 原封不动地往下传, 实现如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">reject</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">reason</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-title function_">reject</span>(reason);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="实现-Promise-prototype-finally"><a href="#实现-Promise-prototype-finally" class="headerlink" title="实现 Promise.prototype.finally"></a>实现 Promise.prototype.finally</h3><p>无论当前 Promise 是成功还是失败，调用finally之后都会执行 finally 中传入的函数，并且将值原封不动的往下传。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">finally</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">callback</span>()).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> value;<br>    &#125;)<br>  &#125;, <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">callback</span>()).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">throw</span> error;<br>    &#125;)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h3 id="实现-Promise-all"><a href="#实现-Promise-all" class="headerlink" title="实现 Promise.all"></a>实现 Promise.all</h3><p>对于 <code>all</code> 方法而言，需要完成下面的核心功能:</p><ol><li>传入参数为一个空的可迭代对象，则直接进行<code>resolve</code>。</li><li>如果参数中有一个<code>promise</code>失败，那么<code>Promise.all</code>返回的<code>promise</code>对象失败。</li><li>在任何情况下，<code>Promise.all</code> 返回的 <code>promise</code> 的完成状态的结果都是一个数组</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">all</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">promises</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> result = [];<br>    <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> len = promises.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">if</span>(len === <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-title function_">resolve</span>(result);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>   <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>      <span class="hljs-comment">// 为什么不直接 promise[i].then, 因为promise[i]可能不是一个promise</span><br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(promise[i]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>        result[i] = data;<br>        index++;<br>        <span class="hljs-keyword">if</span>(index === len) <span class="hljs-title function_">resolve</span>(result);<br>      &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>        <span class="hljs-title function_">reject</span>(err);<br>      &#125;)<br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><h3 id="实现-Promise-allSettled"><a href="#实现-Promise-allSettled" class="headerlink" title="实现 Promise.allSettled"></a>实现 Promise.allSettled</h3><p>Promise.allSettled() 方法只有等到参数数组的所有 Promise 实例都发生状态变更，返回的 Promise 实例才会发生状态变更，无论是执行 resolve 回调还是 reject 回调的状态。<br>打个比方：多名员工分别同时进行多个项目，你要求每个一个项目都必须完成，然后得到所有项目是令你满意还是令你不满意的。强调的是最终结果。</p><p>同时因为 Promise.allSettled() 和 Promise.all() 都是对所有 Promise 实例的一种处理，下面就可以利用 Promise.all() 来实现 Promise.allSettled() 方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">MyPromise</span>.<span class="hljs-property">allSettled</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">promises</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(<br>    promises.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span><br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(item).<span class="hljs-title function_">then</span>(<br>        <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> (&#123; <span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;fulfilled&#x27;</span>, value &#125;),<br>        <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> (&#123; <span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;rejected&#x27;</span>, reason &#125;)<br>      )<br>    )<br>  );<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="实现-Promise-race"><a href="#实现-Promise-race" class="headerlink" title="实现 Promise.race"></a>实现 Promise.race</h3><p><code>race</code> 的实现相比之下就简单一些，只要有一个 <code>promise</code> 执行完，直接 <code>resolve</code> 并停止执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">race</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">promises</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span>(promises.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-title function_">resolve</span>();<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">let</span> len = promises.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">if</span>(len === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(promise[i]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(data);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>        <span class="hljs-title function_">reject</span>(err);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;)<br>    &#125;<br>   &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现-Promise-any"><a href="#实现-Promise-any" class="headerlink" title="实现 Promise.any"></a>实现 Promise.any</h3><p>Promise.any() 方法是返回任意一个最快执行 resolve 回调的 Promise 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">MyPromise</span>.<span class="hljs-property">any</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">promises</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (promises.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">resolve</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">let</span> result = [];<br>      <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; promises.<span class="hljs-property">length</span>; i++) &#123;<br>        promises[i].<span class="hljs-title function_">then</span>(<br>          <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-title function_">resolve</span>(value);<br>          &#125;,<br>          <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;<br>            result[i] = reason;<br>            <span class="hljs-comment">// 如果所有都失败则返回失败</span><br>            <span class="hljs-keyword">if</span> (++index === promises.<span class="hljs-property">length</span>) &#123;<br>              <span class="hljs-keyword">return</span> <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AggregateError</span>(result));<br>            &#125;<br>          &#125;<br>        );<br>      &#125;<br>    &#125;<br>  &#125;);<br>&#125;;<br><br></code></pre></td></tr></table></figure><blockquote><p>over</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手写函数汇总</title>
    <link href="/2023/09/15/%E6%89%8B%E5%86%99%E5%87%BD%E6%95%B0/"/>
    <url>/2023/09/15/%E6%89%8B%E5%86%99%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="JavaScript-基础"><a href="#JavaScript-基础" class="headerlink" title="JavaScript 基础"></a>JavaScript 基础</h2><h3 id="1-手写-Object-create"><a href="#1-手写-Object-create" class="headerlink" title="1. 手写 Object.create"></a>1. 手写 Object.create</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">create</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"></span>) &#123;&#125;<br>  F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = obj<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-手写-instanceof-方法"><a href="#2-手写-instanceof-方法" class="headerlink" title="2.  手写 instanceof 方法"></a>2.  手写 instanceof 方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myInstanceof</span>(<span class="hljs-params">left, right</span>) &#123;<br>  <span class="hljs-keyword">let</span> proto = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(left),<br>  prototype = right.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <br> <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!proto) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (proto === prototype) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    proto = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(proto);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-手写-new-操作符"><a href="#3-手写-new-操作符" class="headerlink" title="3. 手写 new 操作符"></a>3. 手写 new 操作符</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">newOperator</span>(<span class="hljs-params">ctor, ...args</span>) &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> ctor !== <span class="hljs-string">&#x27;function&#x27;</span>)&#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;newOperator function the first param must be a function&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">let</span> obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(ctor.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br>    <span class="hljs-keyword">let</span> res = ctor.<span class="hljs-title function_">apply</span>(obj, args);<br><br>    <span class="hljs-comment">// 如果构造函数的返回值 res 是一个对象或函数，则直接返回它。否则，返回新创建的对象 obj</span><br>    <span class="hljs-keyword">let</span> isObject = (<span class="hljs-keyword">typeof</span> res === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; res !== <span class="hljs-literal">null</span>);<br>    <span class="hljs-keyword">let</span> isFunction = (<span class="hljs-keyword">typeof</span> res === <span class="hljs-string">&#x27;function&#x27;</span>);<br>    <span class="hljs-keyword">return</span> (isObect || isFunction ) ? res : obj;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="4-手写-Promise-简洁版"><a href="#4-手写-Promise-简洁版" class="headerlink" title="4. 手写 Promise (简洁版)"></a>4. 手写 Promise (简洁版)</h3><p>详细的可看自己的博客 , 这里未实现链式调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PENDING</span> = <span class="hljs-string">&quot;PENDING&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">FULFILLED</span> = <span class="hljs-string">&quot;FULFILLED&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">REJECTED</span> = <span class="hljs-string">&quot;REJECTED&quot;</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Promise</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-literal">undefined</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = <span class="hljs-literal">undefined</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PENDING</span>;<br>    <span class="hljs-comment">// 定义两个数组解决异步调用resolve或者reject的问题</span><br>    <span class="hljs-comment">// 充当队列把then里边的回调存起来</span><br>    <span class="hljs-comment">// 有的时候，我们会给同一个promise实例执行多次then方法, 那么相应的onFulfilled和onRejected回调必须按照其发起调用的顺序执行。</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onResolvedCallbacks</span> = [];<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span> = [];<br><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">resolve</span> = (<span class="hljs-params">value</span>) =&gt; &#123;<br>      <span class="hljs-comment">// 当状态为pending状态的时候才可以去改变状态，并且分别将value和reason赋值给对应值，并去执行相应回调函数</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">FULFILLED</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onResolvedCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> <span class="hljs-title function_">fn</span>());<br>      &#125;<br>    &#125;;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">reject</span> = (<span class="hljs-params">reason</span>) =&gt; &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = reason;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">REJECTED</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> <span class="hljs-title function_">fn</span>());<br>      &#125;<br>    &#125;;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-title function_">executor</span>(resolve, reject);<br>    &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>      <span class="hljs-title function_">reject</span>(err); <span class="hljs-comment">//有报错会直接执行reject函数将状态变为失败rejected</span><br>    &#125;<br>  &#125;<br><br>  <span class="hljs-title function_">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>) &#123;<br>    <span class="hljs-comment">//当执行到then的时候，状态已经是fulfilled状态或者是rejected状态，那么就直接执行回调，并且将value/reason作为第一个参数</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">FULFILLED</span>) &#123;<br>      onFulfilled &amp;&amp; <span class="hljs-title function_">onFulfilled</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">REJECTED</span>) &#123;<br>      onRejected &amp;&amp; <span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>);<br>    &#125;<br>    <span class="hljs-comment">//当执行到then的时候，状态还是pending状态，那么需要将回调存起来，等到状态改变的时候再去执行</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">onResolvedCallbacks</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">onFulfilled</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>      &#125;);<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>);<br>      &#125;);<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">Promise</span>;<br></code></pre></td></tr></table></figure><h3 id="5-手写-Promise-的各种方法"><a href="#5-手写-Promise-的各种方法" class="headerlink" title="5. 手写 Promise 的各种方法"></a>5. 手写 Promise 的各种方法</h3><p>Promise 的实例方法有 then&#x2F;catch&#x2F;finally 三种，静态方法有 all&#x2F;race&#x2F;allSettled&#x2F;any&#x2F;resolve&#x2F;reject 六种</p><h4 id="5-1-手写-Promise-resolve"><a href="#5-1-手写-Promise-resolve" class="headerlink" title="5.1. 手写 Promise.resolve"></a>5.1. 手写 Promise.resolve</h4><p>以下几种关于 Promise 各种方法实现的具体细节可看<a href="https://www.yuque.com/zweirdo/zxyob8/kg4i04ywgxe469w1#JKyuC">JavaScript八股</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">resolve</span> = <span class="hljs-function">(<span class="hljs-params">param</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span>(param <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) <span class="hljs-keyword">return</span> param;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span>(param &amp;&amp; param.<span class="hljs-property">then</span> &amp;&amp; <span class="hljs-keyword">typeof</span> param.<span class="hljs-property">then</span> === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>      <span class="hljs-comment">// param 状态变为成功会调用resolve，将新 Promise 的状态变为成功，反之亦然</span><br>      param.<span class="hljs-title function_">then</span>(resolve, reject);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_">resolve</span>(param);<br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-2-手写-Promise-reject"><a href="#5-2-手写-Promise-reject" class="headerlink" title="5.2. 手写 Promise.reject"></a>5.2. 手写 Promise.reject</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">reject</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">reason</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-title function_">reject</span>(reason);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-3-手写-Promise-prototype-finally"><a href="#5-3-手写-Promise-prototype-finally" class="headerlink" title="5.3. 手写 Promise.prototype.finally"></a>5.3. 手写 Promise.prototype.finally</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">finally</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">callback</span>()).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> value;<br>    &#125;)<br>  &#125;, <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">callback</span>()).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">throw</span> error;<br>    &#125;)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-4-手写-Promise-all"><a href="#5-4-手写-Promise-all" class="headerlink" title="5.4. 手写 Promise.all"></a>5.4. 手写 Promise.all</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">all</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">promises</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(promises)) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">`promises must be a array`</span>)<br>    <span class="hljs-keyword">let</span> result = [];<br>    <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> len = promises.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">if</span>(len === <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-title function_">resolve</span>(result);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>   <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>      <span class="hljs-comment">// 为什么不直接 promise[i].then, 因为promise[i]可能不是一个promise</span><br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(promise[i]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>        result[i] = data;<br>        index++;<br>        <span class="hljs-keyword">if</span>(index === len) <span class="hljs-title function_">resolve</span>(result);<br>      &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>        <span class="hljs-title function_">reject</span>(err);<br>      &#125;)<br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-5-手写-Promise-allSettled"><a href="#5-5-手写-Promise-allSettled" class="headerlink" title="5.5. 手写 Promise.allSettled"></a>5.5. 手写 Promise.allSettled</h4><p>因为 Promise.allSettled() 和 Promise.all() 都是对<strong>所有 Promise 实例</strong>的一种处理，下面就可以利用 Promise.all() 来实现 Promise.allSettled() 方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">MyPromise</span>.<span class="hljs-property">allSettled</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">promises</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(<br>    promises.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span><br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(item).<span class="hljs-title function_">then</span>(<br>        <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> (&#123; <span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;fulfilled&#x27;</span>, value &#125;),<br>        <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> (&#123; <span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;rejected&#x27;</span>, reason &#125;)<br>      )<br>    )<br>  );<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="5-6-手写-Promise-race"><a href="#5-6-手写-Promise-race" class="headerlink" title="5.6. 手写 Promise.race"></a>5.6. 手写 Promise.race</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">race</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">promises</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> len = promises.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">if</span>(len === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(promise[i]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(data);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>        <span class="hljs-title function_">reject</span>(err);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;)<br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-手写防抖函数"><a href="#6-手写防抖函数" class="headerlink" title="6. 手写防抖函数"></a>6. 手写防抖函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn, delay</span>) &#123;<br>  <span class="hljs-keyword">let</span> timer;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>    timer &amp;&amp; <span class="hljs-built_in">clearTimeout</span>(timer);<br>    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>    &#125;, delay);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-手写节流函数"><a href="#7-手写节流函数" class="headerlink" title="7. 手写节流函数"></a>7. 手写节流函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 定时器版本</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn, delay</span>) &#123;<br>  <span class="hljs-keyword">let</span> timer;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!timer) &#123;<br>      timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>        timer = <span class="hljs-literal">null</span>;<br>      &#125;, delay);<br>    &#125;<br>  &#125;;<br>&#125;<br><br><span class="hljs-comment">// 时间戳版本</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">throole</span>(<span class="hljs-params">fn, delay</span>) &#123;<br>  <span class="hljs-keyword">let</span> st = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-keyword">let</span> now = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>    <span class="hljs-keyword">if</span> (delay - (now - st) &lt;= <span class="hljs-number">0</span>) &#123;<br>      fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>      st = now;<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-手写类型判断函数"><a href="#8-手写类型判断函数" class="headerlink" title="8. 手写类型判断函数"></a>8. 手写类型判断函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getType</span>(<span class="hljs-params">value</span>) &#123;<br>  <span class="hljs-comment">// 判断数据是 null 的情况</span><br>  <span class="hljs-keyword">if</span> (value === <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">return</span> value + <span class="hljs-string">&quot;&quot;</span>;<br>  &#125;<br>  <span class="hljs-comment">// 判断数据是引用类型的情况</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&quot;object&quot;</span>) &#123;<br>    <span class="hljs-keyword">let</span> valueClass = <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(value), <span class="hljs-comment">// 重点</span><br>    type = valueClass.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot; &quot;</span>)[<span class="hljs-number">1</span>].<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    type.<span class="hljs-title function_">pop</span>();<br>    <span class="hljs-keyword">return</span> type.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">toLowerCase</span>();<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 判断数据是基本数据类型的情况和函数的情况</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> value;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-手写-call-函数"><a href="#9-手写-call-函数" class="headerlink" title="9. 手写 call 函数"></a>9. 手写 call 函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 给函数对象添加方法: mycall</span><br><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">mycall</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">thisArg, ...otherArgs</span>) &#123;<br>    <span class="hljs-comment">// this -&gt; 调用的函数对象</span><br>    <span class="hljs-comment">// thisArg -&gt; 传入的第一个参数, 要绑定的this</span><br>    <span class="hljs-comment">// console.log(this) // -&gt; 当前调用的函数对象</span><br><br>    <span class="hljs-comment">// 判断调用对象</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&quot;function&quot;</span>)  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;Error&quot;</span>);<br><br>    <span class="hljs-comment">// 获取thisArg, 并且确保是一个对象类型</span><br>    thisArg = (thisArg === <span class="hljs-literal">null</span> || thisArg === <span class="hljs-literal">undefined</span>)? <span class="hljs-attr">window</span>: <span class="hljs-title class_">Object</span>(thisArg)<br><br>    <span class="hljs-keyword">const</span> fnKey = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;fn&#x27;</span>);<br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(thisArg, fnKey, &#123;<br>        <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 不可枚举</span><br>        <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">value</span>: <span class="hljs-variable language_">this</span><br>    &#125;)<br>    thisArg[fnKey](...otherArgs) <span class="hljs-comment">// 通过thisArg调用方法, 相当于改变了this指向</span><br><br>    <span class="hljs-keyword">delete</span> thisArg[fnKey] <span class="hljs-comment">// 最后要删除</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-手写-apply-函数"><a href="#10-手写-apply-函数" class="headerlink" title="10. 手写 apply 函数"></a>10. 手写 apply 函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hyapply</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">thisArg, otherArgs</span>) &#123;<br><br>  <span class="hljs-comment">// 判断调用对象</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&quot;function&quot;</span>)  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;Error&quot;</span>);<br><br>  <span class="hljs-comment">// 获取thisArg, 并且确保是一个对象类型</span><br>  thisArg = (thisArg === <span class="hljs-literal">null</span> || thisArg === <span class="hljs-literal">undefined</span>)? <span class="hljs-attr">window</span>: <span class="hljs-title class_">Object</span>(thisArg)<br>  <span class="hljs-comment">// 上方的window可以改成globalThis更严谨</span><br><br>  <span class="hljs-keyword">const</span> fnKey = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;fn&#x27;</span>); <span class="hljs-comment">// 防止篡改thisArg原有的属性</span><br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(thisArg, fnKey, &#123;  <br>    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">value</span>: <span class="hljs-variable language_">this</span>    <span class="hljs-comment">// this指向调用者</span><br>  &#125;)<br>  thisArg[fnKey](...otherArgs)   <span class="hljs-comment">// 和call的区别就是后面的参数是数组形式</span><br>  <span class="hljs-keyword">delete</span> thisArg[fnKey];  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="11-手写-bind-函数"><a href="#11-手写-bind-函数" class="headerlink" title="11. 手写 bind 函数"></a>11. 手写 bind 函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hybind</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">thisArg, ...otherArgs</span>) &#123;<br><br>  <span class="hljs-comment">// 判断调用对象</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&quot;function&quot;</span>)  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;Error&quot;</span>);<br><br>  thisArg = thisArg === <span class="hljs-literal">null</span> || thisArg === <span class="hljs-literal">undefined</span> ? <span class="hljs-attr">window</span>: <span class="hljs-title class_">Object</span>(thisArg)<br>  <span class="hljs-keyword">const</span> fnKey = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;fn&#x27;</span>); <span class="hljs-comment">// 防止篡改thisArg原有的属性</span><br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(thisArg, fnKey, &#123;<br>    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">value</span>: <span class="hljs-variable language_">this</span><br>  &#125;)<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...newArgs</span>) =&gt;</span> &#123;  <span class="hljs-comment">// 返回一个函数拿去调用</span><br>    <span class="hljs-keyword">var</span> allArgs = [...otherArgs, ...newArgs]  <span class="hljs-comment">// 可能还会传参数</span><br>    thisArg[fnKey](...allArgs)<br>    <span class="hljs-comment">// 因为下次调用还会使用这个fnKey , 所以不要删除</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="12-手写柯里化函数"><a href="#12-手写柯里化函数" class="headerlink" title="12. 手写柯里化函数"></a>12. 手写柯里化函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a,b,c</span>)&#123;<br>  <span class="hljs-keyword">return</span> a+b+c;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">curring</span>(<span class="hljs-params">fn</span>)&#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">cur</span>(<span class="hljs-params">...args</span>)&#123;<br>    <span class="hljs-keyword">if</span>(args.<span class="hljs-property">length</span>&gt;=fn.<span class="hljs-property">length</span>)&#123;<br>      <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>,args);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...newargs</span>)&#123;<br>        <span class="hljs-keyword">return</span> cur.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>,args.<span class="hljs-title function_">concat</span>(newargs));<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> cur;<br>&#125;<br><span class="hljs-keyword">let</span> add=<span class="hljs-title function_">curring</span>(foo);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)); <span class="hljs-comment">// 6</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)); <span class="hljs-comment">// 6</span><br></code></pre></td></tr></table></figure><h3 id="13-实现AJAX请求"><a href="#13-实现AJAX请求" class="headerlink" title="13. 实现AJAX请求"></a>13. 实现AJAX请求</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">SERVER_URL</span> = <span class="hljs-string">&quot;/server&quot;</span>;<br><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br><span class="hljs-comment">// 创建 Http 请求</span><br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-variable constant_">SERVER_URL</span>, <span class="hljs-literal">true</span>);<br><span class="hljs-comment">// 设置状态监听函数</span><br>xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">readyState</span> !== <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-comment">// 当请求成功时</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>    <span class="hljs-title function_">handle</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">response</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>);<br>  &#125;<br>&#125;;<br><span class="hljs-comment">// 设置请求失败时的监听函数</span><br>xhr.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>);<br>&#125;;<br><span class="hljs-comment">// 设置请求头信息</span><br>xhr.<span class="hljs-property">responseType</span> = <span class="hljs-string">&quot;json&quot;</span>;<br>xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>);<br><span class="hljs-comment">// 发送 Http 请求</span><br>xhr.<span class="hljs-title function_">send</span>(<span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure><h3 id="14-使用Promise封装AJAX请求"><a href="#14-使用Promise封装AJAX请求" class="headerlink" title="14. 使用Promise封装AJAX请求"></a>14. 使用Promise封装AJAX请求</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getJSON</span>(<span class="hljs-params">url</span>) &#123;<br>  <span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>    xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, url, <span class="hljs-literal">true</span>);<br>    xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">readyState</span> !== <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span>;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">response</span>);  <span class="hljs-comment">// 注意</span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>));<br>      &#125;<br>    &#125;;<br>    xhr.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>));<br>    &#125;;<br>    xhr.<span class="hljs-property">responseType</span> = <span class="hljs-string">&quot;json&quot;</span>;<br>    xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>);<br>    xhr.<span class="hljs-title function_">send</span>(<span class="hljs-literal">null</span>);<br>  &#125;);<br>  <span class="hljs-keyword">return</span> promise;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="15-浅拷贝的各种实现方法"><a href="#15-浅拷贝的各种实现方法" class="headerlink" title="15. 浅拷贝的各种实现方法"></a>15. 浅拷贝的各种实现方法</h3><p>手写浅拷贝</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">shallowClone</span> = (<span class="hljs-params">target</span>) =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> target === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; target !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">const</span> cloneTarget = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(target) ? []: &#123;&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> prop <span class="hljs-keyword">in</span> target) &#123;<br>      <span class="hljs-keyword">if</span> (target.<span class="hljs-title function_">hasOwnProperty</span>(prop)) &#123;<br>          cloneTarget[prop] = target[prop];<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cloneTarget;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> target;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Object.assign</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;sy&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span> &#125;;<br><span class="hljs-keyword">const</span> obj2 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, obj, &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;sss&#x27;</span>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2);<span class="hljs-comment">//&#123; name: &#x27;sss&#x27;, age: 18 &#125;</span><br></code></pre></td></tr></table></figure><p>数组方法 concat </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> newArr = arr.<span class="hljs-title function_">concat</span>();<br>newArr[<span class="hljs-number">1</span>] = <span class="hljs-number">100</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<span class="hljs-comment">//[ 1, 2, 3 ]</span><br></code></pre></td></tr></table></figure><p>数组方法 slice</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> newArr = arr.<span class="hljs-title function_">slice</span>();<br>newArr[<span class="hljs-number">0</span>] = <span class="hljs-number">100</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<span class="hljs-comment">//[1, 2, 3]</span><br></code></pre></td></tr></table></figure><p>…展开运算符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> newArr = [...arr];<span class="hljs-comment">//跟arr.slice()是一样的效果</span><br></code></pre></td></tr></table></figure><h3 id="16-深拷贝的实现方法"><a href="#16-深拷贝的实现方法" class="headerlink" title="16. 深拷贝的实现方法"></a>16. 深拷贝的实现方法</h3><p>JSON.parse(JSON.stringify(obj))</p><p>它的原理就是利用JSON.stringify 将js对象序列化（JSON字符串），再使用JSON.parse来反序列化(还原)js对象。这时候两个对象的引用就不相同了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj1 = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">b</span>: &#123;<span class="hljs-attr">c</span>: <span class="hljs-number">0</span>&#125; &#125;;<br><span class="hljs-keyword">let</span> obj2 = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj1));<br>obj1.<span class="hljs-property">a</span> = <span class="hljs-number">1</span>;<br>obj1.<span class="hljs-property">b</span>.<span class="hljs-property">c</span> = <span class="hljs-number">1</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1); <span class="hljs-comment">// &#123;a: 1, b: &#123;c: 1&#125;&#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2); <span class="hljs-comment">// &#123;a: 0, b: &#123;c: 0&#125;&#125;</span><br></code></pre></td></tr></table></figure><p>函数库lodash的_.cloneDeep方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> _ = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;lodash&#x27;</span>);<br><span class="hljs-keyword">var</span> obj1 = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">b</span>: &#123; <span class="hljs-attr">f</span>: &#123; <span class="hljs-attr">g</span>: <span class="hljs-number">1</span> &#125; &#125;,<br>    <span class="hljs-attr">c</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>&#125;;<br><span class="hljs-keyword">var</span> obj2 = _.<span class="hljs-title function_">cloneDeep</span>(obj1);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1.<span class="hljs-property">b</span>.<span class="hljs-property">f</span> === obj2.<span class="hljs-property">b</span>.<span class="hljs-property">f</span>);<span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p><strong>⭐ 手写实现深拷贝函数</strong></p><p>具体优化细节可以看<a href="https://www.yuque.com/zweirdo/zxyob8/mkhhq2eoodzvocnb#ggm18">18_深拷贝-事件总线</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isObject</span>(<span class="hljs-params">originValue</span>) &#123;<br>    <span class="hljs-keyword">const</span> myType = <span class="hljs-keyword">typeof</span> originValue;<br>    <span class="hljs-keyword">return</span> myType != <span class="hljs-literal">null</span> &amp;&amp; (myType === <span class="hljs-string">&quot;function&quot;</span> || myType === <span class="hljs-string">&quot;object&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepCopy</span>(<span class="hljs-params">originValue, map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>()</span>) &#123;<br>  <br>    <span class="hljs-comment">// 1.如果值是Symbol的类型</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> originValue === <span class="hljs-string">&quot;symbol&quot;</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Symbol</span>(originValue.<span class="hljs-property">description</span>)<br>    &#125;<br><br>    <span class="hljs-comment">// 2.如果是原始类型或者promise, 直接返回</span><br>    <span class="hljs-comment">// 如果你深拷贝一个 Promise 对象，可能会破坏其异步行为，并且导致意外行为。</span><br>    <span class="hljs-comment">// 这样可以避免破坏异步行为和意外行为。</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isObject</span>(originValue) || originValue <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) &#123;<br>        <span class="hljs-keyword">return</span> originValue<br>    &#125;<br><br>    <span class="hljs-comment">// 3.如果是set类型</span><br>    <span class="hljs-keyword">if</span> (originValue <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Set</span>) &#123;<br>        <span class="hljs-keyword">const</span> newSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> setItem <span class="hljs-keyword">of</span> originValue) &#123;<br>            newSet.<span class="hljs-title function_">add</span>(<span class="hljs-title function_">deepCopy</span>(setItem))<br>        &#125;<br>        <span class="hljs-keyword">return</span> newSet<br>    &#125;<br><br>    <span class="hljs-comment">// 4. 判断值是否为map类型</span><br>    <span class="hljs-keyword">if</span> (originValue <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Map</span>) &#123;<br>        <span class="hljs-keyword">const</span> newMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [i, j] <span class="hljs-keyword">of</span> originValue) &#123;<br>            newMap.<span class="hljs-title function_">set</span>(<span class="hljs-title function_">deepCopy</span>(i, map), <span class="hljs-title function_">deepCopy</span>(j, map));<br>        &#125;<br>        <span class="hljs-keyword">return</span> newMap;<br>    &#125;<br><br>    <span class="hljs-comment">// 5. 处理日期对象</span><br>    <span class="hljs-keyword">if</span> (originValue <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Date</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(originValue.<span class="hljs-title function_">getTime</span>());<br>    &#125;<br><br>    <span class="hljs-comment">// 6. 处理正则表达式对象</span><br>    <span class="hljs-keyword">if</span> (originValue <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">RegExp</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(originValue);<br>    &#125;<br><br>    <span class="hljs-comment">// 7.如果是函数function类型, 不需要进行深拷贝</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> originValue === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>        <span class="hljs-keyword">return</span> originValue<br>    &#125;<br><br>    <span class="hljs-comment">// 8.处理循环引用</span><br>    <span class="hljs-keyword">if</span> (map.<span class="hljs-title function_">get</span>(originValue)) &#123;<br>        <span class="hljs-keyword">return</span> map.<span class="hljs-title function_">get</span>(originValue)<br>    &#125;<br><br>    <span class="hljs-comment">// 9.判断是对象或者数组类型</span><br>    <span class="hljs-keyword">const</span> newObj = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(originValue) ? []: &#123;&#125;<br>    map.<span class="hljs-title function_">set</span>(originValue, newObj)<br><br>    <span class="hljs-comment">// 遍历普通的key</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> originValue) &#123;<br>        newObj[key] = <span class="hljs-title function_">deepCopy</span>(originValue[key], map);<br>    &#125;<br><br>    <span class="hljs-comment">// 单独遍历symbol</span><br>    <span class="hljs-keyword">const</span> symbolKeys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertySymbols</span>(originValue)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> symbolKey <span class="hljs-keyword">of</span> symbolKeys) &#123;<br>        newObj[<span class="hljs-title class_">Symbol</span>(symbolKey.<span class="hljs-property">description</span>)] = <span class="hljs-title function_">deepCopy</span>(originValue[symbolKey], map)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> newObj<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="17-判断循环引用的方法"><a href="#17-判断循环引用的方法" class="headerlink" title="17. 判断循环引用的方法"></a>17. 判断循环引用的方法</h3><p>原生</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">isCycleObject</span> = (<span class="hljs-params">obj, parent</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> parentArr = parent || [obj]; <span class="hljs-comment">//  如果没有传入父级, parentArr就代表包含当前对象的数组</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(parentArr);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> obj) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj[i] === <span class="hljs-string">&quot;object&quot;</span>) &#123;<br>      <span class="hljs-keyword">let</span> flag = <span class="hljs-literal">false</span>;<br>      parentArr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">pObj</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (pObj === obj[i]) &#123;<br>          flag = <span class="hljs-literal">true</span>;<br>        &#125;<br>      &#125;);<br>      <span class="hljs-keyword">if</span> (flag) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      flag = <span class="hljs-title function_">isCycleObject</span>(obj[i], [...parentArr, obj[i]]); <span class="hljs-comment">// 递归调用这个子对象</span><br>      <span class="hljs-keyword">if</span> (flag) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;;<br><br><span class="hljs-keyword">var</span> a = &#123; <span class="hljs-attr">b</span>: &#123; <span class="hljs-attr">c</span>: &#123;&#125; &#125; &#125;;<br><br>a.<span class="hljs-property">b</span>.<span class="hljs-property">c</span>.<span class="hljs-property">d</span> = a;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">isCycleObject</span>(a));<br><span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>递归 + 哈希表</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isCircular</span>(<span class="hljs-params">obj, hash = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>()</span>) &#123;<br>  <span class="hljs-keyword">if</span> (obj === <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&#x27;object&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>  <span class="hljs-keyword">if</span> (hash.<span class="hljs-title function_">has</span>(obj)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>  hash.<span class="hljs-title function_">set</span>(obj, <span class="hljs-literal">true</span>)<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hasOwnProperty</span>.<span class="hljs-title function_">call</span>(obj, key)) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isCircular</span>(obj[key], hash)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><h3 id="1-实现数组的扁平化"><a href="#1-实现数组的扁平化" class="headerlink" title="1. 实现数组的扁平化"></a>1. 实现数组的扁平化</h3><p>实现数组扁平化有 6 种方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript">ary = ary.<span class="hljs-title function_">flat</span>(<span class="hljs-title class_">Infinity</span>); <span class="hljs-comment">// Infinity 代表扁平多少层</span><br>ary = str.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/(\[|\])/g</span>, <span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;,&#x27;</span>) <span class="hljs-comment">// 把括号全部替换为空字符串</span><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]]];<br><span class="hljs-keyword">let</span> fn = <span class="hljs-keyword">function</span>(<span class="hljs-params">ary</span>) &#123;<br>  <span class="hljs-keyword">let</span> result = [];<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; ary.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">let</span> item = ary[i];<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(item))&#123;<br>      result = result.<span class="hljs-title function_">concat</span>(<span class="hljs-title function_">fn</span>(item));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      result.<span class="hljs-title function_">push</span>(item);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">fn</span>(arr))  <span class="hljs-comment">// [ 1, 2, 3, 4, 5 ]</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">flatten</span>(<span class="hljs-params">ary</span>) &#123;<br>    <span class="hljs-keyword">return</span> ary.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">pre, cur</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> pre.<span class="hljs-title function_">concat</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(cur) ? <span class="hljs-title function_">flatten</span>(cur) : cur);<br>    &#125;, []);<br>&#125;<br><span class="hljs-comment">//只要有一个元素有数组，那么循环继续</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">flatten</span>(<span class="hljs-params">arr</span>) &#123;<br>    <span class="hljs-keyword">while</span> (arr.<span class="hljs-title function_">some</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(item))) &#123;<br>        arr = [].<span class="hljs-title function_">concat</span>(...arr);<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]];<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">flatten</span>(<span class="hljs-params">arr</span>) &#123;<br>    <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;,&#x27;</span>).<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Number</span>);<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">flatten</span>(arr)); <span class="hljs-comment">//  [ 1, 2, 3, 4 ]</span><br></code></pre></td></tr></table></figure><p>以上数组 <code>arr.toString()</code> 之后 直接变成了 <code>1,2,3,4</code></p><h3 id="2-实现数组各个方法"><a href="#2-实现数组各个方法" class="headerlink" title="2. 实现数组各个方法"></a>2. 实现数组各个方法</h3><p>flat</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">_flat</span>(<span class="hljs-params">arr, depth</span>) &#123;<br>  <span class="hljs-keyword">if</span>(!<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(arr) || depth &lt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> arr;<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">prev, cur</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(cur)) &#123;<br>      <span class="hljs-keyword">return</span> prev.<span class="hljs-title function_">concat</span>(<span class="hljs-title function_">_flat</span>(cur, depth - <span class="hljs-number">1</span>))<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> prev.<span class="hljs-title function_">concat</span>(cur);<br>    &#125;<br>  &#125;, []);<br>&#125;<br></code></pre></td></tr></table></figure><p>push</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 简便写法</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">push</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">for</span>( <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span> ; i++)&#123;<br><span class="hljs-variable language_">this</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>] = <span class="hljs-variable language_">arguments</span>[i] ;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>;<br>&#125;<br><br><br><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">push</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">...items</span>) &#123;<br>  <span class="hljs-keyword">let</span> O = <span class="hljs-title class_">Object</span>(<span class="hljs-variable language_">this</span>);<br>  <span class="hljs-keyword">let</span> len = <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span> &gt;&gt;&gt; <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> argCount = items.<span class="hljs-property">length</span> &gt;&gt;&gt; <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 2 ** 53 - 1 为JS能表示的最大正整数</span><br>  <span class="hljs-keyword">if</span> (len + argCount &gt; <span class="hljs-number">2</span> ** <span class="hljs-number">53</span> - <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;The number of array is over the max value restricted!&quot;</span>)<br>  &#125;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; argCount; i++) &#123;<br>    O[len + i] = items[i];<br>  &#125;<br>  <span class="hljs-keyword">let</span> newLength = len + argCount;<br>  O.<span class="hljs-property">length</span> = newLength;<br>  <span class="hljs-keyword">return</span> newLength;<br>&#125;<br></code></pre></td></tr></table></figure><p>pop</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">pop</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> O = <span class="hljs-title class_">Object</span>(<span class="hljs-variable language_">this</span>);<br>  <span class="hljs-keyword">let</span> len = <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span> &gt;&gt;&gt; <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (len === <span class="hljs-number">0</span>) &#123;<br>    O.<span class="hljs-property">length</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;<br>  &#125;<br>  len --;<br>  <span class="hljs-keyword">let</span> value = O[len];<br>  <span class="hljs-keyword">delete</span> O[len];<br>  O.<span class="hljs-property">length</span> = len;<br>  <span class="hljs-keyword">return</span> value;<br>&#125;<br></code></pre></td></tr></table></figure><p>filter</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_filter</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fn !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;参数必须是一个函数&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">const</span> res = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>; i &lt; len; i++) &#123;<br>        <span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">this</span>[i]) &amp;&amp; res.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>map</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 简便写法</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">map</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">cb,thisArg</span>)&#123;<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(<span class="hljs-variable language_">this</span>) || <span class="hljs-keyword">typeof</span> cb != <span class="hljs-string">&#x27;function&#x27;</span>)&#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;has Error, please check!&#x27;</span>)<br>    &#125;<br>    <span class="hljs-keyword">var</span> res = []<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>; i++)&#123;<br>     <span class="hljs-comment">//使用call方法来改变this指向即可</span><br>     res.<span class="hljs-title function_">push</span>(cb.<span class="hljs-title function_">call</span>(thisArg,<span class="hljs-variable language_">this</span>[i],i,<span class="hljs-variable language_">this</span>))<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br><br><br><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_map</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">fn</span>) &#123;<br>   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fn !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;参数必须是一个函数&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">const</span> res = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>; i &lt; len; i++) &#123;<br>        res.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">this</span>[i]));<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>reduce</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">reduce</span>  = <span class="hljs-keyword">function</span>(<span class="hljs-params">callbackfn, initialValue</span>) &#123;<br>  <span class="hljs-comment">// 异常处理，和 map 一样</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span> === <span class="hljs-literal">null</span> || <span class="hljs-variable language_">this</span> === <span class="hljs-literal">undefined</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;Cannot read property &#x27;reduce&#x27; of null or undefined&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(callbackfn) != <span class="hljs-string">&quot;[object Function]&quot;</span>) &#123; <span class="hljs-comment">//注意中间无逗号</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(callbackfn + <span class="hljs-string">&#x27; is not a function&#x27;</span>)<br>  &#125;<br>  <span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 后面要重复利用</span><br>  <span class="hljs-keyword">let</span> O = <span class="hljs-title class_">Object</span>(<span class="hljs-variable language_">this</span>);  <span class="hljs-comment">// 先将调用者转为对象</span><br>  <span class="hljs-keyword">let</span> len = O.<span class="hljs-property">length</span> &gt;&gt;&gt; <span class="hljs-number">0</span>;  <span class="hljs-comment">// 确认为整数</span><br>  <span class="hljs-keyword">let</span> accumulator = initialValue; <span class="hljs-comment">// 积累值</span><br>  <span class="hljs-keyword">if</span> (accumulator === <span class="hljs-literal">undefined</span>) &#123;   <span class="hljs-comment">// 没传初始值</span><br>    <span class="hljs-keyword">for</span>(; k &lt; len ; k++) &#123;<br>      <span class="hljs-keyword">if</span> (k <span class="hljs-keyword">in</span> O) &#123;  <br>        accumulator = O[k];<br>        k++;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 表示数组全为空</span><br>  <span class="hljs-keyword">if</span>(k === len &amp;&amp; accumulator === <span class="hljs-literal">undefined</span>) <br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Each element of the array is empty&#x27;</span>);<br>  <br>  <span class="hljs-keyword">for</span>(;k &lt; len; k++) &#123;<br>    <span class="hljs-keyword">if</span> (k <span class="hljs-keyword">in</span> O) &#123;<br>      accumulator = callbackfn.<span class="hljs-title function_">call</span>(<span class="hljs-literal">undefined</span>, accumulator, O[k], k, O);   <span class="hljs-comment">// 注意，核心！</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> accumulator;<br>&#125;<br></code></pre></td></tr></table></figure><p>sort</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> quick_sort = <span class="hljs-keyword">function</span>(<span class="hljs-params">a, l, r</span>)&#123;<br>    <span class="hljs-keyword">if</span>(l &gt;= r)<span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">let</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> x = a[mid];<br>    <span class="hljs-keyword">while</span>(i &lt; j)&#123;<br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span>(a[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span>(a[j] &gt; x);<br>        <span class="hljs-keyword">if</span>(i &lt; j)&#123;<br>            <span class="hljs-keyword">let</span> z = a[i];<br>            a[i] = a[j];<br>            a[j] = z;<br>        &#125;<br>    &#125;<br>    <span class="hljs-title function_">quick_sort</span>(a, l, j);<br>    <span class="hljs-title function_">quick_sort</span>(a, j + <span class="hljs-number">1</span>, r);<br>&#125;<br><span class="hljs-keyword">var</span> q = [<span class="hljs-number">1</span>,<span class="hljs-number">44</span>,<span class="hljs-number">6</span>,<span class="hljs-number">713</span>,<span class="hljs-number">76</span>];<br><span class="hljs-title function_">quick_sort</span>(q, <span class="hljs-number">0</span>, q.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(q);  <span class="hljs-comment">// [ 1, 6, 44, 76, 713 ]</span><br></code></pre></td></tr></table></figure><p>splice 方法(了解原理)</p><details class="lake-collapse"><summary id="u3d2e2d29"><span class="ne-text">代码</span></summary><pre data-language="javascript" id="YT8RU" class="ne-codeblock language-javascript" style="border: 1px solid #e8e8e8; border-radius: 2px; background: #f9f9f9; padding: 16px; font-size: 13px; color: #595959"><code>Array.prototype.splice = function(startIndex, deleteCount, ...addElements)  &#123;  // 1. 初始工作  let argumentsLen = arguments.length;  let array = Object(this);  let len = array.length;  let deleteArr = new Array(deleteCount);<pre><code class="hljs">// 2. 参数的清洗工作</code></pre><p>  &#x2F;&#x2F; 当用户传来非法的 startIndex 和 deleteCount 或者负索引的时候，需要我们做出特殊的处理。<br>  if (startIndex &lt; 0) {<br>    startIndex &#x3D; startIndex + len &gt; 0 ? startIndex + len: 0;<br>  }<br>  else startIndex &#x3D; startIndex &gt;&#x3D; len ? len: startIndex;</p><p>  &#x2F;&#x2F; 删除数目没有传，默认删除startIndex及后面所有的<br>  if (argumentsLen &#x3D;&#x3D;&#x3D; 1)  deleteCount &#x3D; len - startIndex;<br>  else if (deleteCount &lt; 0) deleteCount &#x3D; 0 &#x2F;&#x2F; 删除数目过小<br>  else if (deleteCount &gt; len - startIndex) deletCount &#x3D; len - startIndex; &#x2F;&#x2F;删除数目过大</p><pre><code class="hljs">// 3. 判断 sealed 对象和 frozen 对象, 即 密封对象 和 冻结对象if (Object.isSealed(array) &amp;amp;&amp;amp; deleteCount !== addElements.length) &#123;throw new TypeError(&#39;the object is a sealed object!&#39;)</code></pre><p>  } else if(Object.isFrozen(array) &amp;&amp; (deleteCount &gt; 0 || addElements.length &gt; 0)) {<br>    throw new TypeError(‘the object is a frozen object!’)<br>  }</p><p>  &#x2F;&#x2F; 4.拷贝删除的元素<br>  for (let i &#x3D; 0; i &lt; deleteCount; i++) {<br>    let index &#x3D; startIndex + i;<br>    if (index in array) {<br>      let current &#x3D; array[index];<br>      deleteArr[i] &#x3D; current;<br>    }<br>  }</p><p>  &#x2F;&#x2F; 5.移动删除元素后面的元素</p><p>  &#x2F;&#x2F; 对删除元素后面的元素进行挪动, 挪动分为三种情况:<br>  &#x2F;&#x2F; * 添加的元素和删除的元素个数相等<br>  &#x2F;&#x2F; * 添加的元素个数小于删除的元素<br>  &#x2F;&#x2F; * 添加的元素个数大于删除的元素</p><p>  if (deleteCount &#x3D;&#x3D;&#x3D; addElements.length) &#x2F;&#x2F; 就什么也不管<br>  else if(deleteCount &gt; addElements.length) {<br>    &#x2F;&#x2F; 删除的元素比新增的元素多，那么后面的元素整体向前挪动<br>    for (let i &#x3D; startIndex + deleteCount; i &lt; len; i++) {<br>      let fromIndex &#x3D; i; &#x2F;&#x2F; 移动元素的起始位置<br>      let toIndex &#x3D; i - (deleteCount - addElements.length); &#x2F;&#x2F; 将要挪动到的目标位置<br>      if (fromIndex in array) {<br>        array[toIndex] &#x3D; array[fromIndex];<br>      } else {<br>        delete array[toIndex];<br>      }<br>    }<br>    &#x2F;&#x2F; 注意注意！这里我们把后面的元素向前挪，相当于数组长度减小了，需要删除冗余元素<br>    &#x2F;&#x2F; 目前长度为 len + addElements - deleteCount<br>    for (let i &#x3D; len - 1; i &gt;&#x3D; len + addElements.length - deleteCount; i –) {<br>      delete array[i];<br>    }<br>  }<br>     else if(deleteCount &lt; addElements.length) {<br>    &#x2F;&#x2F; 删除的元素比新增的元素少，那么后面的元素整体向后挪动<br>    &#x2F;&#x2F; 思考一下: 这里为什么要从后往前遍历？从前往后会产生什么问题？<br>    for (let i &#x3D; len - 1; i &gt;&#x3D; startIndex + deleteCount; i–) {<br>      let fromIndex &#x3D; i;  &#x2F;&#x2F; 挪动元素的初始位置<br>      let toIndex &#x3D; i + (addElements.length - deleteCount); &#x2F;&#x2F; 将要挪动到的目标位置<br>      if (fromIndex in array) {<br>        array[toIndex] &#x3D; array[fromIndex];<br>      } else {<br>        delete array[toIndex];<br>      }<br>    }<br>  }</p><p>  &#x2F;&#x2F; 6.插入新元素<br>  for (let i &#x3D; 0; i &lt; addElements.length; i++) {<br>    array[startIndex + i] &#x3D; addElements[i];<br>  }<br>  array.length &#x3D; len - deleteCount + addElements.length;</p><p>  &#x2F;&#x2F; 7.返回被删除元素组成的数组<br>  return deleteArr;<br>}</code></pre></details></p><h3 id="实现数组的乱序输出"><a href="#实现数组的乱序输出" class="headerlink" title="实现数组的乱序输出"></a>实现数组的乱序输出</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>  <span class="hljs-comment">// 注意最后加i就行, 否则会重复输出同一个值</span><br>  <span class="hljs-keyword">const</span> randomIndex = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * (arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span> - i)) + i; <br>  [arr[i], arr[randomIndex]] = [arr[randomIndex], arr[i]];<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr)<br></code></pre></td></tr></table></figure><h3 id="实现字符串的-repeat-方法"><a href="#实现字符串的-repeat-方法" class="headerlink" title="实现字符串的 repeat 方法"></a>实现字符串的 repeat 方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">repeat</span>(<span class="hljs-params">s, n</span>) &#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(n + <span class="hljs-number">1</span>)).<span class="hljs-title function_">join</span>(s);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-实现字符串各个方法"><a href="#3-实现字符串各个方法" class="headerlink" title="3. 实现字符串各个方法"></a>3. 实现字符串各个方法</h3><p>repeat</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">repeat</span>(<span class="hljs-params">s, n</span>) &#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(n + <span class="hljs-number">1</span>)).<span class="hljs-title function_">join</span>(s);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-将数字每千分位用逗号隔开"><a href="#4-将数字每千分位用逗号隔开" class="headerlink" title="4. 将数字每千分位用逗号隔开"></a>4. 将数字每千分位用逗号隔开</h3><p>数字无小数版本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">format</span> = n =&gt; &#123;<br>    <span class="hljs-keyword">let</span> num = n.<span class="hljs-title function_">toString</span>() <br>    <span class="hljs-keyword">let</span> len = num.<span class="hljs-property">length</span><br>    <span class="hljs-keyword">if</span> (len &lt;= <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-keyword">return</span> num<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">let</span> remainder = len % <span class="hljs-number">3</span><br>        <span class="hljs-keyword">if</span> (remainder &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 不是3的整数倍</span><br>          <span class="hljs-comment">// 每隔三个数字用逗号分隔为字符串</span><br>          <span class="hljs-keyword">return</span> num.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, remainder) + <span class="hljs-string">&#x27;,&#x27;</span> + num.<span class="hljs-title function_">slice</span>(remainder, len).<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\d&#123;3&#125;/g</span>).<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;,&#x27;</span>) <br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 是3的整数倍</span><br>            <span class="hljs-keyword">return</span> num.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, len).<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\d&#123;3&#125;/g</span>).<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;,&#x27;</span>) <br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-title function_">format</span>(<span class="hljs-number">1232323</span>)  <span class="hljs-comment">// &#x27;1,232,323&#x27;</span><br></code></pre></td></tr></table></figure><p>数字有小数版本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">format</span> = n =&gt; &#123;<br>    <span class="hljs-keyword">let</span> num = n.<span class="hljs-title function_">toString</span>() <span class="hljs-comment">// 转成字符串</span><br>    <span class="hljs-keyword">let</span> decimals = <span class="hljs-string">&#x27;&#x27;</span><br>        <span class="hljs-comment">// 判断是否有小数</span><br>    num.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;.&#x27;</span>) &gt; -<span class="hljs-number">1</span> ? decimals = num.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;.&#x27;</span>)[<span class="hljs-number">1</span>] : decimals<br>    <span class="hljs-keyword">let</span> len = num.<span class="hljs-property">length</span><br>    <span class="hljs-keyword">if</span> (len &lt;= <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-keyword">return</span> num<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">let</span> temp = <span class="hljs-string">&#x27;&#x27;</span><br>        <span class="hljs-keyword">let</span> remainder = len % <span class="hljs-number">3</span><br>        decimals ? temp = <span class="hljs-string">&#x27;.&#x27;</span> + decimals : temp<br>        <span class="hljs-keyword">if</span> (remainder &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 不是3的整数倍</span><br>            <span class="hljs-keyword">return</span> num.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, remainder) + <span class="hljs-string">&#x27;,&#x27;</span> + num.<span class="hljs-title function_">slice</span>(remainder, len).<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\d&#123;3&#125;/g</span>).<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;,&#x27;</span>) + temp<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 是3的整数倍</span><br>            <span class="hljs-keyword">return</span> num.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, len).<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\d&#123;3&#125;/g</span>).<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;,&#x27;</span>) + temp <br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-title function_">format</span>(<span class="hljs-number">12323.33</span>)  <span class="hljs-comment">// &#x27;12,323.33&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="5-手写日期格式化函数"><a href="#5-手写日期格式化函数" class="headerlink" title="5. 手写日期格式化函数"></a>5. 手写日期格式化函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">dateFormat</span> = (<span class="hljs-params">dateInput, format</span>)=&gt;&#123;<br>    <span class="hljs-keyword">var</span> day = dateInput.<span class="hljs-title function_">getDate</span>() <br>    <span class="hljs-keyword">var</span> month = dateInput.<span class="hljs-title function_">getMonth</span>() + <span class="hljs-number">1</span>  <br>    <span class="hljs-keyword">var</span> year = dateInput.<span class="hljs-title function_">getFullYear</span>()   <br>    format = format.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/yyyy/</span>, year)<br>    format = format.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/MM/</span>,month)<br>    format = format.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/dd/</span>,day)<br>    <span class="hljs-keyword">return</span> format<br>&#125;<br><span class="hljs-title function_">dateFormat</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-string">&#x27;2020-12-01&#x27;</span>), <span class="hljs-string">&#x27;yyyy/MM/dd&#x27;</span>) <span class="hljs-comment">// 2020/12/01</span><br><span class="hljs-title function_">dateFormat</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-string">&#x27;2020-04-01&#x27;</span>), <span class="hljs-string">&#x27;yyyy/MM/dd&#x27;</span>) <span class="hljs-comment">// 2020/04/01</span><br><span class="hljs-title function_">dateFormat</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-string">&#x27;2020-04-01&#x27;</span>), <span class="hljs-string">&#x27;yyyy年MM月dd日&#x27;</span>) <span class="hljs-comment">// 2020年04月01日</span><br></code></pre></td></tr></table></figure><h3 id="6-实现大整数相加"><a href="#6-实现大整数相加" class="headerlink" title="6. 实现大整数相加"></a>6. 实现大整数相加</h3><p>来自算法篇章</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-string">&#x27;13124342343353535235&#x27;</span><br><span class="hljs-keyword">let</span> b = <span class="hljs-string">&#x27;34423434234234243233&#x27;</span><br><span class="hljs-comment">// 两个字符串a, b</span><br><span class="hljs-keyword">let</span> arr1 = a.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Number</span>);<br><span class="hljs-keyword">let</span> arr2 = b.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Number</span>);<br><span class="hljs-keyword">let</span> res = [];<br><span class="hljs-keyword">let</span> flag = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(arr1.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span> || arr2.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>  <span class="hljs-keyword">let</span> t1 = arr1.<span class="hljs-title function_">pop</span>() || <span class="hljs-number">0</span>;  <span class="hljs-comment">// 判断arr1是否已经为空</span><br>  <span class="hljs-keyword">let</span> t2 = arr2.<span class="hljs-title function_">pop</span>() || <span class="hljs-number">0</span>;  <span class="hljs-comment">// 判断arr2是否已经为空</span><br>  <span class="hljs-keyword">let</span> tmp = t1 + t2 + flag;<br>  flag = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(tmp / <span class="hljs-number">10</span>)<br>  res.<span class="hljs-title function_">unshift</span>(tmp % <span class="hljs-number">10</span>)<br>&#125;<br><span class="hljs-keyword">if</span>(flag) res.<span class="hljs-title function_">unshift</span>(flag);<br>res = res.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res); <span class="hljs-comment">// 47547776577587778468</span><br></code></pre></td></tr></table></figure><h3 id="7-解析-URL-Params-为对象"><a href="#7-解析-URL-Params-为对象" class="headerlink" title="7. 解析 URL Params 为对象"></a>7. 解析 URL Params 为对象</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> url = <span class="hljs-string">&#x27;http://www.domain.com/?user=anonymous&amp;id=123&amp;id=456&amp;city=%E5%8C%97%E4%BA%AC&amp;enabled&#x27;</span>;<br><span class="hljs-title function_">parseParam</span>(url)<br><span class="hljs-comment">/* 结果</span><br><span class="hljs-comment">&#123; user: &#x27;anonymous&#x27;,</span><br><span class="hljs-comment">  id: [ 123, 456 ], // 重复出现的 key 要组装成数组，能被转成数字的就转成数字类型</span><br><span class="hljs-comment">  city: &#x27;北京&#x27;, // 中文需解码</span><br><span class="hljs-comment">  enabled: true, // 未指定值得 key 约定为 true</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>exec 是正则的方法</p><p>exec() 方法在一个指定字符串中执行一个搜索匹配。返回一个结果数组或 null。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">parseParam</span>(<span class="hljs-params">url</span>) &#123;<br>  <span class="hljs-keyword">const</span> paramsStr = <span class="hljs-regexp">/.+\?(.+)$/</span>.<span class="hljs-title function_">exec</span>(url)[<span class="hljs-number">1</span>]; <span class="hljs-comment">// 将 ? 后面的字符串取出来❗</span><br>  <span class="hljs-keyword">const</span> paramsArr = paramsStr.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&amp;&#x27;</span>); <span class="hljs-comment">// 将字符串以 &amp; 分割后存到数组中</span><br>  <span class="hljs-keyword">let</span> paramsObj = &#123;&#125;;<br>  <span class="hljs-comment">// 将 params 存到对象中</span><br>  paramsArr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">param</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/=/</span>.<span class="hljs-title function_">test</span>(param)) &#123; <span class="hljs-comment">// 处理有 value 的参数, 存在 &#x27;=&#x27;</span><br>      <span class="hljs-keyword">let</span> [key, val] = param.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;=&#x27;</span>); <span class="hljs-comment">// 分割 key 和 value</span><br>      val = <span class="hljs-built_in">decodeURIComponent</span>(val); <span class="hljs-comment">// 解码❗ 注意还需解码</span><br>      val = <span class="hljs-regexp">/^\d+$/</span>.<span class="hljs-title function_">test</span>(val) ? <span class="hljs-built_in">parseFloat</span>(val) : val; <span class="hljs-comment">// 判断是否转为数字</span><br>      <span class="hljs-keyword">if</span> (paramsObj.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123; <span class="hljs-comment">// 如果对象有 key，则添加一个值</span><br>        paramsObj[key] = [].<span class="hljs-title function_">concat</span>(paramsObj[key], val); <span class="hljs-comment">// 将其变为数组, 因为有多个值, 就用数组存起来</span><br>      &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 如果对象没有这个 key，创建 key 并设置值</span><br>        paramsObj[key] = val;<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 处理没有 value 的参数</span><br>      paramsObj[param] = <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;)<br>  <span class="hljs-keyword">return</span> paramsObj;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue响应式原理</title>
    <link href="/2023/09/12/Vue%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"/>
    <url>/2023/09/12/Vue%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="1-认识响应式逻辑"><a href="#1-认识响应式逻辑" class="headerlink" title="1. 认识响应式逻辑"></a>1. 认识响应式逻辑</h2><blockquote><p>抽象描绘</p></blockquote><ul><li>假如你有一个变量m , 你的某一段代码使用了变量m , 如果某个时刻变量m发生了改变, 那么这段代码也会重新执行.</li><li>但实际上执行的代码中可能不止一行代码，所以我们可以将这些代码放到一个函数中, 于是就变成了, <strong>你有一个对象, 你的某个函数使用了对象的某个属性, 如果某个时候这个属性发生改变, 这个函数也会重新执行</strong></li></ul><blockquote><p>具体描述</p></blockquote><p>数据驱动视图 </p><p>简洁版 :</p><p>在 Vue 实例创建过程中，首先对所有属性进行劫持 ( vue2 &#x2F; vue3 方法和原理都不同, 注意辨别 ) ,   同时会为每个数据属性创建一个 <code>Dep</code>（依赖），Dep 用于收集所有订阅了该属性的 <code>Watcher</code>。当属性值发生变化时，Vue 会通知该属性对应的这些 <code>Watcher</code> 实例进行相应的更新操作。</p><ul><li>数据响应式</li></ul><p>Vue采用的是<strong>数据劫持</strong>结合<strong>发布和-订阅者模式</strong>的方式</p><blockquote><p> 通过拦截对数据的操作，在数据变动时发布消息给订阅者，触发相应的监听回调。</p></blockquote><h3 id=""><a href="#" class="headerlink" title=""></a></h3><ul><li>数据劫持</li></ul><blockquote><p>vue2数据劫持</p></blockquote><p>vue2通过<code>Object.defineProperty</code>对<code>data</code>上的数据<strong>递归地</strong>进行(转为)<code>getter</code>和<code>setter</code>操作。也就是对属性的读取、修改进行拦截（数据劫持）</p><p>注意是将 data 中的所有属性进行监听</p><blockquote><p>vue3 数据劫持</p></blockquote><p>vue3通过<code>Proxy</code>对象创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。<code>Proxy</code>的监听是深层次的，<strong>监听整个对象，而不是某个属性。</strong></p><p>这里是将 reactive () 中的所有属性进行监听</p><ul><li>发布者-订阅者模式</li></ul><p>简单地说，发布者-订阅者模式的流程就是，监听器<code>**Observer**</code>监听数据状态变化, 一旦数据发生变化，则会通知(数据)对应的订阅者<code>**Watcher**</code>，让订阅者执行对应的业务逻辑 。</p><ul><li>整个响应式执行过程</li></ul><ol><li>在 Vue 实例初始化过程中， 我们设置了一个监听器<code>**Observer**</code>，此实例的所有相关属性会被监听(也就是上方的数据劫持)  . 在此过程中，Vue 会对<strong>每个属性</strong>创建一个 <code>dep</code> 实例</li></ol><ul><li>vue2 对 data 中的属性进行遍历生成 <code>dep</code> 实例</li><li>vue3 中对 <code>reactive()</code> 中的对象进行遍历生成 <code>dep</code> 实例</li><li><code>dep</code> 实例会收集所有订阅了该属性的 <code>Watcher 订阅者</code>, 并将该 <code>Watcher</code> 绑定更新函数</li><li>这些更新函数可能会执行一些操作，比如更新模板中的文本、计算新的值等</li></ul><ol><li>通过<code>Compile</code>解析模板指令，将模板中的数据和方法与真实 DOM 节点关联起来，使得数据和方法能够被视图访问和使用, 然后再初始化渲染页面视图.</li><li>一旦属性发生变化，Vue 会通知所有订阅了当前属性的的订阅者<code>Watcher</code>(这些 <code>Watcher</code> 放在属性对应的 <code>dep</code> 实例当中), 来执行此订阅者对应的更新函数,  从而更新视图.</li></ol><blockquote><p> MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</p></blockquote><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309210946810.png" alt="image-20230921094628751"></p><h2 id="2-响应式依赖收集"><a href="#2-响应式依赖收集" class="headerlink" title="2. 响应式依赖收集"></a>2. 响应式依赖收集</h2><h3 id="2-1-响应式函数的实现watchFn"><a href="#2-1-响应式函数的实现watchFn" class="headerlink" title="2.1. 响应式函数的实现watchFn"></a>2.1. 响应式函数的实现watchFn</h3><p>我们现在实现一个响应式函数</p><p>◼ 但是我们怎么区分呢？</p><ul><li>这个时候我们封装一个新的函数<code>watchFn</code>；</li><li><strong>凡是传入到watchFn的函数，就是需要响应式的；</strong></li><li>其他默认定义的函数都是不需要响应式的；</li></ul><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927280.png" alt="img"></p><p>如图, foo以及bar都是需要响应式的</p><p>我们将这些函数在响应之前先执行一次</p><p>当obj的某个属性发生变化时, 就依次执行reactiveFns中的函数</p><p>目前当然是极为不完善, 待后续优化hhh</p><h3 id="2-2-响应式依赖的收集-类"><a href="#2-2-响应式依赖的收集-类" class="headerlink" title="2.2. 响应式依赖的收集__类"></a>2.2. 响应式依赖的收集__类</h3><p>◼ 目前我们收集的依赖是放到一个数组中来保存的，但是这里会存在数据管理的问题：</p><ul><li> 我们在实际开发中<strong>需要监听很多对象的响应式；</strong></li><li> 这些对象需要监听的不只是一个属性，它们很多属性的变化，都会有对应的响应式函数；</li><li> 我们不<strong>可能在全局维护一大堆的数组来保存这些响应函数；</strong></li></ul><p>◼ 所以我们要<strong>设计一个类，这个类用于管理某一个对象的某一个属性的所有响应式函数：</strong></p><ul><li> 相当于替代了原来的简单 reactiveFns 的数组；</li></ul><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927189.png" alt="img"></p><p>这个类记住</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927257.png" alt="img"></p><p>当我们某个属性发生变化时, 只需执行dep.notify()就行了, 无需一个一个的遍历函数</p><p>这个obj对象就对应Depend类所创建出来的对象</p><p>当然, 还需大大的优化</p><p>现在我们每次修改了一个属性之后都是手动的去调用, 这样太麻烦了, 我们想要让它自动去调用响应函数,</p><p>因此我们要去监听属性的变化</p><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h2 id="3-Object-defineProperty-监听属性变化"><a href="#3-Object-defineProperty-监听属性变化" class="headerlink" title="3. Object.defineProperty()监听属性变化"></a>3. Object.defineProperty()监听属性变化</h2><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927250.png" alt="img"></p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927238.png" alt="img"></p><p>再记一遍这个类</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927292.png" alt="img"></p><p>注意看注释</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927814.png" alt="img"></p><p>这里在属性变化后就不用手动给它通知了, 自动响应实现</p><p>不过这种收集方式其实是错误的hhhhh</p><h2 id="4-自动收集依赖-🔥"><a href="#4-自动收集依赖-🔥" class="headerlink" title="4. 自动收集依赖 🔥"></a>4. 自动收集依赖 🔥</h2><p>我们现在发现了一个问题 , obj 对象的两个属性都依赖于 同一个dep对象的reactiveFns,</p><p>这样就会造成我们根本没办法区分它们</p><p>对于同一个对象来说, 我们还是给它放到了同一个dep里面, 这会造成无法将它的属性区分</p><p><strong>如何解决这个问题呢 ?</strong> </p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927843.png" alt="img"></p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927050.png" alt="img"></p><p>比如我们要获取obj对象的name属性的依赖</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> dep = objMap.<span class="hljs-title function_">get</span>(obj).<span class="hljs-title function_">get</span>(name);<br>dep.<span class="hljs-title function_">notifiy</span>();<br></code></pre></td></tr></table></figure><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927155.png" alt="img"></p><ul><li><p>dep对象数据结构的管理</p></li><li><p>每一个对象的每一个属性都会对应一个dep对象</p></li><li><p>同一个对象的多个属性的dep对象是存放一个map对象中</p></li><li><p>多个对象的map对象, 会被存放到一个objMap的对象中</p></li><li><p>当执行get函数, 自动的添加fn函数</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Depend</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span> = []<br>  &#125;<br><br>  <span class="hljs-title function_">addDepend</span>(<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-keyword">if</span> (fn) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span>.<span class="hljs-title function_">push</span>(fn)<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-title function_">notify</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> &#123;<br>      <span class="hljs-title function_">fn</span>()<br>    &#125;)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span><br>&#125;<br><br><span class="hljs-comment">// 设置一个专门执行响应式函数的一个函数</span><br><span class="hljs-keyword">let</span> reactiveFn = <span class="hljs-literal">null</span> <span class="hljs-comment">// </span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">watchFn</span>(<span class="hljs-params">fn</span>) &#123;<br>  reactiveFn = fn<br>  <span class="hljs-title function_">fn</span>() <span class="hljs-comment">// 执行下方的get方法 , 使得间接的把函数加到特定的dep对象上</span><br>  <span class="hljs-comment">//(因为函数中会有一些对象会有一些属性)</span><br>  reactiveFn = <span class="hljs-literal">null</span> <span class="hljs-comment">// 使用完后再置为null, 不然可能会造成影响</span><br>&#125;<br><br><span class="hljs-comment">// 封装一个函数: 负责通过obj的key获取对应的Depend对象</span><br><span class="hljs-comment">// 我们用一个WeakMap对所有对象进行管理, 我们不需要对里面进行强引用, </span><br><span class="hljs-comment">// 如果有一天obj为null,那就无法销毁了</span><br><span class="hljs-keyword">const</span> objMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>()<br><br><br><span class="hljs-comment">// 这个函数的作用是通过对象的key找到它的dep对象</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getDepend</span>(<span class="hljs-params">obj, key</span>) &#123;<br>  <br>  <span class="hljs-comment">// 1.根据对象obj, 找到对应的map对象</span><br>  <span class="hljs-keyword">let</span> map = objMap.<span class="hljs-title function_">get</span>(obj) <span class="hljs-comment">// 没有就new一个</span><br>  <span class="hljs-keyword">if</span> (!map) &#123;<br>    map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br>    objMap.<span class="hljs-title function_">set</span>(obj, map)<br>  &#125;<br><br>  <span class="hljs-comment">// 2.根据key, 找到对应的depend对象</span><br>  <span class="hljs-keyword">let</span> dep = map.<span class="hljs-title function_">get</span>(key)<br>  <span class="hljs-keyword">if</span> (!dep) &#123;<br>    dep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Depend</span>()<br>    map.<span class="hljs-title function_">set</span>(key, dep)<br>  &#125;<br>  <span class="hljs-keyword">return</span> dep<br>&#125;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> value = obj[key]<br><br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, key, &#123;<br>    <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">newValue</span>) &#123;<br>      value = newValue<br>      <span class="hljs-comment">// 拿到这个对象的属性的dep对象</span><br>      <span class="hljs-keyword">const</span> dep = <span class="hljs-title function_">getDepend</span>(obj, key)<br>      dep.<span class="hljs-title function_">notify</span>()  <span class="hljs-comment">// 对这些</span><br>    &#125;,<br>    <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-comment">// 在函数中拿到obj 和 key 就会调用这个get方法</span><br>      <span class="hljs-comment">// console.log(&quot;get函数中:&quot;, obj, key)</span><br>      <span class="hljs-comment">// 找到对应的obj对象的key对应的dep对象</span><br>      <span class="hljs-keyword">const</span> dep = <span class="hljs-title function_">getDepend</span>(obj, key) <br>      <span class="hljs-comment">// 意味着我们只会创建obj对象的key属性的dep对象</span><br>      dep.<span class="hljs-title function_">addDepend</span>(reactiveFn) <br>      <span class="hljs-comment">// 精髓 : 在这个dep对象上放入跟特有对象的特有属性相关的函数,即reactiveFn</span><br>      <span class="hljs-comment">// dep这个对象就是保存了跟这个特有对象特有属性相关的一些函数</span><br>      <br>      <span class="hljs-keyword">return</span> value<br>    &#125;<br>  &#125;)<br>&#125;)<br><br><span class="hljs-title function_">watchFn</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;foo function&quot;</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;foo:&quot;</span>, obj.<span class="hljs-property">name</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;foo&quot;</span>, obj.<span class="hljs-property">age</span>)<br>&#125;)<br><br><span class="hljs-title function_">watchFn</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;bar function&quot;</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;bar:&quot;</span>, obj.<span class="hljs-property">age</span> + <span class="hljs-number">10</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>注意看注释 !!!!!</p><p>你用了我的数据, 我就收集你的依赖, 你没用, 我就不收集 —</p><p>我们还有可以优化的点 : </p><p>当我们执行下面这段代码时</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927937.png" alt="img"></p><p>age发生变化时, 它会执行两次函数</p><p>我们可以这样操作</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927105.png" alt="img"></p><p>我们的reactiveFns是一个Set, 这样它就不会添加相同的函数到这里面去</p><p>然后下方的push改为add</p><p>还有一个地方是我们可以给<img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927328.png" alt="img">这个地方换个写法</p><p>我们并不希望将reactiveFn添加放到get中，因为它是属于Dep的行为 (也可以不换, 看自己 )</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927511.png" alt="img"></p><p>我们直接在类中添加一个方法自动获取收集的函数<code>depend()</code></p><p>相当于利用到这个自由变量<code>reactiveFn</code></p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927495.png" alt="img"></p><p>然后直接<code>dep.depen()</code>调用即可</p><p>不过这两种写法都可以 hhh</p><p>但这个代码还有不足, 关于<strong>多个对象</strong>, 我们如何给它挨个来自动收集依赖, 因为我们这里是写死给obj对象自动收集依赖的</p><p>如何解决呢? </p><p>方法如下hhh —- 多个对象响应式</p><h2 id="5-多个对象响应式"><a href="#5-多个对象响应式" class="headerlink" title="5. 多个对象响应式"></a>5. 多个对象响应式</h2><p>我们只需要将监听对象属性的这一串代码封装为一个函数</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927710.png" alt="img"></p><p>这里我们将这一串代码封装为一个函数reactive, 我们创建的对象就可以作为参数传递进去, 那么这个对象的所有属性就能被监听到了, 然后我们<strong>返回一个被监听的对象</strong></p><p>注意 : 需要返回这个对象哈, 别搞忘了</p><p>然后我们在创建对象时使用这个函数, 那么对象的所有属性就能被监听到了</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927717.png" alt="img"></p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927766.png" alt="img"></p><p>以上都是vue2响应式原理(也就是defineProperty), 接下来我们用vue3对代码进行重构</p><p>特别easy</p><h2 id="6-vue3-监听对象-proxy"><a href="#6-vue3-监听对象-proxy" class="headerlink" title="6. vue3__监听对象__proxy"></a>6. vue3__监听对象__proxy</h2><p>我们直接将</p><p>Object.defineProperty</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927710.png" alt="img"></p><p>这部分代码改成</p><p>proxy</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927876.png" alt="img"></p><p>在我们调用了Proxy的get捕获器时, 收集依赖</p><p>因为如果一个函数中使用了某个对象的key，那么它应该被收集依赖；</p><p>这部分代码即可</p><p>都是学过的东西 , 忘了就翻翻前面的笔记 </p><h2 id="7-完整响应式代码"><a href="#7-完整响应式代码" class="headerlink" title="7. 完整响应式代码"></a>7. 完整响应式代码</h2><p>完整响应式代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Depend</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()<br>  &#125;<br><br>  <span class="hljs-title function_">addDepend</span>(<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-keyword">if</span> (fn) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span>.<span class="hljs-title function_">add</span>(fn)<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-title function_">depend</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (reactiveFn) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span>.<span class="hljs-title function_">add</span>(reactiveFn)<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-title function_">notify</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> &#123;<br>      <span class="hljs-title function_">fn</span>()<br>    &#125;)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> reactiveFn = <span class="hljs-literal">null</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">watchFn</span>(<span class="hljs-params">fn</span>) &#123;<br>  reactiveFn = fn<br>  <span class="hljs-title function_">fn</span>()<br>  reactiveFn = <span class="hljs-literal">null</span><br>&#125;<br><br><span class="hljs-keyword">const</span> objMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>()<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getDepend</span>(<span class="hljs-params">obj, key</span>) &#123;<br>  <span class="hljs-comment">// 1.根据对象obj, 找到对应的map对象</span><br>  <span class="hljs-keyword">let</span> map = objMap.<span class="hljs-title function_">get</span>(obj)<br>  <span class="hljs-keyword">if</span> (!map) &#123;<br>    map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br>    objMap.<span class="hljs-title function_">set</span>(obj, map)<br>  &#125;<br><br>  <span class="hljs-comment">// 2.根据key, 找到对应的depend对象</span><br>  <span class="hljs-keyword">let</span> dep = map.<span class="hljs-title function_">get</span>(key)<br>  <span class="hljs-keyword">if</span> (!dep) &#123;<br>    dep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Depend</span>()<br>    map.<span class="hljs-title function_">set</span>(key, dep)<br>  &#125;<br>  <span class="hljs-keyword">return</span> dep<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">reactive</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">const</span> objProxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;<br>    <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">target, key, newValue, receiver</span>) &#123;<br>      <span class="hljs-comment">// target[key] = newValue</span><br>      <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, newValue, receiver)<br>      <span class="hljs-keyword">const</span> dep = <span class="hljs-title function_">getDepend</span>(target, key)<br>      dep.<span class="hljs-title function_">notify</span>()<br>    &#125;,<br>    <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">target, key, receiver</span>) &#123;<br>      <span class="hljs-keyword">const</span> dep = <span class="hljs-title function_">getDepend</span>(target, key)<br>      dep.<span class="hljs-title function_">depend</span>()<br>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver)<br>    &#125;<br>  &#125;)<br>  <span class="hljs-keyword">return</span> objProxy <br>&#125;<br></code></pre></td></tr></table></figure><p>业务代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = <span class="hljs-title function_">reactive</span>(&#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>  <span class="hljs-attr">address</span>: <span class="hljs-string">&quot;广州市&quot;</span><br>&#125;)<br><br><span class="hljs-title function_">watchFn</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">name</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">age</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">age</span>)<br>&#125;)<br><br><span class="hljs-comment">// 修改name</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;--------------&quot;</span>)<br><span class="hljs-comment">// obj.name = &quot;kobe&quot;</span><br>obj.<span class="hljs-property">age</span> = <span class="hljs-number">20</span><br><span class="hljs-comment">// obj.address = &quot;上海市&quot;</span><br><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;=============== user =================&quot;</span>)<br><span class="hljs-keyword">const</span> user = <span class="hljs-title function_">reactive</span>(&#123;<br>  <span class="hljs-attr">nickname</span>: <span class="hljs-string">&quot;abc&quot;</span>,<br>  <span class="hljs-attr">level</span>: <span class="hljs-number">100</span><br>&#125;)<br><br><span class="hljs-title function_">watchFn</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;nickname:&quot;</span>, user.<span class="hljs-property">nickname</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;level:&quot;</span>, user.<span class="hljs-property">level</span>)<br>&#125;)<br><br>user.<span class="hljs-property">nickname</span> = <span class="hljs-string">&quot;cba&quot;</span><br></code></pre></td></tr></table></figure><p>执行结果</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927019.png" alt="img"></p><p>总结 : </p><ul><li>Vue3主要是通过Proxy来监听数据的变化以及收集相关的依赖的；</li><li>ue2中通过我们前面学习过的Object.defineProerty的方式来实现对象属性的监听；</li></ul>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>后端抽象理解</title>
    <link href="/2023/06/19/%E5%90%8E%E7%AB%AF%E5%BD%A2%E8%B1%A1%E7%90%86%E8%A7%A3%E7%AF%87/"/>
    <url>/2023/06/19/%E5%90%8E%E7%AB%AF%E5%BD%A2%E8%B1%A1%E7%90%86%E8%A7%A3%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h2 id="如何形象的理解-spring"><a href="#如何形象的理解-spring" class="headerlink" title="如何形象的理解 spring?"></a>如何形象的理解 spring?</h2><blockquote><p>依赖注入框架，帮助你管理 Java 对象，集成一些其他的内容</p></blockquote><p>让我们用通俗易懂的语言来解释Spring框架。</p><p>想象一下你在组装一台电脑。你需要连接各个硬件组件，如CPU、内存、硬盘等，并确保它们能够协同工作。Spring框架就像是电脑组装的助手，它帮助你管理和组织各个组件，并提供一些便捷的功能。</p><p>在这个比喻中：</p><ul><li>你可以将硬件组件看作是你的应用程序中的不同部分，如服务、数据访问对象、控制器等。</li><li>Spring框架则扮演了管理和组织这些组件的角色，确保它们能够协同工作。</li><li>框架提供了一种便捷的方式来连接和配置这些组件，就像你将硬件组件插入主板上的插槽一样。</li><li>框架还提供了一些额外的功能，如依赖注入（DI），就像是帮助你将各个硬件组件连接在一起，使它们可以相互通信和协作。</li><li>你可以使用框架提供的功能来实现业务逻辑，就像在电脑上运行软件应用程序一样。</li></ul><p>总的来说，Spring框架是一个帮助你管理和组织应用程序组件的工具。它简化了开发过程，提供了便捷的连接和配置方式，并提供了一些额外的功能来增强应用程序的灵活性和可维护性。使用Spring框架，你可以更轻松地构建和管理复杂的应用程序，并提供高效、可靠的功能。</p><h2 id="如何形象的理解依赖注入"><a href="#如何形象的理解依赖注入" class="headerlink" title="如何形象的理解依赖注入?"></a>如何形象的理解依赖注入?</h2><p>让我们用一个日常生活的比喻来形象地理解依赖注入。</p><p>假设你是一个厨师，需要准备一道菜。为了完成这道菜，你需要使用一些食材，如蔬菜、肉类、调味料等。</p><p>在没有依赖注入的情况下，你可能需要自己去购买这些食材，并将它们携带到厨房。这意味着你要亲自管理食材的采购、携带和使用过程。这可能会增加你的负担和工作量，还可能导致混乱和错误。</p><p>现在，假设你有一个厨师助手，他负责为你提供所需的食材。这就是依赖注入的概念在生活中的体现。</p><p>在这个比喻中：</p><ul><li>你是主厨，负责菜的制作，即应用程序的核心逻辑。</li><li>食材是你所需要的依赖对象，如服务、数据访问对象等。</li><li>厨师助手是依赖注入的机制，负责将食材提供给你，以供你使用。</li><li>依赖注入让你从繁琐的采购和管理任务中解放出来，专注于菜的制作。</li></ul><p>在编程中，依赖注入的概念类似。它是一种设计模式，通过在需要使用某个对象的地方将其注入（提供）给目标对象，减少了目标对象与依赖对象之间的耦合性。这样，目标对象可以专注于自己的业务逻辑，而不需要关心如何创建或获取依赖对象。</p><p>总而言之，依赖注入就像是一个厨师助手为你提供所需食材一样，它让你从繁琐的依赖管理中解放出来，让你的代码更加清晰、模块化和可维护。它使代码的组织和协作更加灵活和简单。</p><h2 id="如何形象的理解-springmvc"><a href="#如何形象的理解-springmvc" class="headerlink" title="如何形象的理解 springmvc ?"></a>如何形象的理解 springmvc ?</h2><blockquote><p>web 框架，提供接口访问、restful接口等能力</p></blockquote><p>让我们用一个类比来形象地理解Spring MVC。</p><p>假设你是一家快餐店的服务员，负责接待顾客并处理他们的点餐请求。</p><p>在没有Spring MVC的情况下，你可能需要一个人来处理所有的任务，包括接待顾客、记录点餐、取餐、上菜等。这样的情况下，你可能会感到忙碌和混乱，很难有效地处理顾客的需求。</p><p>现在，假设快餐店引入了Spring MVC框架来协助你进行工作。这就是Spring MVC的作用。</p><p>在这个比喻中：</p><ul><li>你是服务员，负责处理顾客的点餐请求，即处理Web请求的控制器。</li><li>顾客是Web应用的用户，发送请求给服务器。</li><li>Spring MVC框架则扮演了一个协调者的角色，负责接收请求、路由请求到适当的控制器，并将结果返回给用户。</li><li>框架提供了一些便捷的功能，如请求路由、参数绑定、视图渲染等，使你能够更加高效地处理顾客的点餐请求。</li></ul><p>使用Spring MVC，你可以将业务逻辑分散到不同的控制器中，每个控制器负责处理特定类型的请求。这样，你可以更好地组织和管理代码，并提供更好的用户体验。</p><p>总而言之，Spring MVC就像是一个服务员的协助工具，帮助你更好地处理Web请求，分散和管理业务逻辑，并提供高效的处理方式。它简化了开发过程，提供了便捷的路由和控制功能，使得Web应用的开发更加模块化、可维护和可扩展。</p><h2 id="如何形象的理解-mybatis"><a href="#如何形象的理解-mybatis" class="headerlink" title="如何形象的理解 mybatis ?"></a>如何形象的理解 mybatis ?</h2><blockquote><p>Java 操作数据库的框架，持久层框架，对 jdbc 的封装</p></blockquote><p>让我们用一个类比来形象地理解MyBatis。</p><p>假设你是一个图书管理员，负责管理图书馆的图书和借阅记录。</p><p>在没有MyBatis的情况下，你可能需要手动管理图书和借阅记录的存储、查询和更新。这意味着你需要编写大量的SQL语句来执行数据库操作，并处理与数据库的连接、事务等细节。这样的工作可能会非常繁琐和复杂。</p><p>现在，假设你有一个智能助手，他帮助你<strong>自动化处理图书和借阅记录的管理</strong>。这就是MyBatis的作用。</p><p>在这个比喻中：</p><ul><li>你是图书管理员，负责处理图书和借阅记录的管理，即数据访问对象（DAO）。</li><li>图书和借阅记录是数据库中的数据，需要进行存储、查询和更新。</li><li>MyBatis框架则扮演了一个智能助手的角色，负责处理与数据库的交互和操作。</li><li>框架提供了一种便捷的方式来映射数据库表和<code>Java</code>对象，并提供了一些SQL执行和结果映射的功能。</li></ul><p>使用MyBatis，你可以通过简单的配置文件和注解来定义SQL语句和参数映射，而无需手动编写大量的SQL语句。框架会自动处理与数据库的连接、事务和结果集的映射，让你更专注于业务逻辑的实现。</p><p>总而言之，MyBatis就像是一个智能助手，帮助你简化和自动化与数据库的交互和操作。它减少了手动编写SQL语句的工作量，提供了便捷的数据访问方式，并帮助你更好地组织和管理数据库操作的代码。使用MyBatis，你可以更轻松地进行数据库操作，并提供高效和可维护的数据访问层。</p><h2 id="如何形象的理解-mybatis-plus"><a href="#如何形象的理解-mybatis-plus" class="headerlink" title="如何形象的理解 mybatis - plus ?"></a>如何形象的理解 mybatis - plus ?</h2><blockquote><p>对 mybatis 的增强，不用写 sql 也能实现增删改查</p></blockquote><p>让我们用一个类比来形象地理解MyBatis-Plus。</p><p>假设你是一位室内设计师，负责设计客户的家居装修方案。</p><p>在没有MyBatis-Plus的情况下，你可能需要从头开始设计和实施每个客户的装修方案。这意味着你需要考虑并编写各种细节，如房间布局、材料选择、色彩搭配等。这样的工作可能会非常繁琐和耗时。</p><p>现在，假设你有一个装修助手，他为你提供了一套标准化的装修方案和设计模板。这就是MyBatis-Plus的作用。</p><p>在这个比喻中：</p><ul><li>你是室内设计师，负责设计和实施装修方案，即数据访问对象（DAO）。</li><li>客户是数据库中的表，每个客户对应一张表，需要进行增删改查等操作。</li><li>MyBatis-Plus框架则扮演了一个装修助手的角色，提供了一系列标准化的操作和设计模板。</li><li>框架提供了一种简单的方式来定义实体类和数据库表的映射关系，并提供了一些通用的数据访问功能。</li></ul><p>使用MyBatis-Plus，你可以通过简单的注解和配置来定义实体类和数据库表的映射关系，而无需手动编写繁琐的SQL语句。框架会自动处理与数据库的连接、事务和CRUD操作，让你更专注于业务逻辑的实现。</p><p>总而言之，MyBatis-Plus就像是一个装修助手，为你提供了一套标准化的操作和设计模板。它简化了数据访问层的开发过程，提供了便捷的数据访问方式，并帮助你更好地组织和管理数据库操作的代码。使用MyBatis-Plus，你可以更轻松地进行数据库操作，并提供高效和可维护的数据访问层。</p><h2 id="如何形象的理解-springboot"><a href="#如何形象的理解-springboot" class="headerlink" title="如何形象的理解 springboot ?"></a>如何形象的理解 springboot ?</h2><blockquote><p>快速启动 &#x2F; 快速集成项目。不用自己管理 spring 配置，不用自己整合各种框架</p></blockquote><p>让我们用一个类比来形象地理解Spring Boot。</p><p>假设你是一位厨师，需要准备一道复杂的菜肴。</p><p>在没有Spring Boot的情况下，你需要从头开始购买食材、准备厨房、研究菜谱、调整烹饪参数等。这意味着你需要花费大量的时间和精力来完成每个环节，才能最终完成菜肴的制作。</p><p>现在，假设你有一套现成的厨房设备和标准化的食谱，这就是Spring Boot的作用。</p><p>在这个比喻中：</p><ul><li>你是厨师，负责设计和制作菜肴，即应用程序的开发者。</li><li>菜肴是应用程序，需要进行配置、开发和部署等操作。</li><li>Spring Boot框架则扮演了一个现成的厨房设备和标准化的食谱的角色，提供了一套预定义的配置和开发规范。</li><li>框架帮助你简化了应用程序的搭建和开发过程，提供了自动配置、内嵌服务器、依赖管理等功能。</li></ul><p>使用Spring Boot，你可以通过简单的配置和约定来快速搭建和开发应用程序，无需手动处理繁琐的配置和依赖管理。框架会自动处理与服务器的集成、配置的加载和管理，让你更专注于业务逻辑的实现。</p><p>总而言之，Spring Boot就像是一个现成的厨房设备和标准化的食谱，帮助你快速搭建和开发应用程序。它简化了应用程序的搭建和开发过程，提供了自动化的配置和依赖管理，让你能够更轻松地构建高效和可维护的应用程序。</p><blockquote><p>Spring Boot是Spring的一个子项目，旨在简化Spring应用程序的搭建和开发过程，通过自动配置和约定大于配置的原则，提供了一套预定义的规范和配置，使得开发者能够更快速地创建独立的、自包含的应用程序。</p></blockquote><h2 id="什么是-junit-单元测试库"><a href="#什么是-junit-单元测试库" class="headerlink" title="什么是 junit 单元测试库?"></a>什么是 junit 单元测试库?</h2><p>JUnit是一个Java单元测试库，用于编写和执行单元测试。它提供了一组用于编写测试用例的注解和断言方法，可以帮助开发者进行自动化的单元测试。</p><p>JUnit的主要作用是帮助开发者验证代码的正确性和稳定性。通过编写单元测试用例，开发者可以针对代码的不同模块、方法或类编写测试代码，用于验证其预期行为是否符合预期。单元测试可以帮助开发者发现和修复代码中的bug，减少代码出错的可能性，并提高代码的质量和可维护性。</p><p>JUnit提供了一些常用的注解，如<code>@Test</code>用于标记测试方法，<code>@Before</code>和<code>@After</code>用于在测试方法执行前后执行一些初始化和清理操作，<code>@BeforeClass</code>和<code>@AfterClass</code>用于在所有测试方法执行前后执行一次初始化和清理操作。此外，JUnit还提供了一系列的断言方法，如<code>assertEquals</code>、<code>assertTrue</code>、<code>assertFalse</code>等，用于验证测试结果是否符合预期。</p><p>使用JUnit，开发者可以编写简洁、可重复运行的测试用例，并通过运行JUnit测试来自动执行这些测试用例，获取测试结果。这样可以提高开发效率，减少手动测试的工作量，并保证代码的可靠性和稳定性。</p><p>总之，JUnit是一个Java单元测试库，它提供了注解和断言方法，用于编写和执行单元测试，帮助开发者验证代码的正确性和稳定性，并提高代码的质量和可维护性。</p><h2 id="关于用户登录状态管理的详细过程："><a href="#关于用户登录状态管理的详细过程：" class="headerlink" title="关于用户登录状态管理的详细过程："></a>关于用户登录状态管理的详细过程：</h2><ol><li><p>客户端与服务器建立连接后，服务器为客户端创建一个会话（session），并返回会话的标识符（session ID）给客户端。这个会话可以是匿名会话，表示客户端尚未登录。</p></li><li><p>当用户成功登录时，服务器会为该用户创建一个具有用户信息的会话对象，并将会话对象存储在服务器端。通常会将用户信息存储在会话对象的属性中，例如，将用户ID、用户名等信息存储为会话属性。</p></li><li><p>服务器将会话的标识符（session ID）发送给客户端，并要求客户端将其存储为一个 cookie。这个 cookie 的作用是在客户端保存会话标识符，以便在后续的请求中携带该会话标识符。</p></li><li><p>客户端接收到服务器返回的会话标识符后，将其存储为 cookie，保存在客户端浏览器中。</p></li><li><p>当客户端再次向服务器发送请求时，在请求头中会包含该域名下的所有 cookie 信息，包括会话标识符。</p></li><li><p>服务器接收到请求后，从请求头中提取出会话标识符，通过该标识符在服务器端查找对应的会话对象。</p></li><li><p>服务器根据会话标识符找到对应的会话对象后，可以从会话对象中获取存储的用户信息，如用户的登录名等。</p></li></ol><p>总结：通过将会话标识符存储在客户端的 cookie 中，客户端在后续的请求中携带该会话标识符，使服务器能够识别客户端，并通过会话对象管理用户的登录状态和其他相关信息。</p><p>需要注意的是，上述过程是一种常见的用户登录状态管理方式，但实际上，还有其他方法可以实现用户登录状态的管理，如使用 JSON Web Token (JWT) 等。具体的实现方式可能因框架和技术选型而有所差异。</p><h2 id="简单说明cookie和session"><a href="#简单说明cookie和session" class="headerlink" title="简单说明cookie和session"></a><strong>简单说明cookie和session</strong></h2><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcode">🪔 以最常见的登陆案例讲解cookie的使用过程：<br>（<span class="hljs-number">1</span>）首先用户在客户端浏览器向服务器首次发起登陆请求<br>（<span class="hljs-number">2</span>）登陆成功后，服务端会把登陆的用户信息设置在cookie 中，并将cookie返回给客户端浏览器<br>（<span class="hljs-number">3</span>）客户端浏览器接收到 cookie 请求后，会把 cookie 保存到本地<span class="hljs-comment">(可能是内存，也可能是磁盘，看具体使用情况而定)</span><br>（<span class="hljs-number">4</span>）以后再次访问该 web 应用时，客户端浏览器就会把本地的 cookie 带上，这样服务端就能根据 cookie 获得用户信息了<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">🪔 同样以登陆案例为例子讲解 <span class="hljs-keyword">session</span> 的使用过程：<br>（<span class="hljs-number">1</span>）首先用户在客户端浏览器发起登陆请求<br>（<span class="hljs-number">2</span>）登陆成功后，服务端会把用户信息保存在服务端，并返回一个唯一的 <span class="hljs-keyword">session</span> 标识给客户端浏览器。<br>（<span class="hljs-number">3</span>）客户端浏览器会把这个唯一的 <span class="hljs-keyword">session</span> 标识保存在起来<br>（<span class="hljs-number">4</span>）以后再次访问 web 应用时，客户端浏览器会把这个唯一的 <span class="hljs-keyword">session</span> 标识带上，这样服务端就能根据这个唯一标识找到用户信息。<br></code></pre></td></tr></table></figure><p><strong>看到这里可能会引起疑问：把唯一的 session 标识返回给客户端浏览器，然后保存起来，以后访问时带上，这难道不是 cookie 吗？</strong></p><blockquote><p>没错，session 只是一种会话机制，在许多 web 应用中，session 机制就是通过 cookie 来实现的。也就是说它只是使用了 cookie 的功能，并不是使用 cookie完成会话保存。与 cookie 在保存客户端保存会话的机制相反，session 通过 cookie 的功能把会话信息保存到了服务端。</p></blockquote><p><strong>session和cookie有什么区别？</strong></p><ol><li><p>cookie 是浏览器提供的一种缓存机制，它可以用于维持客户端与服务端之间的会话</p></li><li><p>session 指的是维持客户端与服务端会话的一种机制，它可以通过 cookie 实现，也可以通过别的手段实现。</p></li><li><p>如果用 cookie 实现会话，那么会话会保存在客户端浏览器中</p></li><li><p>而 session 机制提供的会话是保存在服务端的。</p></li></ol><p><strong>举个小例子说明Cookie和Session之间的区别和联系</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">🦥 <br>假如一个咖啡店有喝五杯赠一杯咖啡的优惠，但是一次性消费<span class="hljs-number">5</span>杯咖啡的客人很少，这时就需要某种方式来记录某位顾客的消费数量。无外乎下面的几种方案：<br><span class="hljs-number">1</span>、该店的店员很厉害，能记住每位顾客的消费数量，只要顾客一走进咖啡店，店员就知道该怎么对待了。这种做法就是协议本身支持状态。但是<span class="hljs-keyword">http</span>协议本身是无状态的。<br><span class="hljs-number">2</span>、发给顾客一张卡片，上面记录着消费的数量，一般还有个有效期限。每次消费时，如果顾客出示这张卡片，则此次消费就会与以前或以后的消费相联系起来。这种做法就是在客户端保持状态，也就是cookie，顾客就相当于浏览器。<br><span class="hljs-number">3</span>、发给顾客一张会员卡，除了卡号之外什么信息也不纪录，每次消费时，如果顾客出示该卡片，则店员在店里的记录本上找到这个卡号对应的记录添加一些消费信息。这种做法就是在服务器端保持状态。<br></code></pre></td></tr></table></figure><h2 id="正向代理和反向代理的区别是什么"><a href="#正向代理和反向代理的区别是什么" class="headerlink" title="正向代理和反向代理的区别是什么?"></a>正向代理和反向代理的区别是什么?</h2><p><a href="https://www.cnblogs.com/taostaryu/p/10547132.html">原文</a></p><blockquote><p>代理其实就是一个中介，A和B本来可以直连，中间插入一个C，C就是中介。<br>刚开始的时候，代理多数是帮助内网client访问外网server用的<br>后来出现了反向代理，”反向”这个词在这儿的意思其实是指方向相反，即代理将来自外网客户端的请求转发到内网服务器，从外到内.</p></blockquote><h4 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h4><p>正向代理类似一个跳板机，代理访问外部资源 .</p><p>比如我们国内访问谷歌，直接访问访问不到，我们可以通过一个正向代理服务器，请求发到代理服，代理服务器能够访问谷歌，这样由代理去谷歌取到返回数据，再返回给我们，这样我们就能访问谷歌了 .</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202306181011210.png" alt="image-20230618101113110"></p><p><strong>正向代理的用途：</strong></p><ol><li>访问原来无法访问的资源，如google</li><li>可以做缓存，加速访问资源</li><li>对客户端访问授权，上网进行认证</li><li>代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息</li></ol><h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><p>反向代理（Reverse Proxy）实际运行方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202306181011725.png" alt="image-20230618101124689"></p><p><strong>反向代理的作用：</strong></p><ol><li>保证内网的安全，阻止web攻击，大型网站，通常将反向代理作为公网访问地址，Web服务器是内网 . </li><li>负载均衡，通过反向代理服务器来优化网站的负载</li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>正向代理即是客户端代理, 代理客户端, 服务端不知道实际发起请求的客户端.</strong></p><p><strong>反向代理即是服务端代理, 代理服务端, 客户端不知道实际提供服务的服务端</strong></p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202306181014100.png" alt="image-20230618101447052"></p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202306181013811.png" alt="image-20230618101318766"></p><h2 id="java项目中target文件是什么文件"><a href="#java项目中target文件是什么文件" class="headerlink" title="java项目中target文件是什么文件?"></a>java项目中target文件是什么文件?</h2><p><code>target</code> 文件夹通常是在构建过程中由构建工具生成的默认输出目录，例如 Maven 或 Gradle。在 Maven 项目中，<code>target</code> 文件夹用于存储编译后的类文件、资源文件和生成的构建产物（如 JAR 文件）等。</p><p>当你执行 Maven 的构建命令（如 <code>mvn package</code>）时，Maven 会将项目的源代码编译成字节码，并将编译后的类文件和其他资源文件输出到 <code>target</code> 文件夹中。此外，构建工具还会在 <code>target</code> 文件夹中生成其他与构建过程相关的临时文件和日志文件。</p><p>通常情况下，<code>target</code> 文件夹的内容应该是可以被忽略的，不应该被版本控制系统（如 Git）所跟踪。这是因为 <code>target</code> 文件夹的内容可以通过重新构建项目来生成，而不需要将生成的文件包含在版本控制中。</p><p>需要注意的是，<code>target</code> 文件夹的名称可以在 Maven 或 Gradle 的配置文件中进行自定义，但通常情况下，<code>target</code> 是默认的输出目录名称。</p><h2 id="java项目中controller文件的作用是什么"><a href="#java项目中controller文件的作用是什么" class="headerlink" title="java项目中controller文件的作用是什么?"></a>java项目中controller文件的作用是什么?</h2><p>在Java项目中，控制器（Controller）的作用是处理客户端发起的请求并返回响应。它充当了应用程序的入口点，协调不同的组件来完成特定的业务逻辑。控制器主要负责以下几个方面的工作：</p><ol><li><p><strong>接收请求</strong>：控制器监听特定的URL路径或请求方法，并接收来自客户端的请求。它充当了请求的入口，接收并解析请求参数、路径、请求体等信息。</p></li><li><p><strong>处理业务逻辑</strong>：一旦接收到请求，控制器会调用相应的服务（Service）或业务逻辑组件来处理具体的业务逻辑。它可以从数据库、外部服务或其他组件中获取数据，并对数据进行处理、转换或验证。</p></li><li><p><strong>调用服务层</strong>：控制器通常与服务层（Service Layer）进行交互，通过依赖注入或手动创建实例来调用服务层提供的方法。服务层负责封装业务逻辑，处理数据持久化、事务管理、业务规则等操作。</p></li><li><p><strong>返回响应</strong>：控制器根据请求处理的结果生成相应的响应，并将其返回给客户端。响应可以是HTML页面、JSON数据、文件下载等形式。控制器负责将响应数据封装成适当的格式，并设置响应头和状态码。</p></li><li><p><strong>路由和URL映射</strong>：控制器根据不同的URL路径和请求方法来映射到相应的处理方法。它通过使用路由配置或注解来定义URL与处理方法之间的映射关系，以便将请求正确地分发到对应的处理方法。</p></li><li><p><strong>控制流程和验证</strong>：控制器可以处理用户输入的验证和数据校验，确保数据的合法性和完整性。它还可以根据业务需求决定请求的流程，例如重定向、转发或错误处理等。</p></li></ol><p>总之，控制器在Java项目中起着连接用户界面、业务逻辑和数据持久化层的桥梁作用。它接收并处理请求，协调其他组件完成特定的业务功能，并将处理结果返回给客户端。控制器的设计良好与否对于项目的可维护性、可测试性和灵活性具有重要影响。</p><h2 id="java项目里mapper的作用是什么"><a href="#java项目里mapper的作用是什么" class="headerlink" title="java项目里mapper的作用是什么?"></a>java项目里mapper的作用是什么?</h2><p>在Java项目中，Mapper（或称为数据访问对象，DAO）的作用是封装对数据库的访问操作。它充当了应用程序和数据库之间的桥梁，负责执行数据库查询、更新、插入和删除等操作。Mapper的主要作用如下：</p><ol><li><p><strong>数据库访问</strong>：Mapper负责与数据库进行交互，执行SQL语句或调用数据库的API来完成数据的读取、写入和修改操作。它封装了对数据库的底层访问细节，使开发人员可以以面向对象的方式操作数据库，而无需直接编写原始的SQL语句。</p></li><li><p><strong>对象关系映射</strong>（ORM）：Mapper将数据库中的表和实体对象进行映射，实现了对象与关系数据库之间的转换。它通过配置或注解定义实体类和数据库表之间的映射关系，使开发人员可以以面向对象的方式操作数据，而不需要关注数据库的具体实现细节。</p></li><li><p><strong>数据库事务管理</strong>：Mapper可以处理数据库事务，确保一组数据库操作要么全部成功提交，要么全部回滚。它提供了事务的开始、提交和回滚等操作，使开发人员能够在一致的状态下操作数据库，保持数据的完整性和一致性。</p></li><li><p><strong>查询优化和性能调优</strong>：Mapper可以通过编写高效的SQL语句或使用数据库的特定特性来优化查询性能。它可以利用数据库的索引、缓存机制、分页查询等功能来提高数据访问的效率，减少数据库的负载和响应时间。</p></li><li><p><strong>数据库访问的抽象层</strong>：Mapper提供了对数据库访问的高层抽象，使开发人员能够以面向对象的方式对数据进行操作，而不必关注数据库的细节。它提供了一组通用的CRUD（创建、读取、更新、删除）方法，简化了对数据的操作。</p></li></ol><p>总之，Mapper在Java项目中起着与数据库交互的角色，负责执行数据库操作、实现对象与数据库之间的映射以及提供事务管理等功能。它使开发人员能够以面向对象的方式操作数据库，提高了开发效率和代码的可维护性。通过使用Mapper，可以将数据库操作与业务逻辑解耦，提供了灵活性和可扩展性，使得数据访问更加方便和高效。</p><h2 id="IService和BaseMapper它们的区别是什么"><a href="#IService和BaseMapper它们的区别是什么" class="headerlink" title="IService和BaseMapper它们的区别是什么?"></a>IService<T>和BaseMapper<T>它们的区别是什么?</h2><p><code>IService&lt;T&gt;</code> 和 <code>BaseMapper&lt;T&gt;</code> 是 MyBatis-Plus 框架中的两个核心接口，它们在功能和作用上有一些区别。</p><p><code>IService&lt;T&gt;</code> 接口是用于定义通用的业务操作方法的接口，提供了对数据库表进行常见的增删改查操作的方法定义。它包含了一系列的方法，如保存实体对象、删除记录、更新记录、查询记录等。开发人员可以通过实现 <code>IService&lt;T&gt;</code> 接口或继承该接口来自定义业务逻辑操作。</p><p><code>BaseMapper&lt;T&gt;</code> 接口是 MyBatis-Plus 框架提供的基础映射器接口，用于定义数据库表的基本操作方法。它继承了 MyBatis 中的 <code>Mapper&lt;T&gt;</code> 接口，并额外添加了一些常见的数据库操作方法，如插入记录、删除记录、更新记录、查询记录等。<code>BaseMapper&lt;T&gt;</code> 接口提供了对数据库表进行基本操作的能力。</p><p>区别总结如下：</p><ul><li><code>IService&lt;T&gt;</code> 是定义通用业务操作方法的接口，用于封装和定义业务逻辑，提供了更高层次的抽象，使得业务逻辑更加简洁和易于维护。</li><li><code>BaseMapper&lt;T&gt;</code> 是基础映射器接口，用于定义数据库表的基本操作方法，提供了对数据库的增删改查能力。</li><li><code>IService&lt;T&gt;</code> 可以自定义业务逻辑方法，对数据库操作进行封装，而 <code>BaseMapper&lt;T&gt;</code> 主要提供了一些基本的数据库操作方法。</li><li><code>IService&lt;T&gt;</code> 可以根据具体业务需求进行扩展和定制，而 <code>BaseMapper&lt;T&gt;</code> 主要用于执行基本的数据库操作。</li></ul><p>在实际开发中，通常会同时使用 <code>IService&lt;T&gt;</code> 和 <code>BaseMapper&lt;T&gt;</code> 接口。<code>IService&lt;T&gt;</code> 可以作为业务层的接口，定义具体业务操作方法，而 <code>BaseMapper&lt;T&gt;</code> 则作为数据访问层的接口，提供基本的数据库操作方法。这样可以将业务逻辑和数据访问操作进行解耦，并提高代码的可读性和可维护性。</p><h2 id="Autowired注解的作用是什么"><a href="#Autowired注解的作用是什么" class="headerlink" title="@Autowired注解的作用是什么?"></a>@Autowired注解的作用是什么?</h2><p><code>@Autowired</code> 注解是 Spring 框架提供的依赖注入注解，用于自动装配对象。</p><p>作用如下：</p><ol><li>自动装配依赖对象：<code>@Autowired</code> 注解可以自动将标注的属性、构造函数或方法参数与容器中匹配的 bean 进行关联，完成依赖对象的注入。</li><li>简化配置：通过 <code>@Autowired</code> 注解，可以省去手动配置依赖对象的步骤，由 Spring 容器自动查找并注入所需的对象。</li><li>解决对象之间的耦合：通过依赖注入，对象之间的关系由容器管理，减少了对象之间的直接依赖，降低了耦合性，提高了代码的灵活性和可维护性。</li><li>提高代码的可测试性：使用依赖注入可以方便进行单元测试，可以轻松替换依赖对象或使用模拟对象进行测试。</li></ol><p>要注意的是，使用 <code>@Autowired</code> 注解进行自动装配时，需要保证容器中存在匹配的 bean 对象。如果存在多个匹配的 bean 对象，可以结合使用 <code>@Qualifier</code> 注解或通过指定 bean 的名称进行限定，以确定要注入的具体对象。</p><p>另外，<code>@Autowired</code> 注解可以用于字段、构造函数、Setter 方法以及一些特殊的注入场景，例如 <code>@Autowired</code> 与 <code>@Qualifier</code> 的组合使用，以及与 <code>@Value</code> 注解一起使用等。</p><p>当用户使用网上零食商城的零食分类模块时，以下是一个具体的流程示例：</p><ol><li>用户进入网上零食商城的零食分类页面。</li><li>用户提供分类条件，例如选择特定的食品类别、价格范围或品牌等。</li><li>用户点击”搜索”或类似的按钮，将输入条件传递给零食分类模块。</li><li>零食分类模块接收用户输入的条件。</li><li>模块开始处理用户输入的条件，进行以下步骤：<ul><li>分析用户选择的食品类别、价格范围或品牌等条件。</li><li>查询数据库或调用相关接口，获取与用户条件匹配的零食列表。</li><li>对零食列表进行筛选和排序，根据用户的排序要求或其他标准进行处理。</li><li>生成经过分类和排序的零食列表。</li></ul></li><li>零食分类模块将处理结果返回给用户界面。</li><li>用户界面展示分类结果，包括零食的名称、价格、图片等信息（O1）。</li><li>用户可以浏览所展示的零食列表，查看详细信息，并选择感兴趣的零食进行购买。</li><li>用户可以选择特定的分类结果，例如点击特定的分类标签。</li><li>用户界面将用户选择的分类结果传递给零食分类模块。</li><li>模块接收用户选择的分类结果并进行处理，展示与选择分类匹配的零食列表（O2）。</li><li>用户界面展示根据</li><li>用户选择的分类结果所筛选出的零食列表，供用户浏览和购买。</li><li>用户可以继续浏览和购买感兴趣的零食，或者返回重新选择分类条件。</li></ol>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>费曼学习法</title>
    <link href="/2023/06/10/%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95/"/>
    <url>/2023/06/10/%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="关于费曼学习法"><a href="#关于费曼学习法" class="headerlink" title="关于费曼学习法"></a>关于费曼学习法</h2><blockquote><p>前两天偶然间了解到了费曼学习法, 算是拓宽了我对学习方法的认知. </p><p>它可以简化为四个单词 </p></blockquote><p><code>Concept</code> (概念) – <code>Teach</code> (教给别人) – <code>Review</code> (回顾) – <code>Simplify</code> (简化)</p><ol><li>第一步 : 假装把一个知识(概念) 教给一个小孩子 .</li></ol><p>尽量用最基础的词汇, 以使得这些小孩子刚好能理解这些基本的概念和知识, 当你卡壳了, 也就是不知道如何解释某个概念或与其它知识的联系的时候 – 预示着学习的机会到来了. </p><ol start="2"><li>第二步 : 回顾</li></ol><p>你已经发现了你大脑知识库的边缘, 懂得自己能力的界限也是一种能力. 你需要回到自己的原始材料, 重新学习, 直到你可以用基本的术语解释这一概念. </p><ol start="3"><li>第三步: 将语言条理化 , 简化</li></ol><p>要保证你的手上有一套自己的手写笔记 , 检查一下确保自己没有从原材料中借用任何行话. 请阅读一遍自己的手写笔记 , 如果听起来比较混乱 , 这意味着你还需要更深入的理解该领域 . 这时候你需要重新回到第二步 —— 一直重复直到你的手写笔记解释得通俗易懂且有条理性 . </p><ol start="4"><li>第四步(可选) : 传授</li></ol><p>如果你真的确保你的理解没什么问题, 检测知识最终的途径就是你能有能力把它传播给另一个人 , 如果没有这样一个具象的人 , 那你可以将自己的笔记分享出去 , 通过大家的反馈以使得自己对知识的理解更加通透. </p><blockquote><p>昨天基本上一整天时间都花在搭建博客上了, 这个学习方法也没有得到应用, 从今儿开始, 尝试这种学习方法~🎆</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>日常琐碎</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习方法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的第一篇博客</title>
    <link href="/2023/06/09/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/06/09/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="我的第一篇博客"><a href="#我的第一篇博客" class="headerlink" title="我的第一篇博客"></a>我的第一篇博客</h1><blockquote><p>分享琐碎</p></blockquote><p>忙里偷闲, 或者说闲来无事吧, 实际上, 时间已经来到期末, 可是呢, 我还是保留着对技术的疯狂热情, 搭建这个博客是因为偶然间在星球冲浪时, 看见一位大佬所写的hexo搭建博客系列. 正是这一契机让我花了大半天时间搞了这一个博客.</p><p>其实之前也有花时间搭过一个博客, 是通过 <code>VuePress</code> 搭建的 </p><p>(刚刚搞了好久的图床哈哈哈哈哈哈哈哈哈哈, 主要是通过 阿里云 + Pikgo + Typora 构建的)<br><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202306092321545.png" alt="image-20230609232105109"></p><p>这界面还是略显花哨 , 相比呢以下界面就显得非常滴简约好看</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202306092322286.png" alt="image-20230609232220960"> </p><p>话不多说, 准备优化博客咯 —— hh</p>]]></content>
    
    
    <categories>
      
      <category>日常琐碎</category>
      
    </categories>
    
    
    <tags>
      
      <tag>感想</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
