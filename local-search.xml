<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>PC端/移动端适配如何进行配置?</title>
    <link href="/2023/12/19/%E8%AE%B2%E8%AE%B2%E7%A7%BB%E5%8A%A8%E7%AB%AFPC%E7%AB%AF%E9%80%82%E9%85%8D/"/>
    <url>/2023/12/19/%E8%AE%B2%E8%AE%B2%E7%A7%BB%E5%8A%A8%E7%AB%AFPC%E7%AB%AF%E9%80%82%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<blockquote><p>参考文章</p></blockquote><p><a href="https://juejin.cn/post/7277875605538226195?searchId=20231219131403F17CD4077B31DCD81722">5 分钟过下移动端适配方案 - 掘金</a></p><p><a href="https://juejin.cn/post/7278646930174165050?searchId=2023121919035647D3085918D03802F7DF#heading-8">一篇文章搞懂，vue中pc端与移动端适配解决方案(亲测有效) - 掘金</a></p><hr><h2 id="移动端适配"><a href="#移动端适配" class="headerlink" title="移动端适配"></a>移动端适配</h2><hr><h3 id="媒体查询方案"><a href="#媒体查询方案" class="headerlink" title="媒体查询方案"></a>媒体查询方案</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* &lt;375px */</span><br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">max-width</span>:<span class="hljs-number">375px</span>) &#123; <br>  <span class="hljs-selector-class">.box</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  &#125;<br>&#125;<br><span class="hljs-comment">/* &gt;=375px and &lt;450px */</span><br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>:<span class="hljs-number">375px</span>) <span class="hljs-keyword">and</span> (<span class="hljs-attribute">max-width</span>:<span class="hljs-number">450px</span>) &#123;<br>  <span class="hljs-selector-class">.box</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">90%</span>;<br>  &#125;<br>&#125;<br><span class="hljs-comment">/* &gt;=450px */</span><br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>:<span class="hljs-number">450px</span>) &#123;<br>  <span class="hljs-selector-class">.col</span>&#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">80%</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>缺点</p></blockquote><ol><li>页面上所有的元素都得在不同的 @media 中定义一遍不同的尺寸，代价有点高。</li><li>如果再多一种屏幕尺寸，就得多写一个 @media 查询块。</li></ol><hr><h3 id="rem方案"><a href="#rem方案" class="headerlink" title="rem方案"></a>rem方案</h3><ol><li>安装插件</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript">npm install amfe-flexible --save<br>npm install postcss-pxtorem --save-dev<br></code></pre></td></tr></table></figure><ol><li>在<code>main.js</code>中引入<code>amfe-flexible</code>, 该插件会根据不同设备的屏幕宽度来设置<code>html</code>的<code>font-size</code>值</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;amfe-flexible&#x27;</span>;<br></code></pre></td></tr></table></figure><ol><li>在<code>postcss.config.js</code>文件中配置<code>postcss-pxtorem</code></li></ol><blockquote><p><code>postcss-pxtorem</code>是一个能将<code>px</code>转换为<code>rem</code>的工具</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-string">&quot;plugins&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;postcss-pxtorem&quot;</span>: &#123;<br>      <span class="hljs-title function_">rootValue</span>(<span class="hljs-params">&#123; file &#125;</span>) &#123;<br>      <span class="hljs-comment">// 判断是vant文件的样式，还是我们的样式，来决定rootValue的大小</span><br>        <span class="hljs-keyword">return</span> file.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;vant&#x27;</span>) !== -<span class="hljs-number">1</span> ? <span class="hljs-number">37.5</span> : <span class="hljs-number">75</span>;<br>      &#125;,<br>      <span class="hljs-attr">propList</span>: [<span class="hljs-string">&#x27;*&#x27;</span>] <span class="hljs-comment">// 需要被转换的属性</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以在 <code>vite.config.js</code> 中配置 <code>postcss-pxtorem</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-comment">// 在vite.config.js中配置postcss-pxtorem</span><br><span class="hljs-attr">css</span>:&#123;<br>    <span class="hljs-attr">postcss</span>:&#123;<br>      <span class="hljs-attr">plugins</span>:[<br>        <span class="hljs-title function_">postCssPxToRem</span>(&#123;<br>          <span class="hljs-attr">rootValue</span>:<span class="hljs-number">37.5</span>,<br>          <span class="hljs-attr">propList</span>:[<span class="hljs-string">&#x27;*&#x27;</span>],<br>        &#125;)<br>      ]<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><ol><li><code>public/index.html</code>添加<code>viewport</code>元数据标签，使页面宽度和设备宽度一致</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&quot;</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">含义如下：</span><br><span class="hljs-comment">* width=device-width：视口宽度和设备保持一致</span><br><span class="hljs-comment">* initial-scale=1：视口的默认缩放比例1.0</span><br><span class="hljs-comment">* maximum-scale=1：最大缩放比例1.0</span><br><span class="hljs-comment">* minimum-scale=1：最小缩放比例1.0</span><br><span class="hljs-comment">* user-scalable=no：不允许用户自行缩放</span><br><span class="hljs-comment">--&gt;</span><br></code></pre></td></tr></table></figure><p>执行上述步骤之后，就可以使用<code>px</code>进行开发了,  <code>px</code>单位会被自动转换成<code>rem</code>单位。</p><hr><h3 id="viewport方案"><a href="#viewport方案" class="headerlink" title="viewport方案"></a>viewport方案</h3><ol><li><code>public/index.html</code>添加<code>viewport</code>元数据标签，使页面宽度和设备宽度一致</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><ol><li>安装插件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">npm install postcss-px-to-viewport --save-dev<br></code></pre></td></tr></table></figure><ol><li>在<code>postcss.config.js</code>文件中配置<code>postcss-px-to-viewport</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-function">(<span class="hljs-params">&#123; file &#125;</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> vwUnit = file &amp;&amp; file.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;vant&#x27;</span>) !== -<span class="hljs-number">1</span> ? <span class="hljs-number">375</span> : <span class="hljs-number">750</span>;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">plugins</span>: &#123;<br>      <span class="hljs-string">&#x27;postcss-px-to-viewport&#x27;</span>: &#123;<br>        <span class="hljs-attr">viewportWidth</span>: vwUnit, <span class="hljs-comment">// 设计稿的宽度</span><br>        <span class="hljs-attr">unitPrecision</span>: <span class="hljs-number">5</span>, <span class="hljs-comment">// 转换后的位数，即小数点位数</span><br>        <span class="hljs-attr">viewportUnit</span>: <span class="hljs-string">&#x27;vw&#x27;</span>, <span class="hljs-comment">// 转换成的视窗单位</span><br>        <span class="hljs-attr">propList</span>: [<span class="hljs-string">&#x27;*&#x27;</span>], <span class="hljs-comment">// 要进行转换的属性，如果某个属性不进行转换，只需在其前加个“!”即可</span><br>        <span class="hljs-attr">selectorBlackList</span>: [], <span class="hljs-comment">// 不进行转换的选择器</span><br>        <span class="hljs-attr">minPixelValue</span>: <span class="hljs-number">1</span>, <span class="hljs-comment">// 小于或等于1px则不进行转换</span><br>        <span class="hljs-attr">mediaQuery</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否在媒体查询的css代码中也进行转换，默认false</span><br>      &#125;,<br>    &#125;,<br>  &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>执行上述步骤之后，就可以使用<code>px</code>进行开发了，<code>px</code>单位会被自动转换成<code>vw</code>单位。</p><hr><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p><code>amfe-flexable</code>是阿里发布的一套可伸缩适配方案。</p><p>它能根据设备的宽高来设置页面<code>body</code>元素的字体大小，将<code>1rem</code>设置为<code>设备宽度/10</code>以及在页面大小转换时可以重新计算这些数值。</p><p><code>postcss-pxtorem</code>是postcss的一个插件，可以将对应的像素单位转换为<code>rem</code>。</p><p>在<code>vite</code>中可以直接对其进行配置，因为<code>vite</code>已经集成了<code>postcss</code>。</p><blockquote><p>其中最重要的配置属性为：</p></blockquote><ul><li>rootValue：根元素的值，即1rem对应的像素值大小。一般设置为<code>设计稿尺寸/10</code>以及一些其他属性：</li><li>propList：需要进行转换的css属性的值，可以使用通配符。如：<code>*</code>意思是将全部属性单位都进行转换；</li></ul><blockquote><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">[<span class="hljs-string">&quot;*position*&quot;</span>]`会匹配到`background-position-y<br></code></pre></td></tr></table></figure></blockquote><ul><li>selectorBlackList：不进行单位转换的选择器。如设置为字符串<code>body</code>，则所有含有body字符串的选择器都不会被该插件进行转换；若设置为<code>[/^body$/]</code>，则<code>body</code>会被匹配到而不是<code>.body</code></li><li>exclude：不需要进行单位转换的文件</li><li>mediaQuery：是否允许像素在媒体查询中进行转换</li></ul><hr><h2 id="PC端适配"><a href="#PC端适配" class="headerlink" title="PC端适配"></a>PC端适配</h2><hr><h3 id="rem方案-1"><a href="#rem方案-1" class="headerlink" title="rem方案"></a>rem方案</h3><ol><li>安装依赖</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">pnpm add amfe-flexible <span class="hljs-comment">// CSS单位自适应转换插件 负责更改根font-size</span><br>pnpm add postcss-pxtorem <span class="hljs-comment">// 如果版本过高可以降版本下载5.1.1版本 负责将px转成rem</span><br></code></pre></td></tr></table></figure><ol><li>在main.js中引入amfe-flexible</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;amfe-flexible&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>amfe-flexible 等价代码</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// import &#x27;@/utils/rem.js&#x27;</span><br><br><span class="hljs-comment">// 在utils文件夹下创建rem.js</span><br><span class="hljs-comment">// 设置 rem 函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">setRem</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 1920 默认大小16px; 1920px = 120rem ;每个元素px基础上/16</span><br>    <span class="hljs-keyword">const</span> screenWidth = <span class="hljs-number">1920</span><br>    <span class="hljs-keyword">const</span> scale = screenWidth / <span class="hljs-number">16</span><br>    <span class="hljs-keyword">const</span> htmlWidth = <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientWidth</span> || <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">clientWidth</span><br>    <span class="hljs-comment">// 得到html的Dom元素</span><br>    <span class="hljs-keyword">const</span> htmlDom = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;html&#x27;</span>)[<span class="hljs-number">0</span>]<br>    <span class="hljs-comment">// 设置根元素字体大小</span><br>    htmlDom.<span class="hljs-property">style</span>.<span class="hljs-property">fontSize</span> = htmlWidth / scale + <span class="hljs-string">&#x27;px&#x27;</span><br>  &#125;<br>  <span class="hljs-comment">// 初始化</span><br>  <span class="hljs-title function_">setRem</span>()<br>  <span class="hljs-comment">// 改变窗口大小时重新设置 rem</span><br>  <span class="hljs-variable language_">window</span>.<span class="hljs-property">onresize</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">setRem</span>()<br>  &#125;<br></code></pre></td></tr></table></figure><ol><li>配置vue.config.js</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">/***</span><br><span class="hljs-comment">注意点：</span><br><span class="hljs-comment">（1）rootValue根据设计稿宽度除以10进行设置，这边假设设计稿为1920，即rootValue设为192；</span><br><span class="hljs-comment">（2）propList是设置需要转换的属性，这边*为所有都进行转换。</span><br><span class="hljs-comment">***/</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-attr">devServer</span>:&#123;<br>        <span class="hljs-attr">port</span>:<span class="hljs-number">3000</span>,<br>        <span class="hljs-attr">open</span>:<span class="hljs-literal">true</span><br>    &#125;,<br>    <span class="hljs-comment">//rem配置</span><br>    <span class="hljs-attr">css</span>: &#123;<br>        <span class="hljs-attr">loaderOptions</span>: &#123;<br>         <span class="hljs-attr">postcss</span>: &#123;<br>            <span class="hljs-attr">plugins</span>: [<br>              <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;postcss-pxtorem&#x27;</span>)(&#123;<br>                  <span class="hljs-attr">rootValue</span>: <span class="hljs-number">149</span>, <span class="hljs-comment">//根元素字体大小</span><br>                  <span class="hljs-attr">propList</span>: [<span class="hljs-string">&#x27;*&#x27;</span>], <span class="hljs-comment">//可以从px转换为rem的属性，匹配正则</span><br>                  <span class="hljs-comment">// unitPrecision:5, //允许rem单位增长的十进制数字</span><br>                  <span class="hljs-comment">// replace:true, //替换包含rems的规则，而不添加后备</span><br>                  <span class="hljs-comment">// mediaQuery:false, //允许在媒体查询中转换px</span><br>                  <span class="hljs-comment">// minPixelValue:0, //设置要替换的最小像素值</span><br>                  <span class="hljs-comment">// selectorBlackList:[], //忽略转换正则匹配项</span><br>                  <span class="hljs-comment">// exclude:/node_modules/i  要忽略并保留为px的文件路径</span><br>              &#125;)<br>            ]<br>         &#125;<br>       &#125;<br>    &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p>存在问题</p><p><strong>不能使用行内样式</strong> </p><p>对于行内样式，阿里手淘并不能将px转rem，所以对于需要自适应的样式，如font-size、width、height等请不要写在行内。同理，对于不需要转化的样式可以写在行内，或者使用PX（大写）作为单位。</p><blockquote><p>暂未找到可以转行内rem的插件。</p></blockquote><hr><h3 id="viewport方案-1"><a href="#viewport方案-1" class="headerlink" title="viewport方案"></a>viewport方案</h3><ol><li>安装</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">pnpm add postcss-px-to-viewport -D<br></code></pre></td></tr></table></figure><ol><li>与<code>src</code>同目录 新建<code>postcss.config.js</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> plugins = &#123;<br>  <span class="hljs-string">&#x27;postcss-px-to-viewport&#x27;</span>: &#123;<br>    <span class="hljs-attr">unitToConvert</span>: <span class="hljs-string">&#x27;px&#x27;</span>, <span class="hljs-comment">// 需要转换的单位，默认为&quot;px&quot;</span><br>    <span class="hljs-attr">viewportWidth</span>: <span class="hljs-number">1494</span>, <span class="hljs-comment">// 设计稿的视口宽度</span><br>    <span class="hljs-attr">unitPrecision</span>: <span class="hljs-number">5</span>, <span class="hljs-comment">// 单位转换后保留的精度</span><br>    <span class="hljs-attr">propList</span>: [<span class="hljs-string">&#x27;*&#x27;</span>], <span class="hljs-comment">// 能转化为vw的属性列表</span><br>    <span class="hljs-attr">viewportUnit</span>: <span class="hljs-string">&#x27;vw&#x27;</span>, <span class="hljs-comment">// 希望使用的视口单位</span><br>    <span class="hljs-attr">fontViewportUnit</span>: <span class="hljs-string">&#x27;vw&#x27;</span>, <span class="hljs-comment">// 字体使用的视口单位</span><br>    <span class="hljs-attr">selectorBlackList</span>: [], <span class="hljs-comment">// 需要忽略的CSS选择器，不会转为视口单位，使用原有的px等单位。</span><br>    <span class="hljs-attr">minPixelValue</span>: <span class="hljs-number">1</span>, <span class="hljs-comment">// 设置最小的转换数值，如果为1的话，只有大于1的值会被转换</span><br>    <span class="hljs-attr">mediaQuery</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 媒体查询里的单位是否需要转换单位</span><br>    <span class="hljs-attr">replace</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">//  是否直接更换属性值，而不添加备用属性</span><br>    <span class="hljs-attr">exclude</span>: <span class="hljs-literal">undefined</span>, <span class="hljs-comment">// 忽略某些文件夹下的文件或特定文件，例如 &#x27;node_modules&#x27; 下的文件</span><br>    <span class="hljs-attr">include</span>: <span class="hljs-literal">undefined</span>, <span class="hljs-comment">// 如果设置了include，那将只有匹配到的文件才会被转换</span><br>    <span class="hljs-attr">landscape</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 是否添加根据 landscapeWidth 生成的媒体查询条件 @media (orientation: landscape)</span><br>    <span class="hljs-attr">landscapeUnit</span>: <span class="hljs-string">&#x27;vw&#x27;</span>, <span class="hljs-comment">// 横屏时使用的单位</span><br>    <span class="hljs-attr">landscapeWidth</span>: <span class="hljs-number">1494</span> <span class="hljs-comment">// 横屏时使用的视口宽度</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>可以看看这篇文章 ~~ 比较全</p></blockquote><p><a href="https://juejin.cn/post/6884042902587047943#heading-28">移动端适配及PC端适配心得总结体会(一) (可能比较全 - 掘金</a></p>]]></content>
    
    
    <categories>
      
      <category>工程化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>😈快速上手接入文心一言API</title>
    <link href="/2023/12/14/Node.js%20%E6%8E%A5%E5%85%A5%E6%96%87%E5%BF%83%E4%B8%80%E8%A8%80%20API/"/>
    <url>/2023/12/14/Node.js%20%E6%8E%A5%E5%85%A5%E6%96%87%E5%BF%83%E4%B8%80%E8%A8%80%20API/</url>
    
    <content type="html"><![CDATA[<h2 id="故事背景"><a href="#故事背景" class="headerlink" title="故事背景"></a>故事背景</h2><p>前几天上线了自己的 web 终端项目 –  <a href="https://www.weirdo-terminal.com/">https://www.weirdo-terminal.com/</a>  </p><p>由于后端是通过微信云托管部署的, 导致上线版本无法使用 chatGPT 服务, 啊 – 这样我也就放弃部署了</p><hr><p>正好今天, 有位同志在我项目下提了一个问题</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202312142217631.png" alt="image-20231214221743543"></p><p>我瞬间懵逼, 啊? 我咋没想到,  到官网看了看调用方法,  和 gpt 是差不多的。</p><p>那话不多说, 如何快速通过 Node.js 调用文心一言 API , 接下来你就知道咯~~</p><p>API 的调用流程如下图所示。</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202312142219146.png" alt="image-20231214221956120"></p><ol><li>创建一个千帆应用。根据实际需求创建千帆应用，创建成功后，获取AppID、API Key、Secret Key 等信息。</li><li>API 授权。对应用的 AppID 进行授权。</li><li>获取接口访问凭证 access_token 。根据第1步获取的 API Key 和 Secret Key ，调用<a href="https://cloud.baidu.com/doc/WENXINWORKSHOP/s/Ilkkrb0i5">获取access_token</a>接口获取 access_token ，通过 access_token 鉴权调用者身份。</li><li>调用API接口。例如调用ERNIE-Bot相关接口，详见<a href="https://cloud.baidu.com/doc/WENXINWORKSHOP/s/Nlks5zkzu">API列表</a>。</li></ol><h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p>登录百度智能云千帆控制台。</p><p>注册并登录<a href="https://console.bce.baidu.com/qianfan/ais/console/applicationConsole/application">百度智能云千帆控制台</a> 。</p><h2 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h2><p>创建千帆应用</p><p>进入<a href="https://console.bce.baidu.com/qianfan/ais/console/applicationConsole/application/create">控制台创建应用</a> 。</p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202312142221297.png" alt="image-20231214222138267" style="zoom:67%;" /><h2 id="获取-key"><a href="#获取-key" class="headerlink" title="获取 key"></a>获取 key</h2><p>创建应用后，获取AppID、API Key、Secret Key。</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202312142222772.png" alt="image-20231214222213748"></p><blockquote><p>上图则是我的 api key 和 secret key</p></blockquote><h2 id="得到-Access-Token"><a href="#得到-Access-Token" class="headerlink" title="得到 Access Token"></a>得到 Access Token</h2><p>这两个值的作用是用来获取 Access Token，Access Token 是调用文心 API 的必需参数。Access Token 是通过将 API Key 和 Secret Key 作为参数请求一个独立的接口得到。本文用 axios 作为 Node 端的网络请求库，下面的函数用来请求接口，拿到 token：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">API_KEY</span> = <span class="hljs-string">&#x27;&lt;API Key&gt;&#x27;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">SECRET_KEY</span> = <span class="hljs-string">&#x27;&lt;Secret Key&gt;&#x27;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">ACCESS_TOKEN_URL</span> = <span class="hljs-string">&#x27;https://aip.baidubce.com/oauth/2.0/token&#x27;</span>;<br><br><span class="hljs-comment">// 获取 access token</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchAccessToken</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> accessTokenRes = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">post</span>(<span class="hljs-variable constant_">ACCESS_TOKEN_URL</span>, <span class="hljs-literal">null</span>, &#123;<br>        <span class="hljs-attr">params</span>: &#123;<br>            <span class="hljs-string">&#x27;grant_type&#x27;</span>: <span class="hljs-string">&#x27;client_credentials&#x27;</span>,<br>            <span class="hljs-string">&#x27;client_id&#x27;</span>: <span class="hljs-variable constant_">API_KEY</span>,<br>            <span class="hljs-string">&#x27;client_secret&#x27;</span>: <span class="hljs-variable constant_">SECRET_KEY</span>,<br>        &#125;,<br>    &#125;);<br>    <span class="hljs-keyword">return</span> accessTokenRes.<span class="hljs-property">data</span>.<span class="hljs-property">access_token</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="及时更新token"><a href="#及时更新token" class="headerlink" title="及时更新token"></a>及时更新token</h2><p>Access Token 的有效期是 30 天，需要及时更新，在一个需要持久运行的 Node 应用里，最好把 Access Token 和它对应的生成时间成对记录，以便在 token 过期之前及时更新：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 全局存储一个 access token -&gt; 过期时间对象</span><br><span class="hljs-keyword">let</span> accessToken = &#123;<br>    <span class="hljs-attr">expiredTime</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>&#125;;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getAccessToken</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (accessToken.<span class="hljs-property">value</span> &amp;&amp; <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() &lt; accessToken.<span class="hljs-property">expiredTime</span>) &#123;<br>        <span class="hljs-keyword">return</span> accessToken.<span class="hljs-property">value</span>;<br>    &#125;<br>    <span class="hljs-keyword">const</span> token = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchAccessToken</span>();<br>    accessToken = &#123;<br>        <span class="hljs-attr">expiredTime</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() + <span class="hljs-number">29</span> * <span class="hljs-number">86400</span> * <span class="hljs-number">1000</span>, <span class="hljs-comment">// 29 days</span><br>        <span class="hljs-attr">value</span>: token,<br>    &#125;;<br>    <span class="hljs-keyword">return</span> token;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>接下来便是重头戏了, 调用文心一言的服务</p></blockquote><h2 id="调用-ERNIT-Bot-API"><a href="#调用-ERNIT-Bot-API" class="headerlink" title="调用 ERNIT-Bot API"></a>调用 ERNIT-Bot API</h2><p>千帆平台上有多个模型的 API 可以调用，不同 API 用到的参数比较类似，这里用最基本的 ERNIT-Bot API 来做示例。</p><p>Access Token 和对话信息是唯二的必填参数，前者以 query 的形式传入，后者则是作为 POST 请求体。</p><blockquote><p>下面是一个简单的调用示例：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CHAT_URL</span> = <span class="hljs-string">&#x27;https://aip.baidubce.com/rpc/2.0/ai_custom/v1/wenxinworkshop/chat/completions&#x27;</span>;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">ask</span>(<span class="hljs-params">question</span>) &#123;<br>  <span class="hljs-keyword">const</span> messages = [&#123; <span class="hljs-attr">role</span>: <span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-attr">content</span>: question &#125;]<br>  <span class="hljs-keyword">const</span> token = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getAccessToken</span>()<br>  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">post</span>(<span class="hljs-variable constant_">CHAT_URL</span>, &#123; messages &#125;, &#123; <span class="hljs-attr">params</span>: &#123; <span class="hljs-attr">access_token</span>: token &#125; &#125;)<br>  <span class="hljs-keyword">const</span> &#123; data &#125; = res<br>  <span class="hljs-keyword">return</span> data<br>&#125;<br></code></pre></td></tr></table></figure><p>测试一下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> question = <span class="hljs-string">&#x27;我是最帅的!&#x27;</span><br>  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">ask</span>(question)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)<br>&#125;<br><br><span class="hljs-title function_">main</span>();<br></code></pre></td></tr></table></figure><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202312142235215.png" alt="image-20231214223522188"></p><p>可以看到，返回的内容里不仅包括回答的文本，还包括占用 token 数（与计费相关）、回答是否有被截断的等信息。</p><h2 id="实现多轮对话"><a href="#实现多轮对话" class="headerlink" title="实现多轮对话"></a>实现多轮对话</h2><p>OpenAI API 多轮对话是通过维护一个固定 conversation id 的形式实现的，文心 API 则有所不同，要实现多轮对话，需要在调用接口时携带上之前所有的提问和回答。比如最开始我们提问了「把我接下来说的话都翻译成英文」，文心回答「好的，我会尽力把您接下来想要表达的内容翻译成英文。请随时告诉我您想要说的话。」，那么我们再一次提问的时候，message 参数就需要是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[<br>    &#123; <span class="hljs-attr">role</span>: <span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-attr">content</span>: <span class="hljs-string">&#x27;把我接下来说的话都翻译成英文&#x27;</span> &#125;,<br>    &#123; <span class="hljs-attr">role</span>: <span class="hljs-string">&#x27;assistant&#x27;</span>, <span class="hljs-attr">content</span>: <span class="hljs-string">&#x27;好的，我会尽力把您接下来想要表达的内容翻译成英文。请随时告诉我您想要说的话。&#x27;</span> &#125;,<br>    &#123; <span class="hljs-attr">role</span>: <span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-attr">content</span>: <span class="hljs-string">&#x27;你好，我是一名程序员。&#x27;</span> &#125;<br>]<br></code></pre></td></tr></table></figure><p>这里是通过每次加入一条前端传入的对话历史和当前请求的信息, 这样就能成功实现记忆功能</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">ask</span>(<span class="hljs-params">memory, message</span>) &#123;<br>    <span class="hljs-keyword">const</span> token = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getAccessToken</span>()<br>    <span class="hljs-keyword">const</span> messages = memory<br>    messages.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">role</span>: <span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-attr">content</span>: message &#125;)<br>    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">post</span>(<span class="hljs-variable constant_">CHAT_URL</span>, &#123; messages &#125;, &#123; <span class="hljs-attr">params</span>: &#123; <span class="hljs-attr">access_token</span>: token &#125; &#125;)<br>    <span class="hljs-keyword">const</span> &#123; data &#125; = res<br>    <span class="hljs-keyword">return</span> data.<span class="hljs-property">result</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>下面是前端的请求函数</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">getBotOutput</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">message: string</span>) =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (!message) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>  <span class="hljs-keyword">let</span> botStore = <span class="hljs-title function_">useBotStore</span>()<br>  <span class="hljs-keyword">let</span> &#123; memory &#125; = botStore<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">res</span>: any = <span class="hljs-keyword">await</span> myAxios.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/bot/get&#x27;</span>, &#123; message, memory &#125;)<br>  res = res.<span class="hljs-property">data</span><br>  <span class="hljs-comment">// 虽然后端也有添加消息记录的代码, 但是我们前端没有啊, 所以还是要加入</span><br>  <span class="hljs-comment">// 你可能会问 : 为什么不先加入一次记录, 然后拿到最新的memory发起请求呢? 这样可以少传一个message参数。</span><br>  <span class="hljs-comment">// 回答 : 测试过, 不行 ------- hhhh</span><br>  botStore.<span class="hljs-title function_">addRecord</span>(&#123; <span class="hljs-attr">role</span>: <span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-attr">content</span>: message &#125;)<br>  botStore.<span class="hljs-title function_">addRecord</span>(&#123; <span class="hljs-attr">role</span>: <span class="hljs-string">&#x27;assistant&#x27;</span>, <span class="hljs-attr">content</span>: res &#125;)<br>  <span class="hljs-keyword">return</span> res<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这个 res 就是我们获取的值了. 通过模板将回复的内容渲染到页面中即可。</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202312142245398.png" alt="image-20231214224540269"></p><p>这样便能请求到文心一言服务啦~~</p><p>这是我的项目地址 ~~ <a href="https://github.com/2WeirDo/weirdo_terminal">https://github.com/2WeirDo/weirdo_terminal</a> ~~ 感兴趣的朋友们欢迎star哦~ ⭐⭐⭐</p>]]></content>
    
    
    <categories>
      
      <category>Node</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>😈记录我的第一次PR</title>
    <link href="/2023/12/04/%E7%AC%AC%E4%B8%80%E6%AC%A1PR/"/>
    <url>/2023/12/04/%E7%AC%AC%E4%B8%80%E6%AC%A1PR/</url>
    
    <content type="html"><![CDATA[<h2 id="故事开头"><a href="#故事开头" class="headerlink" title="故事开头"></a>故事开头</h2><p>事情是这样的, 前几天我使用 <code>pinia</code> 数据持久化插件 <code>pinia-plugin-persistedstate</code> 时忘记了相关配置, 于是去官方文档查看。</p><p>在关于 <code>storage</code> 配置的位置, 我发现官方文档这里有一个文字错误, 多了一个 “的” 字, 于是我将其记录下来, 也是提前把它当作我的第一次 <code>PR</code> 来练手。</p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202312041032394.png" alt="image" style="zoom: 67%;" /><p><br><br></p><h2 id="PR流程"><a href="#PR流程" class="headerlink" title="PR流程"></a>PR流程</h2><blockquote><p> 接下来是我 PR 的流程</p></blockquote><ol><li>首先把你要提交 <code>PR</code> 的项目 <code>Fork</code> 到自己的仓库。点击 <code>fork</code> 按钮</li></ol><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202312041035122.png" alt="image-20231204103548078"></p><p>这个时候自己的仓库中 就有你 <code>fork</code>下来的项目了</p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202312041037355.png" alt="image-20231204103742309" style="zoom: 50%;" /><p><br><br></p><ol start="2"><li><p>在自己的仓库中将 <code>fork</code> 的仓库 <code>clone</code> 到本地。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># git clone &#x27;自己仓库中的项目地址&#x27;</span><br>git <span class="hljs-built_in">clone</span> <span class="hljs-string">&#x27;https://github.com/2WeirDo/pinia-plugin-persistedstate.git&#x27;</span><br></code></pre></td></tr></table></figure><p><br><br></p></li><li><p>与上游仓库建立连接</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 只需操作一次</span><br>git remote add upstream <span class="hljs-string">&#x27;开源项目源地址&#x27;</span>  <br><br><span class="hljs-comment"># 查看远程仓库地址</span><br>git remote -v  <br></code></pre></td></tr></table></figure><p><br><br></p><ol start="4"><li>代码 <code>clone</code>到本地之后，先切换一个新的分支，分支名最好紧贴这次更新的内容。分支的命名尽量简洁，并与解决的问题相关</li></ol><p>为什么要切换到新分支呢 ?  因为你以后可能还需要进行新的 PR , 这样最好切换到新分支便于管理你的 PR, 避免混淆。</p><blockquote><p>比如这里就是这个项目关于 fix-typo 的 PR。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建并切换分支</span><br>git checkout -b fix-typo <br></code></pre></td></tr></table></figure><p><br><br></p><ol start="5"><li>在新分支修改代码并提交</li></ol><blockquote><p>注意看每个项目它可能会有自己的提交规范, 根据规范进行 PR</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .<br>git commit -m <span class="hljs-string">&quot;just a minor typo&quot;</span><br>git push origin fix-typo<br></code></pre></td></tr></table></figure><p><br><br></p><ol start="6"><li>在自己的仓库中找到对应项目，打开 <code>Pull requests Tab</code>，点击 <code>New pull request</code> 按钮，新建一个 <code>PR</code>。</li></ol><blockquote><p>Pull requests Tab 会显示在我们的项目页面,  如果没有 则点击 Pull requests , 然后点击 New pull request </p></blockquote><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202312041055935.png" alt="image-20231204105531892"></p><p><br><br></p><ol start="7"><li><code>github</code> 会帮我们自动选择刚刚提交的分支，你需要编写 PR 相关描述,  最后点击 <code>Create pull request</code> 即可。</li></ol><blockquote><p>最好使用英文</p></blockquote><p><br><br></p><ol start="8"><li>之后只需要等待管理人员批准审核 merge 你的 PR 即可</li></ol><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202312041053119.png" style="zoom:50%;" /><p><br><br></p><ol start="9"><li>最后我们打开官方文档, 发现 typo 错误已经被修改。</li></ol><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202312041056622.png" alt="image-20231204105627576" style="zoom:67%;" /><p><br><br></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这就是我第一次 PR 的经历了, 虽说是个 很小很水 的 PR , 不过拿来作为我对开源贡献的起步, 也是大有裨益的。</p><blockquote><p>这样看我的 <code>github</code> 主页, 也显得不那么单调咯hhh😈</p></blockquote><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202312041059366.png" alt="image-20231204105950328" style="zoom:50%;" /><p><br><br></p><blockquote><p>❗ <strong>注意</strong> :   你可能会遇到一个问题 :</p><p>当你 fork 了一个项目, 正在开发的时候，可能源项目发生了改动或者其他人也在开发, 这样就使得你 fork 的项目与源项目不同步, </p><p>这个时候就需要去拉取源项目的代码, 进行一个合并,  具体流程可以查阅资料解决   b（￣▽￣）d　</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>日常琐碎</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开源</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>🤠你知道什么是 CDN 吗?</title>
    <link href="/2023/11/29/CDN/"/>
    <url>/2023/11/29/CDN/</url>
    
    <content type="html"><![CDATA[<h3 id="1-CDN的概念"><a href="#1-CDN的概念" class="headerlink" title="1. CDN的概念"></a>1. CDN的概念</h3><p><strong>CDN只是一种网络技术，资源本质上还是存储在某一台服务器上的，</strong><code>CDN</code><strong>只是帮你找到距离你最近的服务器</strong></p><p><code>CDN</code>（Content Delivery Network，内容分发网络）是一种内容分发网络，它能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息<strong>将用户重新导向离用户最近的服务节点上</strong>。</p><p>其目的是使用户就近获取内容，解决网络拥挤的状况，提高用户访问网站的响应速度。</p><p>通俗点就是 :  CDN其实是一个离用户较近的由一个DNS服务器和几台缓存服务器运行起来的，该服务器可以获取到完整的网站资源，并且它会定期与源站进行同步，保证自身服务器上的内容是最新的。</p><p><strong>主要优势 :</strong></p><ul><li>CDN节点解决了跨运营商和跨地域访问的问题，访问延时大大降低；</li><li>大部分请求在CDN边缘节点完成，CDN起到了分流作用，减轻了源站的负载。</li></ul><h3 id="2-CDN的组成部分"><a href="#2-CDN的组成部分" class="headerlink" title="2. CDN的组成部分"></a>2. CDN的组成部分</h3><p>典型的CDN由三个部分组成：<code>分发服务系统</code>、<code>负载均衡系统</code>、<code>运营管理系统</code></p><ul><li><strong>分发服务系统</strong>：最基本的工作单元是Cache设备，cache负责直接响应最终用户的访问请求，把缓存在本地的内容快速提供给用户。同时cache还负责与源站点进行内容同步，把最新的内容从源站获取下来并保存在本地。cache设备的数量、规模、总服务能力是衡量一个CDN系统服务能力的最基本指标。</li><li><strong>负载均衡系统</strong>：主要功能是负责对所有发起请求的用户进行访问调度，确定提供给用户的最终实际访问地址。两级调度体系分为全局负载均衡（GSLB）和本地负载均衡（SLB）。全局负载均衡主要根据用户的就近原则，通过对每个服务节点进行最优判断，确定向用户提供服务的cache的物理地址。本地负载均衡主要负责节点内部的设备负载均衡。</li><li><strong>运营管理系统</strong>：运营管理系统分为运营管理和网络管理子系统，负责处理业务层面与外界系统交互所必须的手机、整理与交互。</li></ul><h3 id="3-⭐CDN工作流程"><a href="#3-⭐CDN工作流程" class="headerlink" title="3. ⭐CDN工作流程"></a>3. ⭐CDN工作流程</h3><p>CDN和DNS有着密不可分的联系，我们先来回顾一下<strong>DNS的解析域名过程:</strong></p><p>在浏览器输入 <code>www.test.com</code> 的解析过程如下： </p><p>（1） 检查浏览器缓存, 如果存在，则域名解析到此完成。</p><p>（2）检查操作系统缓存，常见的如<code>hosts</code>文件 , 如果存在，则域名解析到此完成。</p><p>（3）检查路由器缓存 </p><p>（4）如果前几步都没有找到，会向<code>ISP</code>(网络服务提供商  )的本地<code>DNS</code>服务器(<code>LDNS</code>)查询 </p><p>（5）如果<code>LDNS</code>服务器没找到，会向根域名服务器(<code>Root Server</code>)请求解析，分为以下几步：</p><ul><li>根服务器返回顶级域名服务器如<code>.com，.cn，.org</code>等的地址，该例子中会返回<code>.com</code>的地址</li><li>接着向顶级域名服务器发送请求，然后会返回次级域名服务器的地址，本例子会返回<code>.test</code>的地址</li><li>接着向次级域名服务器发送请求，然后会返回通过域名查询到的目标<code>IP</code>，本例子会返回<code>www.test.com</code>的地址</li><li><code>Local DNS Server</code>会缓存结果，并返回给用户，缓存在系统中</li></ul><p><strong>DNS存在的问题:</strong></p><ul><li>如果存在多个域名(路径过长)需要查询或者网络不佳，可能导致延时大量增加</li><li>各大运营商在域名解析缓存的处理上实现的策略不统一</li><li>DNS劫持 , 部分运营商会在本地域名服务器劫持域名解析结果，在访问网站过程中插入广告</li><li>根服务器一旦被攻击或者关闭服务，将会导致全球互联网瘫痪。</li></ul><p>*<em>用户未使用<code>CDN</code><em>缓存资源的过程：</em></em></p><ol><li>浏览器通过<code>DNS</code>对域名进行解析（就是上面的<code>DNS</code>解析过程），依次得到此域名对应的<code>IP</code>地址</li><li>浏览器根据得到的<code>IP</code>地址，向域名的服务主机发送数据请求</li><li>服务器向浏览器返回响应数据</li></ol><p>**当使用了<code>CDN</code>**时</p><p><code>DNS</code> 服务器根据用户 <code>IP</code> 地址，将域名解析成相应节点的<strong>缓存服务器<code>IP</code>地址</strong>，实现用户就近访问。使用 <code>CDN</code> 服务的网站，只需将其域名解析权交给 <code>CDN</code> 的全局负载均衡（GSLB）设备，将需要分发的内容注入 <code>CDN</code>，就可以实现内容加速了。</p><ol><li>当用户点击网站页面上的内容URL，经过<strong>本地</strong>DNS系统解析，DNS 系统会最终将域名的解析权交给 CNAME 指向的 CDN 专用 DNS 服务器。</li><li>CDN 的 DNS 服务器将 CDN 的<strong>全局负载均衡设备</strong><code>IP</code>地址返回用户。</li><li>用户向 CDN 的全局负载均衡设备发起内容 URL 访问请求。</li><li>CDN 全局负载均衡设备根据用户 IP 地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求。</li><li>基于以下这些条件的综合分析<strong>之后</strong>，区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的IP地址, 具体过程如下 : <ol><li>根据用户 IP 地址，判断哪一台服务器距用户最近；</li><li>根据用户所请求的 URL 中携带的内容名称，判断哪一台服务器上有用户所需内容；</li><li>查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。</li></ol></li><li>全局负载均衡设备把服务器的 <code>IP</code> 地址返回给用户。</li><li>用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。</li></ol><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202311292300039.png" alt="img"></p><h3 id="4-CDN缓存"><a href="#4-CDN缓存" class="headerlink" title="4. CDN缓存"></a>4. CDN缓存</h3><p>当网站接入了<code>CDN</code>，浏览器本地缓存的资源过期后，浏览器不是直接向源服务器请求资源，而是转向<code>CDN</code>边缘节点请求资源。<code>CDN</code>边缘节点中会将用户请求的资源缓存下来，如果<code>CDN</code>中的缓存也过期了，<code>CDN</code>边缘节点则会向源服务器发出回源请求，从而来获取最新资源。</p><p><strong>CDN 缓存策略</strong></p><p><code>CDN</code>节点缓存策略一般都会遵循<code>HTTP</code>协议，在没有匹配到自定义缓存规则且源服务器也没有返回任何有效缓存头的情况下，默认配置策略为：</p><ul><li>针对静态资源，所有正常状态码 <code>200&lt;=code&lt;400</code> 均缓存<code>8</code>天。</li><li><code>301</code> 响应缓存 2 小时，302 响应缓存 20 分钟；</li><li>针对动态资源，程序会自动识别，则不进行缓存</li><li>对于其他大于等于<code>400</code>的不正常响应都不会进行缓存</li></ul><p><strong>缺陷</strong></p><p>但这里需要注意，当源服务器资源更新后，如果 CDN 节点上缓存数据还未过期，用户访问到的依旧是过期的缓存资源，这会导致用户最终访问出现偏差。因此，开发者需要手动刷新相关资源，使 CDN 缓存保持为最新的状态。</p><p><strong>如何解决CDN缓存更新不及时?</strong></p><ul><li>通过<code>URL</code>上加上时间戳参数，使<code>CDN</code>边缘节点同步源站最新资源</li><li>调用<code>CDN</code>服务商提供的刷新缓存的接口</li></ul><h3 id="5-CDN的作用"><a href="#5-CDN的作用" class="headerlink" title="5. CDN的作用"></a>5. CDN的作用</h3><p>CDN最常用的功能当然是加速，但还有一些其他功能。</p><ol><li><strong>加速访问</strong></li></ol><p>CDN可以使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。</p><p>还提供服务器端加速，解决由于用户访问量大造成的服务器过载问题；</p><ol start="2"><li><strong>实现跨运营商、跨地域的全网覆盖</strong></li></ol><p>互联不互通、区域ISP地域局限、出口带宽受限制等种种因素都造成了网站的区域性无法访问。</p><p><code>CDN</code>加速可以覆盖全球的线路，通过使用其是可以完美的解决跨运营商访问难的问题的。</p><ol start="3"><li><strong>异地备援</strong></li></ol><p>当某个服务器发生意外故障时，系统将会调用其他临近的健康服务器节点进行服务，进而提供接近<code>100%</code>的可靠性，这就让你的网站可以做到永不宕机。</p><ol start="4"><li><p><strong>减少网站的安全&#x2F;维护成本</strong></p></li><li><p>CDN的负载均衡和分布式存储技术，可以加强网站的可靠性, 防攻击系统也能避免网站遭到恶意攻击。</p></li><li><p>投入使用CDN加速可以实现网站的全国铺设，你根据不用考虑购买服务器与后续的托管运维, 并且能降低网站自身建设和维护成本。</p></li><li><p>且<code>CDN</code>加速厂商一般都会提供一站式服务，业务不仅限于CDN.</p></li></ol><h3 id="6-CDN的应用场景"><a href="#6-CDN的应用场景" class="headerlink" title="6. CDN的应用场景"></a>6. CDN的应用场景</h3><ol><li><strong>网站站点&#x2F;应用加速</strong></li></ol><p>CDN可用于网站或者应用中大量静态资源的加速分发，如<code>html、css、js、img</code>等，可以通过<code>CDN</code>缓存在边缘节点上，当用户访问时可就近获取，提高了用户的访问速度以及降低了源站的压力。</p><ol start="2"><li><strong>大文件下载分发加速（视频等文件）</strong></li></ol><p><code>CDN</code>可以针对各类文件、在线点播视频提供下载、分发加速，比如<code>mp4</code>、<code>flv</code>视频文件或大小在<code>20M</code>以上的文件，<code>CDN</code>可以搭配<code>对象存储OSS</code>使用，提升回源速度，节约回源带宽成本。</p><ol start="3"><li><strong>移动应用加速</strong></li></ol><p>CDN可以为移动APP更新文件分发，为移动APP内图片、页面、短视频、UGC等内容的优化提供加速分发效果。同时可提供HTTP DNS服务，避免DNS劫持并获得精确的DNS解析结果。</p><ol start="4"><li><strong>直播加速</strong></li></ol><p>CDN可以为直播分发提供流畅的播放下行链路，借助负载均衡系统将主播端采集的音视频数据推送到接近观众的数千个边缘节点，当观众端发起请求，就可以就近获取资源，减少网络抖动，增加直播链路的稳定性。</p><h3 id="7-⭐如何使用CDN"><a href="#7-⭐如何使用CDN" class="headerlink" title="7. ⭐如何使用CDN"></a>7. ⭐如何使用CDN</h3><blockquote><p>在 vite 项目中使用 CDN</p></blockquote><p>使用 vite 创建项目</p><p>首先创建项目和安装依赖</p><p><strong>分析依赖</strong></p><p>build 视图分析依赖文件 (分析项目中的文件大小及引用情况)</p><p>这里可以安装 rollup-plugin-visualizer 插件分析依赖视图</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">npm i rollup-plugin-visualizer -D<br></code></pre></td></tr></table></figure><p>使用 rollup-plugin-visualizer</p><blockquote><p>修改 vite.config.ts</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">import</span> &#123; defineConfig &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vite&#x27;</span><br><span class="hljs-keyword">import</span> vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@vitejs/plugin-vue&#x27;</span><br><br><span class="hljs-keyword">import</span> &#123; visualizer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;rollup-plugin-visualizer&#x27;</span><br><br><span class="hljs-comment">// https://vitejs.dev/config/</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-attr">plugins</span>: [<br>      <span class="hljs-title function_">vue</span>(), <br>      <span class="hljs-title function_">visualizer</span>(&#123; <br>          <span class="hljs-attr">open</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 在默认用户代理中打开生成的文件</span><br>          <span class="hljs-attr">gzipSize</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 收集 gzip 大小并将其显示</span><br>          <span class="hljs-attr">brotliSize</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 收集 brotli 大小并将其显示</span><br>          <span class="hljs-attr">filename</span>: <span class="hljs-string">&quot;stats.html&quot;</span>, <span class="hljs-comment">// 分析图生成的文件名</span><br>       &#125;)  <br>  ],   <br>&#125;)<br></code></pre></td></tr></table></figure><p>配置的参数有很多是默认的，如果你没有特殊需求，完全可以不添加参数；</p><p>下面添加一个表格对已有参数进行诠释：</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202311292300977.png" alt="img"></p><p>打包项目 : npm run build </p><p>打包完成后，会自动打开名为 stats.html 的页面：可以很直观的可以看出各种包的占据程度</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202311292300020.png" alt="img"></p><p>vite 也会输出</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202311292300969.png" alt="img"></p><blockquote><p>分析上图，我们发现整个项目依赖为 1.79MB，其中 vue 体积占比 13.57%，248.43KB 大小，其次是@arco-design+web-vue 占比 81.49%, 1.46MB。</p></blockquote><p>⭐<strong>CDN 加速</strong></p><p>话接上文，我们通过视图分析发现了arco-design + web-vue 是最大的文件依赖,  那我们就尝试在vite+vue下配置这俩个库的cdn引入来减少请求压力</p><p>安装 vite-plugin-cdn-import(推荐)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">npm i vite-plugin-cdn-<span class="hljs-keyword">import</span> -D<br></code></pre></td></tr></table></figure><p>⭐修改 vite.config.ts (配置需要加速的依赖)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">import</span> &#123; defineConfig &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vite&#x27;</span>;<br><span class="hljs-keyword">import</span> compression <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vite-plugin-compression&#x27;</span>;<br><span class="hljs-keyword">import</span> vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@vitejs/plugin-vue&#x27;</span><br><span class="hljs-keyword">import</span> &#123; visualizer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;rollup-plugin-visualizer&#x27;</span><br><span class="hljs-keyword">import</span> importToCDN <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vite-plugin-cdn-import&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-comment">// 其他配置项...</span><br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-comment">// 其他插件...</span><br>    <span class="hljs-comment">// 第三方库CDN引入</span><br>    importToCDN(&#123;<br>      <span class="hljs-attr">prodUrl</span>: <span class="hljs-string">&quot;https://unpkg.com/&#123;name&#125;@&#123;path&#125;&quot;</span>,<br>      <span class="hljs-attr">modules</span>: [<br>        <span class="hljs-comment">// autoComplete 自动导入</span><br>        <span class="hljs-title function_">autoComplete</span>(<span class="hljs-string">&#x27;vue&#x27;</span>),<br>        <span class="hljs-comment">// element-plus 这个源码中使用了 vue 依赖包里的 ref 变量 , 所以我们将 vue 也引入进来</span><br>        <span class="hljs-title function_">autoComplete</span>(<span class="hljs-string">&#x27;axios&#x27;</span>),<br>        &#123;<br>          <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;vue-demi&quot;</span>, <span class="hljs-comment">// vue版本选好 不然会报错</span><br>          <span class="hljs-attr">var</span>: <span class="hljs-string">&quot;VueDemi&quot;</span>,<br>          <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;0.14.5&quot;</span>,<br>        &#125;,<br>        &#123;<br>          <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;vue-router&quot;</span>,<br>          <span class="hljs-attr">var</span>: <span class="hljs-string">&quot;VueRouter&quot;</span>,<br>          <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;4.2.2&quot;</span>,<br>        &#125;,<br>        &#123;<br>          <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;element-plus&quot;</span>,<br>          <span class="hljs-attr">var</span>: <span class="hljs-string">&quot;ElementPlus&quot;</span>,<br>          <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;2.3.6&quot;</span>,<br>          <span class="hljs-attr">css</span>: <span class="hljs-string">&quot;2.3.6/dist/index.css&quot;</span>,<br>        &#125;,<br>        &#123;<br>          <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;@element-plus/icons-vue&quot;</span>,<br>          <span class="hljs-attr">var</span>: <span class="hljs-string">&quot;ElementPlusIconsVue&quot;</span>, <span class="hljs-comment">// 根据main.js中定义的来</span><br>          <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;2.1.0&quot;</span>,<br>        &#125;,<br>        &#123;<br>          <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;pinia&quot;</span>,<br>          <span class="hljs-attr">var</span>: <span class="hljs-string">&quot;Pinia&quot;</span>,<br>          <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;2.1.3&quot;</span>,<br>        &#125;,<br>      ],<br>    &#125;),<br>  ],<br>&#125;);<br></code></pre></td></tr></table></figure><blockquote><p>CDN 链接查询 <a href="https://www.jsdelivr.com/">https://www.jsdelivr.com/</a> 这个好用</p></blockquote><p>CDN 参数获取方式</p><ul><li><p>name：npm 包的名称</p></li><li><p>var：组件（main.ts）引用的名称</p><ul><li>比如 ArcoVue</li></ul></li><li><p>path：cdn 网站存储对应的 js 地址</p><ul><li>输入对应名称，会自动跳转到对应的 js 文件，复制粘贴，需要修改版本，和自己项目的 package.json 版本一致</li></ul></li><li><p>css：对应位置</p><ul><li>需要注意的是，css 可以使用本地的，使用本地的就不要添加 css，使用远程 cdn 的就需要在打包前注释本地的，否则会出现样式重叠。(在main.js中注释arcodesign的css引入)</li></ul></li></ul><p>怎么找到对应库cdn包的路径，我们好来配置参数</p><blockquote><p>以UNPKG为例实践如下: 比如我们要配置element-plus的cdn引入</p></blockquote><ul><li>先进入unpkg.com</li><li>在地址后面链接你的包名</li><li>得到链接配置参数即可</li></ul><p>重新打包 <code>npm run build</code> </p><p>可以看到，原先的 arco-design 依赖包和消失了：</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202311292300047.png" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>性能优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CDN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>😈node记账本demo笔记</title>
    <link href="/2023/11/27/node%E8%AE%B0%E8%B4%A6%E6%9C%AC/"/>
    <url>/2023/11/27/node%E8%AE%B0%E8%B4%A6%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h2 id="基本结构搭建"><a href="#基本结构搭建" class="headerlink" title="基本结构搭建"></a>基本结构搭建</h2><ol><li><p><code>npm i -g express-generator </code>  : 安装 npm 包 (已经安装就第二步)</p></li><li><p><code>express -e accounts</code> : 快速创建文件夹, 添加<code>ejs</code>模板引擎的支持</p></li><li><p>在<code>views</code>中通过 ejs 写好页面 (关于页面的显示这里就不多介绍)</p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202311271511346.png" alt="img" style="zoom:67%;" /></li><li><p>将所需要的 js 和 css 文件存放到 public 文件夹下</p></li><li><p>在<code>routes/index.js</code>中写好增删改查</p></li><li><p><code>npm i</code> : 安装依赖</p></li><li><p><code>npm start</code> : 运行项目 (在 bin &#x2F; www 文件, 端口用的 3000)</p><blockquote><p>package.json 中的 start 命令可以改为 nodemon</p></blockquote></li></ol><blockquote><p>app.js代码</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> createError = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http-errors&#x27;</span>);<br><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">var</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><span class="hljs-keyword">var</span> cookieParser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;cookie-parser&#x27;</span>);<br><span class="hljs-keyword">var</span> logger = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;morgan&#x27;</span>);<br><br><span class="hljs-keyword">var</span> indexRouter = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./routes/index&#x27;</span>);  <span class="hljs-comment">//❗ 我们只需要在这里编写代码即可</span><br><span class="hljs-keyword">var</span> app = <span class="hljs-title function_">express</span>();<br><br><span class="hljs-comment">// view engine setup</span><br>app.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;views&#x27;</span>, path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;views&#x27;</span>)); <span class="hljs-comment">//❗ 设置模板文件存放文职</span><br>app.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;view engine&#x27;</span>, <span class="hljs-string">&#x27;ejs&#x27;</span>); ❗ <span class="hljs-comment">// 设置模板引擎为 ejs</span><br><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">logger</span>(<span class="hljs-string">&#x27;dev&#x27;</span>));<br>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">json</span>()); <span class="hljs-comment">//❗ 创建全局中间件 : 获取请求体(json格式)</span><br>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">urlencoded</span>(&#123; <span class="hljs-attr">extended</span>: <span class="hljs-literal">false</span> &#125;));  <span class="hljs-comment">//❗ 创建全局中间件 : 获取请求体(quirestring格式)</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">cookieParser</span>());<br>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">static</span>(path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;public&#x27;</span>))); <span class="hljs-comment">//❗ 创建静态资源中间件</span><br><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/&#x27;</span>, indexRouter); <span class="hljs-comment">// ❗路由中间件</span><br><br><span class="hljs-comment">// catch 404 and forward to error handler</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req, res, next</span>) &#123;<br>  <span class="hljs-title function_">next</span>(<span class="hljs-title function_">createError</span>(<span class="hljs-number">404</span>));<br>&#125;);<br><br><span class="hljs-comment">// error handler</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">err, req, res, next</span>) &#123;<br>  <span class="hljs-comment">// set locals, only providing error in development</span><br>  res.<span class="hljs-property">locals</span>.<span class="hljs-property">message</span> = err.<span class="hljs-property">message</span>;<br>  res.<span class="hljs-property">locals</span>.<span class="hljs-property">error</span> = req.<span class="hljs-property">app</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;env&#x27;</span>) === <span class="hljs-string">&#x27;development&#x27;</span> ? err : &#123;&#125;;<br><br>  <span class="hljs-comment">// render the error page</span><br>  res.<span class="hljs-title function_">status</span>(err.<span class="hljs-property">status</span> || <span class="hljs-number">500</span>);<br>  res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;error&#x27;</span>);<br>&#125;);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = app; <span class="hljs-comment">// 导出, 最终是在www文件中start</span><br><br></code></pre></td></tr></table></figure><h2 id="Mongodb-连接"><a href="#Mongodb-连接" class="headerlink" title="Mongodb 连接"></a>Mongodb 连接</h2><p>下载 mongdb —  省略</p><p><strong>启动服务</strong></p><blockquote><p>记得在 cmd 中先启动服务 (两个 cmd 窗口分别启动)</p></blockquote><ol><li>运行命令 mongod</li><li>运行命令 mongosh 连接本机的 mongodb 服务</li></ol><p><strong>使用 mongoose</strong></p><p><code>npm i mongoose</code> : 先安装 mongoose </p><blockquote><p>Mongoose 是一个对象文档模型库 , 为了方便使用代码操作 mongodb数据库</p></blockquote><p><strong>Mongoose 代码模块化</strong></p><p>我们将 mongoose 的基本使用封装为一个 db 文件, 里面装一个函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; success  数据库连接成功的回调</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; error  数据库连接失败的回调</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// db/db.js</span><br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">success, error</span>) &#123;<br><br>    <span class="hljs-comment">// 判断是否传入error, 给默认失败回调</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> error !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>        <span class="hljs-comment">// 给个默认值</span><br>        error = <span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;连接失败&#x27;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mongoose&#x27;</span>);<br><br>    <span class="hljs-comment">// weirdo是数据库的名称(不存在会自动创建) , 27017是mongodb的默认端口号(可以不写)</span><br>    mongoose.<span class="hljs-title function_">connect</span>(<span class="hljs-string">&#x27;mongodb://127.0.0.1:27017/weirdo&#x27;</span>) <br>    <br>    <span class="hljs-comment">// 设置连接成功的回调, once只执行一次, 用on的话掉线回来后还会执行</span><br>    mongoose.<span class="hljs-property">connection</span>.<span class="hljs-title function_">once</span>(<span class="hljs-string">&#x27;open&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">success</span>();<br>    &#125;)<br>    <br>    <span class="hljs-comment">//设置连接错误的回调</span><br>    mongoose.<span class="hljs-property">connection</span>.<span class="hljs-title function_">once</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">error</span>()<br>    &#125;)<br>    <br>    <span class="hljs-comment">// 设置连接关闭的回调</span><br>    mongoose.<span class="hljs-property">connection</span>.<span class="hljs-title function_">once</span>(<span class="hljs-string">&#x27;close&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;连接关闭&#x27;</span>);<br>    &#125;)<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们就可以在需要使用的地方使用db函数连接数据库即可</p><ol><li><p>导入db文件</p></li><li><p>导入模型对象</p></li></ol><p>我们还准备把数据库的一些信息单独拿出来, 做一个配置文件config, 那么以后信息需要修改的时候也比较方便</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// config/config.js  配置文件</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-attr">DBHOST</span>: <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<br>    <span class="hljs-attr">DBPORT</span>: <span class="hljs-string">&#x27;27017&#x27;</span>,<br>    <span class="hljs-attr">DBNAME</span>: <span class="hljs-string">&#x27;weirdo&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>然后到db.js文件中使用即可</p><p><strong>在www文件中导入并调用db函数</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// www</span><br><span class="hljs-keyword">const</span> db = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;../db/db&quot;</span>); <span class="hljs-comment">// 导入db函数</span><br><br><span class="hljs-comment">// 调用db函数 , 数据库连接上再启动http服务, 否则没有意义</span><br><span class="hljs-title function_">db</span>(<span class="hljs-function">() =&gt;</span> &#123;<br> ...<br> ...<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>创建<code>AccountModel.js</code> 模型对象</strong></p><p>我们在根目录下创建一个modules文件夹, 存放一些数据库需要的模型对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// modules/AccountModel.js</span><br><span class="hljs-keyword">const</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mongoose&#x27;</span>)<br><br><span class="hljs-keyword">let</span> <span class="hljs-title class_">AccountSchema</span> = <span class="hljs-keyword">new</span> mongoose.<span class="hljs-title class_">Schema</span>(&#123;<br>    <span class="hljs-attr">title</span>: &#123; <span class="hljs-comment">// 标题</span><br>        <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,<br>        <span class="hljs-attr">require</span>: <span class="hljs-literal">true</span>,<br>    &#125;, <br>    <span class="hljs-attr">time</span>: <span class="hljs-title class_">Date</span>, <span class="hljs-comment">// 时间</span><br>    <span class="hljs-attr">type</span>: &#123;  <span class="hljs-comment">//类型</span><br>        <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>,<br>        <span class="hljs-attr">default</span>: -<span class="hljs-number">1</span>,<br>    &#125;,<br>    <span class="hljs-attr">account</span>: &#123;<br>        <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>,<br>        <span class="hljs-attr">require</span>: <span class="hljs-literal">true</span><br>    &#125;,<br>    <span class="hljs-attr">remarks</span>: &#123;<br>        <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,<br>    &#125;<br>&#125;)<br><br><span class="hljs-comment">// 创建模型对象 : 对文档操作的封装对象</span><br><span class="hljs-comment">// 第一个参数是集合名称, 第二个参数为结构对象</span><br><span class="hljs-keyword">let</span> <span class="hljs-title class_">AccountModel</span> = mongoose.<span class="hljs-title function_">model</span>(<span class="hljs-string">&#x27;accounts&#x27;</span>, <span class="hljs-title class_">AccountSchema</span>);<br><br><span class="hljs-comment">//暴露模型对象</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">AccountModel</span>;<br></code></pre></td></tr></table></figure><p>这里由于我们的时间<code>time</code>在最后获取到的是一个字符串, 我们要将它转换为<code>Date</code>型, 就要用到一个工具包</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i moment<br></code></pre></td></tr></table></figure><p><strong>插入数据</strong></p><blockquote><p>routes&#x2F;index.js</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 新增记录</span><br>router.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/account&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 在app.js中已经添加了body-parser中间件</span><br>  <span class="hljs-title class_">AccountModel</span>.<span class="hljs-title function_">create</span>(&#123;<br>    ...req.<span class="hljs-property">body</span>,<br>    <span class="hljs-comment">// 修改time属性的值</span><br>    <span class="hljs-attr">time</span>: <span class="hljs-title function_">moment</span>(req.<span class="hljs-property">body</span>.<span class="hljs-property">time</span>).<span class="hljs-title function_">toDate</span>() <span class="hljs-comment">// 将字符串修改为时间对象</span><br>  &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;success&#x27;</span>, &#123;<span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;添加成功hhh&#x27;</span>, <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/account&#x27;</span>&#125;)<br>  &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>    res.<span class="hljs-title function_">status</span>(<span class="hljs-number">500</span>).<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;插入失败&#x27;</span>)<br>  &#125;)<br>  <br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>读取数据</strong></p><blockquote><p>routes&#x2F;index.js</p></blockquote><p>这里用到了格式化时间, 同样需要导入<code>moment</code>, 然后这里传递<code>moment</code>到<code>ejs</code>去</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 记账本的列表</span><br>router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/account&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">req, res, next</span>) &#123;<br>  <span class="hljs-comment">// 获取所有的账单信息</span><br>  <span class="hljs-title class_">AccountModel</span>.<span class="hljs-title function_">find</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>      res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;list&#x27;</span>, &#123;<span class="hljs-attr">accounts</span>: data, <span class="hljs-attr">moment</span>: moment, <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/account/create&#x27;</span>&#125;)<br>  &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    res.<span class="hljs-title function_">status</span>(<span class="hljs-number">500</span>).<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;读取失败&#x27;</span>)<br>  &#125;)<br>&#125;);<br></code></pre></td></tr></table></figure><p>然后使用格式化时间</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202311271440681.png" alt="img"></p><p>另外, 由于数据库里面的<code>id</code>是<code>_id</code>, 所以我们将<code>list.ejs</code>的相关字段改一下</p><blockquote><p>其实不改也行, mongodb默认也会帮我们操作</p></blockquote><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202311271440676.png" alt="img"></p><p><strong>删除数据</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 删除记录 (根据id进行删除)</span><br>router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/account/:id&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 获取params的id参数</span><br>  <span class="hljs-keyword">let</span> id = req.<span class="hljs-property">params</span>.<span class="hljs-property">id</span>;<br>  <span class="hljs-title class_">AccountModel</span>.<span class="hljs-title function_">deleteOne</span>(&#123;<br>    <span class="hljs-attr">_id</span>: id,<br>  &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;success&#x27;</span>, &#123;<span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;删除成功hhh&#x27;</span>, <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/account&#x27;</span>&#125;)<br>  &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    res.<span class="hljs-title function_">status</span>(<span class="hljs-number">500</span>).<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;删除失败&#x27;</span>)<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>为了使前端不要误操作, 我们给删除按钮添加一个验证</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// list.ejs</span><br><span class="hljs-keyword">let</span> delBtns = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;.delBtn&#x27;</span>);<br>delBtns.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>  item.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-title function_">confirm</span>(<span class="hljs-string">&#x27;您确定要删除该条文档吗?&#x27;</span>)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      e.<span class="hljs-title function_">preventDefault</span>()<br>    &#125;<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="添加接口功能"><a href="#添加接口功能" class="headerlink" title="添加接口功能"></a>添加接口功能</h2><p>为了将来我们在app, 安卓, ios中开发完程序后, 到时候直接和接口对接, 那么整个功能就完成了</p><p>首先先启动 mongod 服务, 然后本地连接 mongosh </p><p>npm start 打开我们通过 express-generator 做的记账本案例</p><p>在routes下添加以下文件</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202311271445059.png" alt="img"></p><p>这里的web&#x2F;index.js就是原先的index.js</p><p>另外, 在app.js中修改相关代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> indexRouter = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./routes/web/index&quot;</span>);<br><span class="hljs-keyword">const</span> accountRouter = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./routes/api/account&quot;</span>); <span class="hljs-comment">// 导入 account 接口路由文件</span><br>...<br>...<br>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&quot;/&quot;</span>, indexRouter);<br>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&quot;/api&quot;</span>, accountRouter);<br></code></pre></td></tr></table></figure><p>这样, 我们通过<code>api</code>访问到的就是接口返回的信息了</p><p>api&#x2F;account.js 代码如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;express&quot;</span>);<br><span class="hljs-keyword">var</span> router = express.<span class="hljs-title class_">Router</span>();<br><br><span class="hljs-keyword">const</span> moment = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;moment&quot;</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">AccountModel</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;../../modules/AccountModel&quot;</span>);<br><br><span class="hljs-comment">// 记账本的列表</span><br>router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/account&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br>  <span class="hljs-comment">// 获取所有的账单信息</span><br>  <span class="hljs-title class_">AccountModel</span>.<span class="hljs-title function_">find</span>()<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>      res.<span class="hljs-title function_">json</span>(&#123;<br>        <span class="hljs-attr">code</span>: <span class="hljs-string">&#x27;0000&#x27;</span>, <span class="hljs-comment">// 响应编号, 0000表示成功</span><br>        <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;读取成功&#x27;</span>, <span class="hljs-comment">// 响应的信息</span><br>        <span class="hljs-attr">data</span>: data, <span class="hljs-comment">// 响应的数据</span><br>      &#125;)<br>    &#125;)<br>    .<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      res.<span class="hljs-title function_">json</span>(&#123;<br>        <span class="hljs-attr">code</span>: <span class="hljs-string">&#x27;1001&#x27;</span>,<br>        <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;读取失败&#x27;</span>,<br>        <span class="hljs-attr">data</span>: <span class="hljs-literal">null</span><br>      &#125;)<br>    &#125;);<br>&#125;);<br><br><span class="hljs-comment">// 新增记录</span><br>router.<span class="hljs-title function_">post</span>(<span class="hljs-string">&quot;/account&quot;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// ❗在这之前可以进行表单验证</span><br><br>  <span class="hljs-comment">// 在app.js中已经添加了body-parser中间件</span><br>  <span class="hljs-title class_">AccountModel</span>.<span class="hljs-title function_">create</span>(&#123;<br>    ...req.<span class="hljs-property">body</span>,<br>    <span class="hljs-comment">// 修改time属性的值</span><br>    <span class="hljs-attr">time</span>: <span class="hljs-title function_">moment</span>(req.<span class="hljs-property">body</span>.<span class="hljs-property">time</span>).<span class="hljs-title function_">toDate</span>(),<br>  &#125;)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>      res.<span class="hljs-title function_">json</span>(&#123;<br>        <span class="hljs-attr">code</span>: <span class="hljs-string">&#x27;0000&#x27;</span>,<br>        <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;添加成功&#x27;</span>,<br>        <span class="hljs-attr">data</span>: data<br>      &#125;)<br>    &#125;)<br>    .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>      res.<span class="hljs-title function_">json</span>(&#123;<br>        <span class="hljs-attr">code</span>: <span class="hljs-string">&#x27;1002&#x27;</span>,<br>        <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;添加失败&#x27;</span>,<br>        <span class="hljs-attr">data</span>: <span class="hljs-literal">null</span><br>      &#125;)<br>    &#125;);<br>&#125;);<br><br><span class="hljs-comment">// 删除记录 (根据id进行删除)</span><br>router.<span class="hljs-title function_">delete</span>(<span class="hljs-string">&quot;/account/:id&quot;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 获取params的id参数</span><br>  <span class="hljs-keyword">let</span> id = req.<span class="hljs-property">params</span>.<span class="hljs-property">id</span>;<br>  <span class="hljs-title class_">AccountModel</span>.<span class="hljs-title function_">deleteOne</span>(&#123;<br>    <span class="hljs-attr">_id</span>: id,<br>  &#125;)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      res.<span class="hljs-title function_">json</span>(&#123;<br>        <span class="hljs-attr">code</span>: <span class="hljs-string">&#x27;0000&#x27;</span>,<br>        <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;删除成功&#x27;</span>,<br>        <span class="hljs-attr">data</span>: &#123;&#125;<br>      &#125;)<br>    &#125;)<br>    .<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      res.<span class="hljs-title function_">json</span>(&#123;<br>        <span class="hljs-attr">code</span>: <span class="hljs-string">&#x27;1003&#x27;</span>,<br>        <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;删除失败&#x27;</span>,<br>        <span class="hljs-attr">data</span>: <span class="hljs-literal">null</span><br>      &#125;)<br>    &#125;);<br>&#125;);<br><br><span class="hljs-comment">// 获取单个账单信息</span><br>router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/account/:id&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> &#123;id&#125; = req.<span class="hljs-property">params</span>;<br>    <span class="hljs-title class_">AccountModel</span>.<span class="hljs-title function_">findById</span>(id).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>        res.<span class="hljs-title function_">json</span>(&#123;<br>            <span class="hljs-attr">code</span>: <span class="hljs-string">&#x27;0000&#x27;</span>,<br>            <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;获取成功&#x27;</span>,<br>            <span class="hljs-attr">data</span>: data<br>        &#125;)<br>    &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>        res.<span class="hljs-title function_">json</span>(&#123;<br>            <span class="hljs-attr">code</span>: <span class="hljs-string">&#x27;1004&#x27;</span>,<br>            <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;获取失败&#x27;</span>,<br>            <span class="hljs-attr">data</span>: <span class="hljs-literal">null</span><br>        &#125;)<br>    &#125;)<br>&#125;)<br><br><span class="hljs-comment">// 更新单个账单信息</span><br>router.<span class="hljs-title function_">patch</span>(<span class="hljs-string">&#x27;/account/:id&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> &#123;id&#125; = req.<span class="hljs-property">params</span>;<br>    <span class="hljs-title class_">AccountModel</span>.<span class="hljs-title function_">updateOne</span>(&#123;<span class="hljs-attr">_id</span>: id&#125;, req.<span class="hljs-property">body</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-comment">// 更新成功后返回更新后的数据</span><br>        <span class="hljs-title class_">AccountModel</span>.<span class="hljs-title function_">findById</span>(id).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>            res.<span class="hljs-title function_">json</span>(&#123;<br>                <span class="hljs-attr">code</span>: <span class="hljs-string">&#x27;0000&#x27;</span>,<br>                <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;更新成功&#x27;</span>,<br>                <span class="hljs-attr">data</span>: data<br>            &#125;)<br>        &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>            res.<span class="hljs-title function_">json</span>(&#123;<br>                <span class="hljs-attr">code</span>: <span class="hljs-string">&#x27;1004&#x27;</span>,<br>                <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;获取失败&#x27;</span>,<br>                <span class="hljs-attr">data</span>: <span class="hljs-literal">null</span><br>            &#125;)<br>        &#125;)<br>    &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>        res.<span class="hljs-title function_">json</span>(&#123;<br>            <span class="hljs-attr">code</span>: <span class="hljs-string">&#x27;1005&#x27;</span>,<br>            <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;更新失败&#x27;</span>,<br>            <span class="hljs-attr">data</span>: <span class="hljs-literal">null</span><br>        &#125;)<br>    &#125;)<br>&#125;)<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = router;<br></code></pre></td></tr></table></figure><blockquote><p>只是将之前返回的数据变为了json, 之前是 res.render 渲染 ejs 页面, 现在是返回 json 数据</p></blockquote><p>这样我们就可以在apipost中进行各种操作了</p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202311271447503.png" alt="img" style="zoom: 50%;" /><h2 id="会话控制"><a href="#会话控制" class="headerlink" title="会话控制"></a>会话控制</h2><p><strong>cookie</strong></p><blockquote><p>如果是通过 express-generator 进行创建项目的话就不用自己搭建了, 这里使用的是原生express</p><p>npm i express   :  注意要安装获取 cookie 的包</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-comment">//1. 安装 cookie-parser npm i cookie-parser</span><br><span class="hljs-comment">//2. 引入 cookieParser 包</span><br><span class="hljs-keyword">const</span> cookieParser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;cookie-parser&#x27;</span>);<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br><br><span class="hljs-comment">//3. 设置 cookieParser 中间件</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">cookieParser</span>());<br><br><span class="hljs-comment">//4-1 设置 cookie</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/set-cookie&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;<br>    response.<span class="hljs-title function_">cookie</span>(<span class="hljs-string">&#x27;username&#x27;</span>,<span class="hljs-string">&#x27;wangwu&#x27;</span>); <span class="hljs-comment">// 不带时效性, 关闭浏览器就没了</span><br>    response.<span class="hljs-title function_">cookie</span>(<span class="hljs-string">&#x27;email&#x27;</span>,<span class="hljs-string">&#x27;23123456@qq.com&#x27;</span>, &#123;<span class="hljs-attr">maxAge</span>: <span class="hljs-number">5</span>*<span class="hljs-number">60</span>*<span class="hljs-number">1000</span> &#125;); <span class="hljs-comment">// 带时效性</span><br>    response.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Cookie的设置&#x27;</span>); <span class="hljs-comment">//响应</span><br>&#125;);<br><br><span class="hljs-comment">//4-2 读取 cookie</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/get-cookie&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(request.<span class="hljs-property">cookies</span>); <span class="hljs-comment">//读取所有 cookie</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(request.<span class="hljs-property">cookies</span>.<span class="hljs-property">username</span>) <span class="hljs-comment">// 单独读取 cookie</span><br>    response.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Cookie的读取&#x27;</span>); <span class="hljs-comment">//响应体</span><br>&#125;);<br><br><br><span class="hljs-comment">// 4-3 删除cookie (一般用户退出登录的时候会用到)</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/delete-cookie&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    res.<span class="hljs-title function_">clearCookie</span>(<span class="hljs-string">&#x27;username&#x27;</span>);<br>    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;删除成功&#x27;</span>)<br>&#125;)<br><br><br><span class="hljs-comment">//启动服务</span><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;服务已经启动....&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>session</strong></p><p>session 是保存在 服务器端的一块儿数据 ，保存当前访问用户的相关信息</p><p>它可实现会话控制，可以识别用户的身份，快速获取当前用户的相关信息</p><blockquote><p>运行流程</p></blockquote><ol><li>填写账号和密码校验身份，校验通过后服务端创建 <code>session</code> 信息 ，然后将 <code>session_id</code> 的值通过响应头返回给浏览器</li><li>在登录(请求)了一次此网站后,  下次发送请求时会自动携带 <code>cookie</code>，服务器通过 <code>cookie</code> 中的<code>session_id</code> 的值确定用户的身份</li></ol><blockquote><p>session 的代码操作</p></blockquote><p>安装 <code>npm i express-session</code>  它可在 <code>express</code> 中对 <code>session</code> 进行操作</p><p>安装 <code>npm i connect-mongo</code> , 可以连接 <code>mongodb</code>数据库, 也可以做一些操作, 这样就可以将session存到数据库</p><blockquote><p>记得要先把 mongodb 跑起来</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-comment">//1. 安装包 npm i express-session connect-mongo</span><br><span class="hljs-comment">//2. 引入 express-session connect-mongo</span><br><span class="hljs-keyword">const</span> session = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;express-session&quot;</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">MongoStore</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;connect-mongo&#x27;</span>);<br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br><br><span class="hljs-comment">//3. 设置 session 的中间件</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">session</span>(&#123;<br>     <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;sid&#x27;</span>, <span class="hljs-comment">//设置cookie的name，默认值是：connect.sid</span><br>     <span class="hljs-attr">secret</span>: <span class="hljs-string">&#x27;atguigu&#x27;</span>, <span class="hljs-comment">//参与加密的字符串（又称签名）❗加盐</span><br>      <br>     <span class="hljs-attr">saveUninitialized</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">//是否为每次请求都设置一个cookie用来存储session的id</span><br>     <span class="hljs-comment">//不用就不创建, 除非对匿名用户信息做记录, 就可以设置为 true</span><br>        <br>     <span class="hljs-attr">resave</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">//是否在每次请求时重新保存session (比如可以更新session的过期时间)</span><br>     <span class="hljs-comment">// 一直发请求就不会重新登录, 长时间操作过了session过期时间就又要重新登录了</span><br>     <br>     <span class="hljs-attr">store</span>: <span class="hljs-title class_">MongoStore</span>.<span class="hljs-title function_">create</span>(&#123;<br>         <span class="hljs-attr">mongoUrl</span>: <span class="hljs-string">&#x27;mongodb://127.0.0.1:27017/weirdo&#x27;</span> <span class="hljs-comment">//数据库的连接配置</span><br>     &#125;),<br>     <span class="hljs-attr">cookie</span>: &#123;<br>        <span class="hljs-attr">httpOnly</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 开启后前端无法通过 JS 进行访问(比如 document.cookie)</span><br>        <span class="hljs-attr">maxAge</span>: <span class="hljs-number">1000</span> * <span class="hljs-number">300</span> <span class="hljs-comment">// 这一条 是控制 sessionID 的过期时间的！！</span><br>        <span class="hljs-comment">// session 和 cookie 都可以通过这个设置</span><br>    &#125;,<br>&#125;))<br><br><span class="hljs-comment">//创建 session</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/login&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">//设置session</span><br>    <span class="hljs-comment">// 满足某条件(比如用户名和密码输入正确)设置session</span><br>    <span class="hljs-keyword">if</span>(req.<span class="hljs-property">query</span>.<span class="hljs-property">username</span> === <span class="hljs-string">&#x27;admin&#x27;</span> &amp;&amp; req.<span class="hljs-property">query</span>.<span class="hljs-property">password</span> === <span class="hljs-string">&#x27;admin&#x27;</span>) &#123;<br>         req.<span class="hljs-property">session</span>.<span class="hljs-property">username</span> = <span class="hljs-string">&#x27;zhangsan&#x27;</span>;<br>         req.<span class="hljs-property">session</span>.<span class="hljs-property">email</span> = <span class="hljs-string">&#x27;zhangsan@qq.com&#x27;</span><br>         res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;登录成功&#x27;</span>);<br>    &#125;<br>    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;登录失败&#x27;</span>);<br>&#125;)<br><br><span class="hljs-comment">//获取 session</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/home&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;session的信息&#x27;</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">session</span>.<span class="hljs-property">username</span>);<br>    <span class="hljs-keyword">if</span> (req.<span class="hljs-property">session</span>.<span class="hljs-property">username</span>) &#123;<br>        res.<span class="hljs-title function_">send</span>(<span class="hljs-string">`你好 <span class="hljs-subst">$&#123;req.session.username&#125;</span>`</span>);<br>    &#125; <span class="hljs-keyword">else</span>&#123;<br>        res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;登录 注册&#x27;</span>);<br>    &#125;<br>&#125;)<br><br><span class="hljs-comment">//销毁 session</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/logout&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">//销毁session</span><br>    <span class="hljs-comment">// res.send(&#x27;设置session&#x27;);</span><br>    req.<span class="hljs-property">session</span>.<span class="hljs-title function_">destroy</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;成功退出&#x27;</span>);<br>    &#125;);<br>&#125;);<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;服务已经启动, 端口 &#x27;</span> + <span class="hljs-number">3000</span> + <span class="hljs-string">&#x27; 监听中...&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>session 和 cookie 的区别</strong></p><ol><li>存在的位置<ol><li>cookie：浏览器端</li><li>session：服务端</li></ol></li><li>安全性<ol><li>cookie 是以明文的方式存放在客户端的，安全性相对较低</li><li>session 存放于服务器中，所以安全性 相对 较好</li></ol></li><li>网络传输量<ol><li>cookie 设置内容过多会增大报文体积， 会影响传输效率</li><li>session 数据存储在服务器，只是通过 cookie 传递 id，所以不影响传输效率</li></ol></li><li>存储限制<ol><li>浏览器限制单个 cookie 保存的数据不能超过 4K ，且单个域名下的存储数量也有限制</li><li>session 数据存储在服务器中，所以没有这些限制</li></ol></li></ol><p><strong>token</strong></p><p>token 是服务端生成并返回给 HTTP 客户端的一串加密字符串， token 中保存着 用户信息</p><p>它可以实现会话控制，可以识别用户的身份，主要用于移动端 APP</p><blockquote><p>工作流程</p></blockquote><p>填写账号和密码校验身份，校验通过后响应 token，token 一般是在响应体中返回给客户端的</p><p>后续发送请求时，需要手动将 token 添加在请求报文中，一般是放在请求头中</p><blockquote><p>特点</p></blockquote><ul><li>服务端压力更小<ul><li>数据存储在客户端</li></ul></li><li>相对更安全<ul><li>数据加密</li><li>可以避免 CSRF（跨站请求伪造）因为不能自动携带</li></ul></li><li>扩展性更强<ul><li>服务间可以共享</li><li>增加服务节点更简单</li></ul></li></ul><p><strong>和 cookie 的区别</strong></p><ul><li><p>token 手动携带</p></li><li><p>cookie 自动携带</p></li></ul><p><strong>jwt</strong></p><p>JWT（JSON Web Token ）是目前最流行的跨域认证解决方案，可用于基于 token 的身份验证</p><p>JWT 使 token 的生成与校验更规范</p><blockquote><p>我们可以使用 jsonwebtoken 包 来操作 token</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript">npm i jsonwebtoken<br><span class="hljs-comment">//导入 jsonwebtokan</span><br><span class="hljs-keyword">const</span> jwt = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;jsonwebtoken&#x27;</span>);<br><br><span class="hljs-comment">//创建 token</span><br><span class="hljs-comment">// jwt.sign(三个参数 : 数据, 加密字符串, 配置对象)</span><br><span class="hljs-keyword">let</span> token = jwt.<span class="hljs-title function_">sign</span>(&#123; <span class="hljs-comment">// 创建token </span><br>    <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;zhangsan&#x27;</span><br>&#125;, <span class="hljs-string">&#x27;zhaoweirduohaoshuai&#x27;</span>, &#123;<br>    <span class="hljs-attr">expiresIn</span>: <span class="hljs-number">60</span> <span class="hljs-comment">// token的声明周期, 单位是秒</span><br>&#125;)<br><br><span class="hljs-comment">//解析(校验) token</span><br>jwt.<span class="hljs-title function_">verify</span>(token, <span class="hljs-string">&#x27;zhaoweiduohaoshuai&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span>(err)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;校验失败~~&#x27;</span>);<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="项目完善"><a href="#项目完善" class="headerlink" title="项目完善"></a>项目完善</h2><p>我们先在 views 文件夹下创建 req.ejs 文件用来存放注册页面</p><p>然后我们在web文件夹下新建一个文件 auth.js 用来存放登录和注册所要用到的路由</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// routes/web/auth.js</span><br><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;express&quot;</span>);<br><span class="hljs-keyword">var</span> router = express.<span class="hljs-title class_">Router</span>();<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">UserModel</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;../../modules/UserModel.js&#x27;</span>)<br><span class="hljs-keyword">const</span> md5 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;md5&#x27;</span>)<br><span class="hljs-comment">// 在存放数据的时候, 密码我们需要进行加密, 所以 npm i md5, 然后导入即可</span><br><br><span class="hljs-comment">// 注册页面</span><br>router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/reg&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;reg&#x27;</span>)<br>&#125;)<br><br><span class="hljs-comment">// 注册用户</span><br>router.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/reg&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 做表单验证(这里就不做了)</span><br>    <span class="hljs-title class_">UserModel</span>.<span class="hljs-title function_">create</span>(&#123;<br>        ...req.<span class="hljs-property">body</span>,<br>        <span class="hljs-attr">password</span>: <span class="hljs-title function_">md5</span>(req.<span class="hljs-property">body</span>.<span class="hljs-property">password</span>), <span class="hljs-comment">// 对密码进行加密</span><br>    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>       res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&quot;success&quot;</span>, &#123; <span class="hljs-attr">msg</span>: <span class="hljs-string">&quot;注册成功hhh&quot;</span>, <span class="hljs-attr">url</span>: <span class="hljs-string">&quot;/login&quot;</span> &#125;);<br>    &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>         res.<span class="hljs-title function_">status</span>(<span class="hljs-number">500</span>).<span class="hljs-title function_">send</span>(<span class="hljs-string">&quot;注册失败&quot;</span>);<br>    &#125;);<br>      <br>&#125;)<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = router;<br></code></pre></td></tr></table></figure><p>这里你会发现我们对数据库存储数据, 我们需要一个UserModel</p><p>我们在这个文件中将数据存储到数据库中, 我们就还需要一个model</p><p>所以我们在 modules 文件夹下新建一个 UserModel.js </p><blockquote><p> 接收两个数据, 用户名和密码, 并将数据存放在 users 数据库集合中</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mongoose&#x27;</span>)<br><br><span class="hljs-keyword">let</span> <span class="hljs-title class_">UserSchema</span> = <span class="hljs-keyword">new</span> mongoose.<span class="hljs-title class_">Schema</span>(&#123;<br>    <span class="hljs-attr">username</span>: &#123; <span class="hljs-comment">// 标题</span><br>        <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,<br>        <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>,<br>    &#125;, <br>    <span class="hljs-attr">password</span>: &#123;  <span class="hljs-comment">//类型</span><br>        <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,<br>        <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span><br>    &#125;,<br>&#125;)<br><br><span class="hljs-comment">// 创建模型对象 : 对文档操作的封装对象</span><br><span class="hljs-comment">// 第一个参数是集合名称, 第二个参数为结构对象</span><br><span class="hljs-keyword">let</span> <span class="hljs-title class_">UserModel</span> = mongoose.<span class="hljs-title function_">model</span>(<span class="hljs-string">&#x27;users&#x27;</span>, <span class="hljs-title class_">UserSchema</span>);<br><br><span class="hljs-comment">//暴露模型对象</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">UserModel</span>;<br></code></pre></td></tr></table></figure><p>然后我们在 app.js 中导入登录和注册的全局中间件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">...<br><span class="hljs-keyword">const</span> authRouter = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./routes/web/auth&quot;</span>);<br>...<br>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&quot;&quot;</span>, authRouter);<br></code></pre></td></tr></table></figure><p>同样我们在 views 下添加 login.ejs 页面</p><p>由于登录时我们也是需要拿到加密后的密码和数据库中的密码进行比对, 也是需要md5加密</p><p>然后我们在 auth.js 中写入登录的相关操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// web/auth.js</span><br><span class="hljs-comment">// 登录页面</span><br>router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/login&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;login&#x27;</span>)<br>&#125;)<br><br><span class="hljs-comment">// 登录操作</span><br>router.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/login&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 获取用户名和密码</span><br>    <span class="hljs-keyword">let</span> &#123;username, password&#125; = req.<span class="hljs-property">body</span><br>    <span class="hljs-comment">// 查询数据库</span><br>    <span class="hljs-title class_">UserModel</span>.<span class="hljs-title function_">findOne</span>(&#123;<br>        <span class="hljs-attr">username</span>: username, <br>        <span class="hljs-attr">password</span>: <span class="hljs-title function_">md5</span>(password)<br>    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>       <span class="hljs-keyword">if</span>(!data) res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;账号或者密码错误&#x27;</span>)  <br>       <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 写入session</span><br>            req.<span class="hljs-property">session</span>.<span class="hljs-property">username</span> = data.<span class="hljs-property">username</span>; <span class="hljs-comment">// 待会就会根据是否有username判断session</span><br>            req.<span class="hljs-property">session</span>.<span class="hljs-property">_id</span> = data.<span class="hljs-property">_id</span>  <span class="hljs-comment">// 用户文档的id, 不是session ID</span><br>            res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&quot;success&quot;</span>, &#123; <span class="hljs-attr">msg</span>: <span class="hljs-string">&quot;登录成功hhh&quot;</span>, <span class="hljs-attr">url</span>: <span class="hljs-string">&quot;/account&quot;</span> &#125;);<br>       &#125;<br>    &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>       res.<span class="hljs-title function_">status</span>(<span class="hljs-number">500</span>).<span class="hljs-title function_">send</span>(<span class="hljs-string">&quot;登录失败&quot;</span>);<br>    &#125;);<br>&#125;)<br></code></pre></td></tr></table></figure><p>查询数据库时, 如果data没有值才说明账号或者密码错误, 如果登录成功那还要写入session</p><p>写入session我们就需要用到 两个包, 第一个是用express进行session操作, 第二个是连接mongdb数据库</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">npm i express-<span class="hljs-keyword">session</span> <span class="hljs-keyword">connect</span>-mongo<br></code></pre></td></tr></table></figure><p>然后我们在app.js中进行导入session的中间件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 导入express-session</span><br><span class="hljs-keyword">const</span> session = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;express-session&quot;</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">MongoStore</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;connect-mongo&quot;</span>);<br><br>...<br><br><span class="hljs-comment">//导入配置项</span><br><span class="hljs-keyword">const</span> &#123;<span class="hljs-variable constant_">DBHOST</span>, <span class="hljs-variable constant_">DBNAME</span>, <span class="hljs-variable constant_">DBPORT</span>&#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./config/config&#x27;</span>)<br><span class="hljs-keyword">var</span> app = <span class="hljs-title function_">express</span>();<br><br><span class="hljs-comment">// 设置 session 的中间件</span><br>app.<span class="hljs-title function_">use</span>(<br>  <span class="hljs-title function_">session</span>(&#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;sid&quot;</span>, <span class="hljs-comment">//设置cookie的name，默认值是：connect.sid</span><br>    <span class="hljs-attr">secret</span>: <span class="hljs-string">&quot;atguigu&quot;</span>, <span class="hljs-comment">//参与加密的字符串（又称签名）❗加盐</span><br><br>    <span class="hljs-attr">saveUninitialized</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">//是否为每次请求都设置一个cookie用来存储session的id</span><br>    <span class="hljs-comment">//不用就不创建, 除非对匿名用户信息做记录, 就可以设置为 true</span><br><br>    <span class="hljs-attr">resave</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">//是否在每次请求时重新保存session (比如可以更新session的过期时间)</span><br>    <span class="hljs-comment">// 一直发请求就不会重新登录, 长时间操作过了session过期时间就又要重新登录了</span><br><br>    <span class="hljs-attr">store</span>: <span class="hljs-title class_">MongoStore</span>.<span class="hljs-title function_">create</span>(&#123;<br>      <span class="hljs-attr">mongoUrl</span>: <span class="hljs-string">`mongodb://<span class="hljs-subst">$&#123;DBHOST&#125;</span>:<span class="hljs-subst">$&#123;DBPORT&#125;</span>/<span class="hljs-subst">$&#123;DBNAME&#125;</span>`</span>, <span class="hljs-comment">//数据库的连接配置</span><br>    &#125;),<br>    <span class="hljs-attr">cookie</span>: &#123;<br>      <span class="hljs-attr">httpOnly</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 开启后前端无法通过 JS 进行访问(比如 document.cookie)</span><br>      <span class="hljs-attr">maxAge</span>: <span class="hljs-number">1000</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span> * <span class="hljs-number">7</span>, <span class="hljs-comment">// 这一条 是控制 sessionID 的过期时间的！！</span><br>      <span class="hljs-comment">// session 和 cookie 都可以通过这个设置</span><br>    &#125;,<br>  &#125;)<br>);<br></code></pre></td></tr></table></figure><blockquote><p>另外我们这里的mongoUrl不能写死, 所以我们导入了配置项</p></blockquote><p><strong>用户登录检测</strong></p><p>我们访问 account 页面, 无痕模式发现都能进行操作, 这样是不行的, 只有登录了并且返回了session才能进行操作</p><p>所以我们在<code>web/index.js</code>中的每一个接口前加入以下判断</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">if</span>(!req.<span class="hljs-property">session</span>.<span class="hljs-property">username</span>) &#123; <span class="hljs-comment">// 根据是否有username判断session</span><br>     <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">redirect</span>(<span class="hljs-string">&#x27;/login&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现代码冗余, 于是我们将其封装为一个中间件</p><p>在根目录下创建 middlewares 文件夹存放中间件, 并将这段代码放进去</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// middlewares/checkLoginMiddlewares.js</span><br><span class="hljs-comment">// 检测登录的中间件</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 判断是否拥有session</span><br>    <span class="hljs-comment">// 这里判断的时候根据当时写入sesson具体字段即可,(比如session.username) 直接写session不行</span><br>    <span class="hljs-keyword">if</span>(!req.<span class="hljs-property">session</span>.<span class="hljs-property">username</span>) &#123; <br>      <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">redirect</span>(<span class="hljs-string">&#x27;/login&#x27;</span>);<br>    &#125;<br>    <span class="hljs-title function_">next</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在<code>index.js</code>中导入即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 导入中间件检测登录</span><br><span class="hljs-keyword">let</span> checkLoginMiddleware = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;../../middlewares/checkLoginMiddleware&#x27;</span>)<br>...<br>router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/account&quot;</span>, checkLoginMiddleware, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;...<br>router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/account/create&quot;</span>, checkLoginMiddleware, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;...<br>...<br></code></pre></td></tr></table></figure><p><strong>退出业务</strong></p><p>我们在auth.js中写退出相关接口</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 退出登录</span><br>router.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/logout&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 销毁session</span><br>    req.<span class="hljs-property">session</span>.<span class="hljs-title function_">destroy</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;success&#x27;</span>, &#123;<span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;退出成功&#x27;</span>, <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/login&#x27;</span>&#125;);<br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>主要的操作就是销毁<code>session</code>然后在回调函数中跳转页面</p><p>然后我们在 list.ejs 中添加一个按钮实现点击退出</p><p><strong>这里为什么不用 a 标签 然后里面href 写 ‘&#x2F;logout’ ?</strong></p><p>因为如果在其它端口通过<code>link/script/image</code>标签发送请求, 则也会导致退出登录  &#x3D;&gt;  即<strong>XSRF(跨站请求伪造)</strong></p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202311271458377.png" alt="img" style="zoom: 67%;" /><p>所以我们尽量改为post请求, 但是这样还远远不够哈, 具体的解决办法可以看自己的八股</p><p><strong>优化路由和首页</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// web/index.ts</span><br><span class="hljs-comment">// 添加首页的路由规则</span><br>router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">redirect</span>(<span class="hljs-string">&#x27;/account&#x27;</span>);  <span class="hljs-comment">// 在跳转到account页面时也会判断session的</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>我们创建一个 <code>404.ejs</code> 在url路径错误的情况下放一个公益页面</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">&lt;body&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;//volunteer.cdn-go.cn/404/latest/404.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><p>然后在app.js 中它帮我们写的位置修改一下, render 404页面</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// catch 404 and forward to error handler</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br>  res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;404&#x27;</span>)<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>JWT引入</strong></p><p> 目前还是存在bug, 因为我们的接口端(api那个)不受任何约束</p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202311271500879.png" alt="img" style="zoom:50%;" /><p>我们在 api 文件夹下创建一个 auth.js 来限制我们的登录</p><p>我们先安装 jsonwebtoken : <code>npm i jsonwebtoken</code></p><p>然后在 auth.js 中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// routes/api/autg.js</span><br><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;express&quot;</span>);<br><span class="hljs-keyword">var</span> router = express.<span class="hljs-title class_">Router</span>();<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">UserModel</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;../../modules/UserModel.js&quot;</span>);<br><span class="hljs-keyword">const</span> md5 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;md5&quot;</span>);<br><span class="hljs-keyword">const</span> jwt = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;jsonwebtoken&quot;</span>);<br><br><span class="hljs-comment">// 登录操作</span><br>router.<span class="hljs-title function_">post</span>(<span class="hljs-string">&quot;/login&quot;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 获取用户名和密码</span><br>  <span class="hljs-keyword">let</span> &#123; username, password &#125; = req.<span class="hljs-property">body</span>;<br>  <span class="hljs-comment">// 查询数据库</span><br>  <span class="hljs-title class_">UserModel</span>.<span class="hljs-title function_">findOne</span>(&#123;<br>    <span class="hljs-attr">username</span>: username,<br>    <span class="hljs-attr">password</span>: <span class="hljs-title function_">md5</span>(password),<br>  &#125;)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (!data) &#123;<br>        res.<span class="hljs-title function_">json</span>(&#123;<br>          <span class="hljs-attr">code</span>: <span class="hljs-string">&quot;2002&quot;</span>,<br>          <span class="hljs-attr">msg</span>: <span class="hljs-string">&quot;用户名或密码错误&quot;</span>,<br>          <span class="hljs-attr">data</span>: <span class="hljs-literal">null</span>,<br>        &#125;);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 创建当前用户的token</span><br>        <span class="hljs-keyword">let</span> token = jwt.<span class="hljs-title function_">sign</span>(<br>          &#123;<br>            <span class="hljs-attr">username</span>: data.<span class="hljs-property">username</span>,<br>            <span class="hljs-attr">_id</span>: data.<span class="hljs-property">_id</span>,<br>          &#125;,<br>          <span class="hljs-string">&quot;weirdo&quot;</span>,<br>          &#123;<br>            <span class="hljs-attr">expiresIn</span>: <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span> * <span class="hljs-number">7</span>,<br>          &#125;<br>        );<br><br>        <span class="hljs-comment">// 响应token(记得 npm i jsonwebtoken)</span><br>        res.<span class="hljs-title function_">json</span>(&#123;<br>          <span class="hljs-attr">code</span>: <span class="hljs-string">&quot;0000&quot;</span>,<br>          <span class="hljs-attr">msg</span>: <span class="hljs-string">&quot;登录成功&quot;</span>,<br>          <span class="hljs-attr">data</span>: token,<br>        &#125;);<br>      &#125;<br>    &#125;)<br>    .<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      res.<span class="hljs-title function_">status</span>(<span class="hljs-number">500</span>).<span class="hljs-title function_">send</span>(<span class="hljs-string">&quot;登录失败&quot;</span>);<br>      res.<span class="hljs-title function_">json</span>(&#123;<br>        <span class="hljs-attr">code</span>: <span class="hljs-string">&quot;2001&quot;</span>,<br>        <span class="hljs-attr">msg</span>: <span class="hljs-string">&quot;数据库读取失败&quot;</span>,<br>        <span class="hljs-attr">data</span>: <span class="hljs-literal">null</span>,<br>      &#125;);<br>    &#125;);<br>&#125;);<br><br><span class="hljs-comment">// 退出登录</span><br>router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/logout&quot;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 销毁session</span><br>  req.<span class="hljs-property">session</span>.<span class="hljs-title function_">destroy</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&quot;success&quot;</span>, &#123; <span class="hljs-attr">msg</span>: <span class="hljs-string">&quot;退出成功&quot;</span>, <span class="hljs-attr">url</span>: <span class="hljs-string">&quot;/login&quot;</span> &#125;);<br>  &#125;);<br>&#125;);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = router;<br></code></pre></td></tr></table></figure><p>对于api相关的接口进行token限制, 至于token如何在客户端进行的保存, 这就不知道了</p><p>这样我们在登录成功后就可以拿到token, 那么我们在访问关于account的相关接口时就要去校验</p><p>同理我们将校验token写为一个中间件, 放在middlewares文件夹中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// middlewares/checkTokenMiddlewares.js</span><br><br><span class="hljs-keyword">const</span> jwt = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;jsonwebtoken&#x27;</span>) <span class="hljs-comment">// 记得要导入</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 获取 token</span><br>  <span class="hljs-keyword">let</span> token = req.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;token&quot;</span>);<br>  <span class="hljs-keyword">if</span> (!token) &#123;<br>    <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">json</span>(&#123;<br>      <span class="hljs-attr">code</span>: <span class="hljs-string">&quot;2003&quot;</span>,<br>      <span class="hljs-attr">msg</span>: <span class="hljs-string">&quot;token 缺失&quot;</span>,<br>      <span class="hljs-attr">data</span>: <span class="hljs-literal">null</span>,<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-comment">// 校验 token</span><br>  jwt.<span class="hljs-title function_">verify</span>(token, <span class="hljs-string">&quot;weirdo&quot;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 检测token是否正确</span><br>    <span class="hljs-keyword">if</span> (err) &#123;<br>      <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">json</span>(&#123;<br>        <span class="hljs-attr">code</span>: <span class="hljs-string">&quot;2004&quot;</span>,<br>        <span class="hljs-attr">msg</span>: <span class="hljs-string">&quot;token校验失败&quot;</span>,<br>        <span class="hljs-attr">data</span>: <span class="hljs-literal">null</span>,<br>      &#125;);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 校验成功</span><br>      <span class="hljs-title function_">next</span>();<br>    &#125;<br>  &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure><p>然后在<code>api/account.js</code>中的每个接口使用即可</p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202311271501369.png" alt="img" style="zoom: 67%;" /><p>我们现在感觉 ‘<code>weirdo</code>‘ 这个密钥在创建和校验都使用了, 以后改起来不太方便, 于是我们将其放到配置文件中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 配置文件</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">DBHOST</span>: <span class="hljs-string">&quot;127.0.0.1&quot;</span>,<br>  <span class="hljs-attr">DBPORT</span>: <span class="hljs-string">&quot;27017&quot;</span>,<br>  <span class="hljs-attr">DBNAME</span>: <span class="hljs-string">&quot;weirdo&quot;</span>,  <span class="hljs-comment">// 这个是数据库集合名称</span><br>  <span class="hljs-attr">secret</span>: <span class="hljs-string">&quot;weirdo&quot;</span>, <span class="hljs-comment">// 这个是我们定义的jwt密钥</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>另外我们可以在校验token成功后<strong>保存用户的信息</strong></p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202311271502904.png" alt="img" style="zoom: 67%;" /><p>然后我们就可以在记账本其它的接口访问这个用户数据(req.user)了</p><blockquote><p>比如</p></blockquote><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202311271502793.png" alt="img" style="zoom:67%;" /><blockquote><p>后面的部署上线就自己去操作吧.</p></blockquote><h2 id="文件-图片-上传"><a href="#文件-图片-上传" class="headerlink" title="文件(图片)上传"></a>文件(图片)上传</h2><p>注意 这时候已经使用了express-generator</p><p>文件上传也是在发送<code>http</code>请求报文</p><p><code>npm i formidable</code> : 拿到<code>formidable</code>对象处理文件上传</p><blockquote><p>routes&#x2F;index.js</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;express&quot;</span>);<br><span class="hljs-keyword">var</span> router = express.<span class="hljs-title class_">Router</span>();<br><span class="hljs-keyword">let</span> &#123;formidable&#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;formidable&quot;</span>);  <span class="hljs-comment">// 这里formidable是一个对象, 要解构拿到</span><br><br><span class="hljs-comment">/* GET home page. */</span><br>router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br>  res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&quot;index&quot;</span>, &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Express&quot;</span> &#125;);<br>&#125;);<br><br><span class="hljs-comment">// 显示网页的 (表单)</span><br>router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/portrait&quot;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&quot;portrait&quot;</span>);<br>&#125;);<br><br><span class="hljs-comment">// 处理文件上传</span><br>router.<span class="hljs-title function_">post</span>(<span class="hljs-string">&quot;/portrait&quot;</span>, <span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 创建表单对象</span><br>  <span class="hljs-keyword">let</span> form = <span class="hljs-title function_">formidable</span>(&#123;<br>    <span class="hljs-comment">// 设置上传文件的保存目录</span><br>    <span class="hljs-attr">uploadDir</span>: __dirname + <span class="hljs-string">&#x27;/../public/images&#x27;</span>,<br>    <span class="hljs-comment">// 保持文件后缀</span><br>    <span class="hljs-attr">keepExtensions</span>: <span class="hljs-literal">true</span><br>  &#125;);<br><br>  <span class="hljs-comment">// 解析请求报文</span><br>  <span class="hljs-comment">// fields储存除了文件以外的字段</span><br>  <span class="hljs-comment">// files储存</span><br>  form.<span class="hljs-title function_">parse</span>(req, <span class="hljs-function">(<span class="hljs-params">err, fields, files</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err) &#123;<br>      <span class="hljs-title function_">next</span>(err);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 服务器保存该图片的访问 URL : images/46b9df33709488d18ff343900.jpg</span><br>    <span class="hljs-keyword">let</span> url = <span class="hljs-string">&#x27;/images/&#x27;</span> + files.<span class="hljs-property">portrait</span>[<span class="hljs-number">0</span>].<span class="hljs-property">newFilename</span>; <span class="hljs-comment">// 将来将此数据保存在数据库中</span><br>    <span class="hljs-comment">// 这里files.portrait是一个数组里面存放一个对象, 拿到即可</span><br><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(files);                 <br>    res.<span class="hljs-title function_">send</span>(url);<br>  &#125;);<br>&#125;);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = router;<br></code></pre></td></tr></table></figure><blockquote><p>portrait.ejs</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>文件上传<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 文件上传必须的属性设置 enctype=&quot;multipart/form-data&quot; --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/portrait&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;</span><br>        用户名: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>        头像 : <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;portrait&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>点击提交<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202311271415354.png" alt="img" style="zoom: 67%;" /><blockquote><p>get请求获取的表单</p></blockquote><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202311271415261.png" alt="img"></p><blockquote><p>点击提交后 (即 post 请求 &#x3D;&gt; 进行文件上传)</p></blockquote><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202311271415258.png" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>Node</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>😎flex布局详解</title>
    <link href="/2023/11/18/flex/"/>
    <url>/2023/11/18/flex/</url>
    
    <content type="html"><![CDATA[<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h1 id="flex-布局"><a href="#flex-布局" class="headerlink" title="flex 布局"></a>flex 布局</h1><blockquote><p>可以看这个</p></blockquote><p><a href="https://www.ruanyifeng.com/blog/2015/07/flex-examples.html">Flex 布局教程:实例篇 - 阮一峰的网络日志</a></p><h2 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h2><p>display 属性用来将父元素定义为 Flex 布局的容器，设置 display 值为 <code>display: flex;</code> </p><p>容器对外表现为块级元素；<code>display: inline-flex;</code> 容器对外表现为行内元素，对内两者表现是一样的。</p><blockquote><p>我们有以下六个属性可以设置的容器上：</p></blockquote><ul><li><code>flex-direction</code></li><li><code>flex-wrap</code></li><li><code>flex-flow</code></li><li><code>justify-content</code></li><li><code>align-items</code></li><li><code>align-content</code></li></ul><h4 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h4><p><code>flex-direction</code> 定义了主轴的方向，即项目的排列方向。</p><ul><li><code>row</code>（默认值）：主轴在水平方向，起点在左侧，也就是我们常见的从左到右；</li><li><code>row-reverse</code>：主轴在水平方向，起点在右侧；</li><li><code>column</code>：主轴在垂直方向，起点在上沿；</li><li><code>column-reverse</code>： 主轴在垂直方向，起点在下沿。</li></ul><h4 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h4><p>默认情况下，项目是排成一行显示的，<code>flex-wrap</code> 用来定义当一行放不下时，项目如何换行。</p><p>假设此时主轴是从左到右的水平方向：</p><ul><li><code>nowrap</code>（默认）：不换行；</li><li><code>wrap</code>：换行，第一行在上面；</li><li><code>wrap-reverse</code>：换行，第一行在下面。</li></ul><h4 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h4><p><code>flex-flow</code> 是 <code>flex-direction </code>和 <code>flex-wrap</code> 的简写，默认值是 <code>row no-wrap</code>。</p><h4 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h4><p><code>justify-content</code> 定义了项目在主轴上的对齐方式。</p><ul><li><code>flex-start</code>（默认）：与主轴的起点对齐；</li><li><code>flex-end</code>：与主轴的终点对齐；</li><li><code>center</code>：项目居中；</li><li><code>space-between</code>：两端对齐，项目之间的距离都相等；</li><li><code>space-around</code>：每个项目的两侧间隔相等，所以项目与项目之间的间隔是项目与边框之间间隔的两倍。</li></ul><h4 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h4><p><code>align-items </code>定义了项目在交叉轴上如何对齐。</p><ul><li><code>flex-start</code>：与交叉轴的起点对齐；</li><li><code>flex-end</code>：与交叉轴的终点对齐；</li><li><code>center</code>：居中对齐；</li><li><code>baseline</code>：项目第一行文字的基线对齐；</li><li><code>stretch</code>（默认值）：如果项目未设置高度或者为 auto，项目将占满整个容器的高度。</li></ul><h4 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h4><p><code>align-content</code> 定义了多根轴线的对齐方式，若此时主轴在水平方向，交叉轴在垂直方向，align-content 就可以理解为多行在垂直方向的对齐方式。项目排列只有一行时，该属性不起作用。</p><ul><li><code>flex-start</code>：与交叉轴的起点对齐；</li><li><code>flex-end</code>： 与交叉轴的终点对齐；</li><li><code>center</code>：居中对齐；</li><li><code>space-between</code>：与交叉轴两端对齐，轴线之间的距离相等；</li><li><code>space-around</code>：每根轴线两侧的间隔都相等，所以轴线与轴线之间的间隔是轴线与边框之间间隔的两倍；</li><li><code>stretch</code>（默认值）：如果项目未设置高度或者为 <code>auto</code>，项目将占满整个容器的高度。</li></ul><h2 id="项目属性"><a href="#项目属性" class="headerlink" title="项目属性"></a>项目属性</h2><p>对项目设置属性，可以更灵活地控制 Flex 布局。以下六种属性可以设置在项目上：</p><ul><li><code>order</code></li><li><code>flex-grow</code></li><li><code>flex-shrink</code></li><li><code>flex-basis</code></li><li><code>flex</code></li><li><code>align-self</code></li></ul><h4 id="order"><a href="#order" class="headerlink" title="order"></a>order</h4><p><code>order</code> 定义了项目的排列顺序，默认值为 0，数值越小，排列越靠前。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.item</span> &#123;<br>    <span class="hljs-attribute">order</span>: &lt;integer&gt;;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202311181027665.png" alt="img"></p><p>（给第三个项目设置了 order: -1； 后，该项目排到了最前面）</p><h4 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h4><p><code>flex-grow</code> 定义了项目的放大比例，默认为 <code>0</code>，也就是即使存在剩余空间，也不会放大。</p><p>如果所有项目的 <code>flex-grow</code> 都为 <code>1</code>，则所有项目平分剩余空间；</p><p>如果其中某个项目的 <code>flex-grow </code>为 <code>2</code>，其余项目的<code> flex-grow</code> 为 <code>1</code>，则前者占据的剩余空间比其他项目多一倍。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.item</span> &#123;<br>    <span class="hljs-attribute">flex-grow</span>: &lt;number&gt;;&#125;<br></code></pre></td></tr></table></figure><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202311181027684.png" alt="img"></p><p>（所有项目的 flex-grow 都为 1，平分剩余空间）</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202311181027720.png" alt="img"></p><p>（flex-grow 属性值越大，所占剩余空间越大）</p><h4 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h4><p><code>flex-shrink</code> 定义了项目的缩小比例，默认为 1，即当空间不足时，项目会自动缩小。</p><p>如果所有项目的 <code>flex-shrink </code>都为 1，当空间不足时，所有项目都将等比缩小；</p><p>如果其中一个项目的 <code>flex-shrink</code> 为 0，其余都为 1，当空间不足时，<code>flex-shrink </code>为 0 的不缩小。</p><p>负值对该属性无效。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.item</span> &#123;<br>    <span class="hljs-attribute">flex-shrink</span>: &lt;number&gt;；<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202311181027736.png" alt="img"></p><p>（空间不足时，默认等比缩小）</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202311181027651.png" alt="img"></p><p>（flex-shrink 为 0 的不缩小）</p><h4 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h4><p><code>flex-basis </code>定义了在分配多余的空间之前，项目占据的主轴空间，默认值为<code> auto</code>，即项目原来的大小。</p><p>浏览器会根据这个属性来计算主轴是否有多余的空间。</p><p><code>flex-basis</code> 的设置跟 <code>width</code> 或 <code>height </code>一样，可以是像素，也可以是百分比。</p><p>设置了 <code>flex-basis</code> 之后，它的优先级比 <code>width</code> 或 <code>height</code> 高。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.item</span> &#123;<br>    <span class="hljs-attribute">flex-basis</span>: &lt;length&gt; | auto;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202311181027759.png" alt="img"></p><p>（不同的 flex-basis 值效果展示）</p><h4 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h4><p><code>flex</code> 属性是 <code>flex-grow、flex-shrink、flex-basis</code> 的缩写，默认值是 <code>0 1 auto</code>，后两个属性可选。</p><p>该属性有两个快捷值：<code>auto（1 1 auto）</code>和 <code>none（0 0 auto）</code>。</p><p><code>auto</code> 代表在需要的时候可以拉伸也可以收缩，<code>none</code>表示既不能拉伸也不能收缩。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.item</span> &#123;<br>    <span class="hljs-attribute">flex</span>: auto | none | [ &lt;<span class="hljs-string">&#x27;flex-grow&#x27;</span>&gt; &lt;<span class="hljs-string">&#x27;flex-shrink&#x27;</span>&gt;? || &lt;<span class="hljs-string">&#x27;flex-basis&#x27;</span>&gt; ]<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h4><p><code>align-self </code>用来定义单个项目与其他项目不一样的对齐方式，可以覆盖 <code>align-items</code> 属性。</p><p>默认属性值是 <code>auto</code>，即继承父元素的 <code>align-items</code> 属性值。当没有父元素时，它的表现等同于 <code>stretch</code>。</p><p><code>align-self </code>的六个可能属性值，除了 <code>auto </code>之外，其他的表现和 <code>align-items</code> 一样。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.item</span> &#123;<br>    <span class="hljs-attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202311181027302.png" alt="img"></p><p>（第三个项目的对齐方式与其他不同）</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>当我们为父盒子设为<code>flex</code>布局之后，子元素的<code>float</code>，<code>clear</code>和<code>vertical-align</code>属性将失效</li><li><code>align-items</code>是单行，<code>align-content</code>是多行</li></ul><p><code>flex</code>属性是<code>flex-grow</code>，<code>flex-shrink</code>和<code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。</p><ul><li><code>flex-grow</code>是如果有剩余空间，是否扩大，<code>1</code>为扩大</li><li><code>flex-shrink</code>是如果剩余空间不够，是否缩小，<code>1</code>为缩小</li><li><code>flex-basis</code>为项目本身的大小，默认值是<code>auto</code></li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202311181027272.png" alt="img"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">flex-direction</span>: column;<br>  <span class="hljs-attribute">justify-content</span>: space-between;<br>  <span class="hljs-attribute">align-items</span>: flex-end;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202311181027277.png" alt="img"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>&#125;<br><br><span class="hljs-selector-class">.item</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">2</span>) &#123;<br>  <span class="hljs-attribute">align-self</span>: center;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202311181027296.png" alt="img"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">justify-content</span>: space-between;<br>&#125;<br><br><span class="hljs-selector-class">.item</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">2</span>) &#123;<br>  <span class="hljs-attribute">align-self</span>: flex-end;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202311181027278.png" alt="img"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>&#125;<br><br><span class="hljs-selector-class">.item</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">2</span>) &#123;<br>  <span class="hljs-attribute">align-self</span>: center;<br>&#125;<br><br><span class="hljs-selector-class">.item</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">3</span>) &#123;<br>  <span class="hljs-attribute">align-self</span>: flex-end;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202311181027287.png" alt="img"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">flex-wrap</span>: wrap;<br>  <span class="hljs-attribute">justify-content</span>: flex-end;<br>  <span class="hljs-attribute">align-content</span>: space-between;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202311181027769.png" alt="img"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;column&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;column&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">flex-wrap</span>: wrap;<br>  <span class="hljs-attribute">align-content</span>: space-between;<br>&#125;<br><br><span class="hljs-selector-class">.column</span> &#123;<br>  <span class="hljs-attribute">flex-basis</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">justify-content</span>: space-between;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202311181027803.png" alt="img"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">flex-wrap</span>: wrap;<br>  <span class="hljs-attribute">align-content</span>: space-between;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202311181027782.png" alt="img"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">flex-direction</span>: column;<br>  <span class="hljs-attribute">flex-wrap</span>: wrap;<br>  <span class="hljs-attribute">align-content</span>: space-between;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202311181027815.png" alt="img"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;row&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;row&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;row&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">flex-wrap</span>: wrap;<br>&#125;<br><br><span class="hljs-selector-class">.row</span>&#123;<br>  <span class="hljs-attribute">flex-basis</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">display</span>:flex;<br>&#125;<br><br><span class="hljs-selector-class">.row</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">2</span>)&#123;<br>  <span class="hljs-attribute">justify-content</span>: center;<br>&#125;<br><br><span class="hljs-selector-class">.row</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">3</span>)&#123;<br>  <span class="hljs-attribute">justify-content</span>: space-between;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202311181027840.png" alt="img"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">flex-wrap</span>: wrap;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="⭐-flex-各个值的区别"><a href="#⭐-flex-各个值的区别" class="headerlink" title="⭐ flex 各个值的区别"></a>⭐ flex 各个值的区别</h2><p>下面来分别讲讲 <code>flex:1</code>， <code>flex:auto</code>， <code>flex:0</code>， <code>flex:none</code>的区别</p><p>flex 属性是 <code>flex-grow</code>、<code>flex-shrink</code>、<code>flex-basis</code> 的缩写，默认值是 <code>0 1 auto</code>，后两个属性可选。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>` : 对应的是`<span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span>%`， 相当于可扩大，可缩小，`flex-basis`为`<span class="hljs-number">0</span>%<br></code></pre></td></tr></table></figure><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202311181027937.png" alt="img"></p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs d">flex: <span class="hljs-keyword">auto</span><span class="hljs-string">` :  对应的是`</span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-keyword">auto</span><span class="hljs-string">`， 相当于可扩大，可缩小，`</span>flex-basis<span class="hljs-string">`为`</span><span class="hljs-keyword">auto</span><br></code></pre></td></tr></table></figure><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202311181027283.png" alt="img"></p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nsis">flex: <span class="hljs-literal">none</span><span class="hljs-string">` : 对应的是`</span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-literal">auto</span><span class="hljs-string">`， 相当于不可扩大，不可缩小，`</span>flex-basis<span class="hljs-string">`为`</span><span class="hljs-literal">auto</span><br></code></pre></td></tr></table></figure><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202311181027352.png" alt="img"></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">flex</span>: <span class="hljs-number">0</span>` : 对应的是`<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span>%`， 相当于不可扩大，可缩小，`flex-basis`为`<span class="hljs-number">0</span>%<br></code></pre></td></tr></table></figure><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202311181027342.png" alt="img"></p><p><strong>flex : 1 和 flex : auto 的区别</strong></p><p><code>flex: 1</code> 不管内容多少，一般都是平分空间，空间大小都一致</p><p><code>flex: auto</code>是<strong>根据内容的大小来分</strong>，不是均分的（除非内容都是一样，才均分）</p><p><strong>flex: 0 和 flex: none 的区别：</strong></p><p><code>flex: 0</code> 不可扩大，可缩小，表现形式为<strong>最小内容宽度</strong>， 上图你可以看到 div 的宽度就是一个字的宽度</p><p>而<code>flex: none</code> 不可扩大，不可缩小，内容本身的宽度是多少就是多少</p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>布局</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cookie/session/token/jwt分清楚没?</title>
    <link href="/2023/11/17/jwt_token/"/>
    <url>/2023/11/17/jwt_token/</url>
    
    <content type="html"><![CDATA[<h2 id="认证和授权"><a href="#认证和授权" class="headerlink" title="认证和授权"></a>认证和授权</h2><p><strong>认证</strong></p><p>指的是使用用户名和密码来验证当前用户的身份，简单来说就是用户登陆。</p><blockquote><p>互联网中的认证：</p></blockquote><ul><li>用户名密码登录</li><li>邮箱发送登录链接</li><li>手机号接收验证码</li><li>只要你能收到邮箱&#x2F;验证码，就默认你是账号的主人</li></ul><p><strong>授权</strong></p><p>指当用户登陆以后，当前用户是否有足够的权限访问特定的资源。</p><p>实现授权的方式有：<code>cookie</code>、<code>session</code>、<code>token</code>、<code>OAuth</code></p><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p><strong>为什么会出现Cookie?</strong></p><p>HTTP 是无状态的协议（对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息)</p><p>每个请求都是完全独立的，服务端无法确认当前访问者的身份信息，无法分辨上一次的请求发送者和这一次的发送者是不是同一个人。</p><p>所以服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。</p><p>而这个状态需要通过 <code>cookie</code> 或者 <code>session</code> 去实现。</p><p><strong>Cookie的创建</strong></p><p>当接收到客户端发出的 <code>HTTP</code> 请求时，服务器可以发送带有响应的 <code>Set-Cookie</code> 标头，<code>Cookie</code> 通常<strong>由浏览器存储</strong>，然后将 <code>Cookie</code> 与 <code>HTTP</code> 标头一同向服务器发出请求。</p><p>随着对服务器的每个新请求，浏览器将使用 <code>Cookie</code> 头将所有以前存储的 <code>Cookie</code> 发送回服务器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">//服务端</span><br><span class="hljs-title class_">Set</span>-<span class="hljs-title class_">Cookie</span>: ...<br><br><span class="hljs-comment">//客户端</span><br><span class="hljs-title class_">Cookie</span>: ...<br></code></pre></td></tr></table></figure><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p><strong>什么是Session?</strong></p><p>session 是另一种记录服务器和客户端<strong>会话状态</strong>的机制</p><p>session 是基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储到客户端的cookie 中</p><p><strong>Session认证流程</strong></p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202311172338258.png" alt="img"></p><ul><li>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 <code>Session</code></li><li>请求返回时将此 <code>Session</code> 的唯一标识信息 <code>SessionID</code> 返回给浏览器</li><li>浏览器接收到服务器返回的 <code>SessionID</code> 信息后，会将此信息存入到 <code>Cookie</code> 中，同时 <code>Cookie</code> 记录此 <code>SessionID</code> 属于哪个域名。</li><li>当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 <code>Cookie</code> 信息，如果存在自动将 <code>Cookie</code> 信息也发送给服务端，服务端会从 <code>Cookie</code> 中获取 <code>SessionID</code>，再根据 <code>SessionID</code> 查找对应的 <code>Session</code> 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 <code>Session</code> 证明用户已经登录可执行后面操作。</li></ul><blockquote><p>根据以上流程可知，<code>SessionID</code> 是连接 <code>Cookie</code> 和 <code>Session</code> 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。</p></blockquote><h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h2><p><strong>什么是Token?</strong></p><p>访问资源接口 (api)  时所需要的资源凭证</p><blockquote><p>简单 <code>token</code> 的组成：  </p></blockquote><ul><li>uid : 用户唯一的身份标识</li><li>time : 当前时间的时间戳</li><li>sign : 签名，token 的前几位以哈希算法压缩成的一定长度的十六进制字符串</li></ul><p><strong>Token 的身份验证流程</strong></p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202311172338267.png" alt="img"></p><ul><li>客户端使用用户名跟密码请求登录</li><li>服务端收到请求，去验证用户名与密码</li><li>验证成功后，服务端会签发一个 <code>token</code> 并把这个 <code>token</code> 发送给客户端</li><li>客户端收到 token 以后，会把它存储起来，比如放在 cookie 里或者 localStorage 里</li><li>客户端每次向服务端请求资源的时候需要带着服务端签发的 token</li><li>服务端收到请求，然后去验证客户端请求里面带着的 token ，如果验证成功，就向客户端返回请求的数据</li></ul><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p><strong>什么是JWT?</strong></p><p>JSON Web Token（简称 JWT）是目前最流行的跨域认证解决方案。</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202311172338321.png" alt="img"></p><ol><li>用户登陆，用户通过用户名和密码登陆，如果登陆成功，服务器就会返回一个加密文档，这个文档就是<code>jwt</code>，其中包含除了用户密码以外的全部的认证信息，包括用户名、email、角色、权限等等，而客户端在拿到<code>jwt</code>以后就可以把它保存起来了，可以保存<code>cookie</code>中，也可以保存在<code>LocalStorage</code>里面，而生成<code>jwt</code>以后不需要在服务器上保存。</li><li>用户需要访问某些资源，这个时候用户需要把<code>jwt</code>放在<code>http</code>请求的<code>header</code>中，与<code>http</code>请求一同发送给服务器。服务器取得<code>jwt</code>以后，会使用自己的私钥来给给<code>jwt</code>文档解密，如果解密成功而且数据依然有效，则代表用户已经登陆了，如果<code>jwt</code>所描述的用户权限允许该用户访问资源，服务器就会把资源信息通过<code>http</code>响应发送回到客户端。</li></ol><p><strong>什么时候用JWT?</strong></p><p>学校新建了一个图书馆系统, 学校希望这个系统可以无缝衔接学生系统，使用同一套账户，在学生系统中登录以后就能直接进入图书馆系统。</p><ul><li><strong>使用传统的session验证方式</strong>，必须在学生系统和图书馆系统都各自创建一套<code>session</code>才能实现登录，而各自的<code>session</code>无法形成有效的联系，所以在最底层创建一个单点登录系统，不管学生访问哪个系统，都会连接到单点登录系统进行<code>session</code>的验证，当学生的登录信息验证成功以后，单点登录系统会做一个重定向，把流量引导至相应的系统中。这样就可以实现这学生系统和图书馆系统的无缝连接。但是，单点登录系统在使用分布式部署的时候又要考虑不同的服务器之间<code>session</code>的一致性，从而导致系统架构非常复杂。</li></ul><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202311172338304.png" alt="img"></p><ul><li>使用的**<code>jwt</code>**的验证方式，那么想要拓展系统简直就是易如反掌。因为<code>jwt</code>不会保存在服务器上，所以服务器如何部署完全不会影响到<code>jwt</code>的使用。学生登录完成以后，把<code>jwt</code>信息保存在浏览器中，需要访问学习系统或图书馆系统的时候，会向服务器发送带有<code>jwt</code>的请求，学生系统和图书馆系统只需要使用相同的私钥来验证<code>token</code>，验证成功以后，就可以通过<code>token</code>中用户的权限给不同的用户输出不同的数据。</li></ul><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202311172338335.png" alt="img"></p><p><strong>JWT的优势</strong></p><ul><li>无状态登录，简化服务器的用户验证流程，同时完美支持分布式部署。</li><li>使用非对称加密，只要私钥不泄露，可以保证<code>token</code>是绝对安全的。</li></ul><p><strong>JWT的缺陷</strong></p><ul><li><code>jwt token</code>一经发布就无法挽回了，因为具有无状态的特征，所以在带来便利的同时也无法被服务禁用，也就是说，如果用户自身因为某些原因导致<code>token</code>被黑客窃取，那么黑客就可以使用这个<code>token</code>来伪装登录，而服务端对此没有任何办法，只能等待<code>token</code>过期失效。</li><li><code>jwt</code>的前两个部分其实并没有加密，仅仅使用了<code>base64</code>来编码而已，也就是说<code>jwt</code>的用户信息等于是明文传递的，很容易造成用户的信息泄露。</li></ul><blockquote><p>本文转载自<a href="https://juejin.cn/post/7167718864447340558#heading-15">❤️❤️包教包会——Cookie、Session、Token、JWT - 掘金</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>浏览器原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>授权机制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你知道 HTTP 代理/代理缓存吗?</title>
    <link href="/2023/11/13/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98/"/>
    <url>/2023/11/13/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h2 id="如何理解-HTTP-代理"><a href="#如何理解-HTTP-代理" class="headerlink" title="如何理解 HTTP 代理?"></a>如何理解 HTTP 代理?</h2><p>我们知道在 HTTP 是基于请求-响应模型的协议，一般由客户端发请求，服务器来进行响应。</p><p>当然，也有特殊情况，就是代理服务器的情况。引入代理之后，作为代理的服务器相当于一个中间人的角色，对于客户端而言，表现为服务器进行响应；而对于源服务器，表现为客户端发起请求，具有<strong>双重身份</strong>。</p><h4 id="代理服务器的功能"><a href="#代理服务器的功能" class="headerlink" title="代理服务器的功能"></a>代理服务器的功能</h4><ol><li><strong>负载均衡</strong>。客户端的请求只会先到达代理服务器，后面到底有多少源服务器，IP 都是多少，客户端是不知道的。因此，这个代理服务器可以拿到这个请求之后，可以通过特定的算法分发给不同的源服务器，让各台源服务器的负载尽量平均。当然，这样的算法有很多，包括<strong>随机算法</strong>、<strong>轮询</strong>、<strong>一致性hash</strong>、<strong>LRU</strong><code>(最近最少使用)</code>等等。</li><li><strong>保障安全</strong>。利用<strong>心跳</strong>机制监控后台的服务器，一旦发现故障机就将其踢出集群。并且对于上下行的数据进行过滤，对非法 IP 限流，这些都是代理服务器的工作。</li><li><strong>缓存代理</strong>。将内容缓存到代理服务器，使得客户端可以直接从代理服务器获得而不用到源服务器那里。</li></ol><h4 id="相关头部字段"><a href="#相关头部字段" class="headerlink" title="相关头部字段"></a><strong>相关头部字段</strong></h4><ul><li><code>Via</code></li></ul><p>代理服务器需要标明自己的身份，在 HTTP 传输中留下自己的痕迹，怎么办呢？ 通过<code>Via</code>字段来记录。</p><blockquote><p>举个例子</p></blockquote><p>现在中间有两台代理服务器，在客户端发送请求后会经历这样一个过程:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">客户端 -&gt; 代理<span class="hljs-number">1</span> -&gt; 代理<span class="hljs-number">2</span> -&gt; 源服务器<br></code></pre></td></tr></table></figure><p>在源服务器收到请求后，会在请求头拿到这个字段:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title class_">Via</span>: proxy_server1, proxy_server2<br></code></pre></td></tr></table></figure><p>而源服务器响应时，最终在客户端会拿到这样的响应头:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title class_">Via</span>: proxy_server2, proxy_server1<br></code></pre></td></tr></table></figure><blockquote><p>可以看到，Via中代理的顺序即为在 HTTP 传输中报文传达的顺序。</p></blockquote><ul><li><code>X-Forwarded-For</code></li></ul><p>字面意思就是为谁转发, 它记录的是请求方的<code>IP</code>**地址 ** (注意，和<code>Via</code>区分开，<code>X-Forwarded-For</code>记录的是请求方这一个<code>IP</code>)。</p><ul><li><p><code>X-Real-IP</code>  : 是一种获取用户真实 <code>IP</code> 的字段，不管中间经过多少代理，这个字段始终记录<strong>最初的客户端的<code>IP</code>。</strong></p></li><li><p><code>X-Forwarded-Host</code>，记录<strong>客户端 (不包括代理) 的域名</strong>。</p></li><li><p><code>X-Forwarded-Proto</code> : 记录<strong>客户端(不包括代理)的协议名</strong></p></li></ul><h4 id="X-Forwarded-For产生的问题"><a href="#X-Forwarded-For产生的问题" class="headerlink" title="X-Forwarded-For产生的问题"></a><strong>X-Forwarded-For产生的问题</strong></h4><p>前面可以看到，<code>X-Forwarded-For</code>这个字段记录的是请求方的 IP，这意味着每经过一个不同的代理，这个字段的名字都要变，从客户端到代理1，这个字段是客户端的 IP，从代理1到代理2，这个字段就变为了代理1的 IP。</p><blockquote><p>但是这会产生两个问题:</p></blockquote><ul><li><p>意味着代理必须解析 HTTP 请求头，然后修改，比直接转发数据性能下降。</p></li><li><p>在 HTTPS 通信加密的过程中，原始报文是不允许修改的。</p></li></ul><p>由此产生了代理协议，一般使用明文版本，只需要在 <code>HTTP</code> 请求行上面加上这样格式的文本即可:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// PROXY + TCP4/TCP6 + 请求方地址 + 接收方地址 + 请求端口 + 接收端口</span><br><span class="hljs-variable constant_">PROXY</span> <span class="hljs-title class_">TCP4</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.2</span> <span class="hljs-number">1111</span> <span class="hljs-number">2222</span><br><span class="hljs-variable constant_">GET</span> / <span class="hljs-variable constant_">HTTP</span>/<span class="hljs-number">1.1</span><br>...<br></code></pre></td></tr></table></figure><p>这样就可以解决<code>X-Forwarded-For</code>带来的问题了。</p><h2 id="代理缓存是什么"><a href="#代理缓存是什么" class="headerlink" title="代理缓存是什么?"></a>代理缓存是什么?</h2><blockquote><p>我们先来回顾一下强缓存和协商缓存</p></blockquote><p>首先通过 <code>Cache-Control</code> 验证强缓存是否可用</p><ul><li>如果强缓存可用，直接使用</li><li>否则进入协商缓存，即发送 HTTP 请求，服务器通过请求头中的If-Modified-Since或者If-None-Match这些条件请求字段检查资源是否更新<ul><li>若资源更新，返回资源和200状态码</li><li>否则，返回304，告诉浏览器直接从缓存获取资源</li></ul></li></ul><p>我们说说另外一种缓存方式: <strong>代理缓存。</strong></p><h4 id="为什么产生代理缓存？"><a href="#为什么产生代理缓存？" class="headerlink" title="为什么产生代理缓存？"></a><strong>为什么产生代理缓存？</strong></h4><p>对于源服务器来说，它也是有缓存的，比如<code>Redis</code>, <code>Memcache</code>，但对于 <code>HTTP</code> 缓存来说，如果每次客户端缓存失效都要到源服务器获取，那给源服务器的压力是很大的。</p><p>由此引入了缓存代理的机制。让代理服务器接管一部分的服务端<code>HTTP</code>缓存，<strong>客户端缓存过期后就近到代理缓存中获取，代理缓存过期了才请求源服务器，这样流量巨大的时候能明显降低源服务器的压力。</strong></p><blockquote><p>那缓存代理究竟是如何做到的呢？</p></blockquote><p>总的来说，缓存代理的控制分为两部分，一部分是<strong>源服务器端的控制</strong>，一部分是<strong>客户端的控制</strong>。</p><h4 id="源服务器的缓存控制"><a href="#源服务器的缓存控制" class="headerlink" title="源服务器的缓存控制"></a><strong>源服务器的缓存控制</strong></h4><ul><li><code>private</code> 和 <code>public</code></li></ul><p>在源服务器的响应头中，会加上<code>Cache-Control</code>这个字段进行缓存控制字段，那么它的值当中可以加入<code>private</code>或者<code>public</code>表示是否允许代理服务器缓存，前者禁止，后者为允许。</p><p>比如对于一些非常私密的数据，如果缓存到代理服务器，别人直接访问代理就可以拿到这些数据，是非常危险的，因此对于这些数据一般是不会允许代理服务器进行缓存的，将响应头部的<code>Cache-Control</code>设为<code>private</code>，而不是<code>public</code>。</p><ul><li><code>proxy-revalidate</code></li></ul><p><code>must-revalidate</code>的意思是客户端缓存过期就去源服务器获取</p><p><code>proxy-revalidate</code>则表示<strong>代理服务器的缓存过期后到源服务器获取</strong>。</p><ul><li><code>s-maxage</code></li></ul><p>限定了<strong>缓存在代理服务器中可以存放多久</strong>，和限制客户端缓存时间的<code>max-age</code>并不冲突。</p><blockquote><p>举例 : 源服务器在响应头中加入这样一个字段:</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title class_">Cache</span>-<span class="hljs-title class_">Control</span>: public, max-age=<span class="hljs-number">1000</span>, s-maxage=<span class="hljs-number">2000</span><br></code></pre></td></tr></table></figure><p>相当于源服务器说: 我这个响应是允许代理服务器缓存的，客户端缓存过期了到代理中拿，并且在客户端的缓存时间为 1000 秒，在代理服务器中的缓存时间为 2000 s。</p><h4 id="客户端的缓存控制"><a href="#客户端的缓存控制" class="headerlink" title="客户端的缓存控制"></a><strong>客户端的缓存控制</strong></h4><ul><li><code>max-stale</code> 和 <code>min-fresh</code> :在客户端的请求头中，可以加入这两个字段，来对代理服务器上的缓存进行宽容和限制操作。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">max-<span class="hljs-attr">stale</span>: <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>表示客户端到代理服务器上拿缓存的时候，即使代理缓存过期了也不要紧，<strong>只要过期时间在5秒之内，还是可以从代理中获取的。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">min-<span class="hljs-attr">fresh</span>: <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>表示代理缓存需要一定的<strong>新鲜度</strong>，不要等到缓存刚好到期再拿，一定要在<strong>到期前 5 秒之前的时间拿，否则拿不到。</strong></p><ul><li><code>only-if-cached</code></li></ul><p>这个字段加上后表示客户端<strong>只会接受代理缓存，而不会接受源服务器的响应。</strong>如果代理缓存无效，则直接返回<code>504</code>（Gateway Timeout）。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端人都应该知道的性能优化📕</title>
    <link href="/2023/11/09/%E6%80%A7%E8%83%BD%E6%A3%80%E6%B5%8B%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
    <url>/2023/11/09/%E6%80%A7%E8%83%BD%E6%A3%80%E6%B5%8B%E4%B8%8E%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.yuque.com/cuggz/feplus/mdg9w2#LL94M">前端性能优化 | 什么是性能优化 · 语雀</a></p><h1 id="性能优化概述"><a href="#性能优化概述" class="headerlink" title="性能优化概述"></a>性能优化概述</h1><h3 id="性能优化的影响"><a href="#性能优化的影响" class="headerlink" title="性能优化的影响"></a>性能优化的影响</h3><ul><li><p><strong>用户的留存</strong> : 加载越快, 用户留存率越高</p></li><li><p><strong>网站的转化率</strong> : 目标行为访问次数 &#x2F; 总访问次数, 比如购物</p></li><li><p><strong>体验与传播</strong> : 好评&#x2F;差评</p></li></ul><h3 id="性能优化的评估模型"><a href="#性能优化的评估模型" class="headerlink" title="性能优化的评估模型"></a>性能优化的评估模型</h3><ol><li><p><strong>响应</strong> : 网站对于响应方面的要求是：在用户感知延迟之前接收到操作的反馈 , 比如必须在 100ms 之内收到反馈</p></li><li><p><strong>动画</strong> : 要求流畅,  最好控制在 10ms 以内</p></li><li><p><strong>空闲</strong> : 利用空闲时间来处理可延迟的任务, 减少预加载的数据大小, 使用户感知不延迟</p></li><li><p>加<strong>载</strong> : 先渲染关键渲染路径, 空闲时间再渲染非关键资源。</p></li></ol><h3 id="性能优化的指标"><a href="#性能优化的指标" class="headerlink" title="性能优化的指标"></a>性能优化的指标</h3><p><strong>感官指标</strong></p><ul><li><p><strong>首次绘制时间 (FP)</strong> : 页面首次绘制的时间点</p></li><li><p><strong>首次有内容绘制时间 (FCP)</strong> : 浏览器完成渲染DOM第一个内容的时间点</p></li><li><p><strong>首次有意义绘制时间 (FMP)</strong> : 页面关键元素渲染时间</p></li><li><p><strong>首屏时间 :</strong>  进入页面之后, 应用渲染完整个屏幕(未滚动之前) 内容的时间.</p></li></ul><p><strong>Performance API</strong></p><blockquote><p>这个 <code>API </code>是 <code>HTML5 </code>新增的特性 , 不明白的可以看看 MDN</p><p>可以在控制台的<code>console</code>面板中通过<code>window.performance</code>来获取网站的各项指标信息</p></blockquote><p>Performance 接口可以获取到当前页面中与性能相关的信息。它是 High Resolution Time API 的一部分，同时也融合了 Performance Timeline API、Navigation Timing API、 User Timing API 和 Resource Timing API。该类型的对象可以通过调用只读属性 Window.performance 来获得。</p><ul><li><code>performance</code>包括了五个属性，其中<code>timing</code>是需要重点关注的，<code>timing</code>是一个<code>map</code>数据结构，其中<code>key</code>值是性能优化指标，<code>value</code>值是对应的时间戳。</li><li>很多指标都是成对出现，直接作差就可以求出对应页面加载过程中关键节点的时间，介绍几个比较常用的</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> timingInfo = <span class="hljs-variable language_">window</span>.<span class="hljs-property">performance</span>.<span class="hljs-property">timing</span>; <br><br><span class="hljs-comment">// TCP连接耗时</span><br>timingInfo.<span class="hljs-property">connectEnd</span> - timingInfo.<span class="hljs-property">connectStart</span><br><br><span class="hljs-comment">// DNS查询耗时</span><br>timingInfo.<span class="hljs-property">domainLookupEnd</span> - timingInfo.<span class="hljs-property">domainLookupStart</span>;<br><br><span class="hljs-comment">// 获得首字节耗费时间，也叫TTFB</span><br>timingInfo.<span class="hljs-property">responseStart</span> - timingInfo.<span class="hljs-property">navigationStart</span><br><br><span class="hljs-comment">// domReady时间(与前面提到的DomContentLoad事件对应)</span><br>timingInfo.<span class="hljs-property">domContentLoadedEventStart</span> - timingInfo.<span class="hljs-property">navigationStart</span><br><br><span class="hljs-comment">// DOM资源下载</span><br>timingInfo.<span class="hljs-property">responseEnd</span> - timingInfo.<span class="hljs-property">responseStart</span><br></code></pre></td></tr></table></figure><blockquote><p>上述就是比较常用的指标，这些指标也可以在Chrome浏览器的network面板中的Timing下获取：</p></blockquote><h3 id="性能优化的步骤"><a href="#性能优化的步骤" class="headerlink" title="性能优化的步骤"></a>性能优化的步骤</h3><ul><li><strong>传输资源的优化</strong>：比如图像资源，不同的格式类型会有不同的使用场景，在使用过程中判断是否恰当；</li><li><strong>加载过程的优化</strong>：比如加载延迟，是否有不需要在首屏展示的非关键信息，占用了页面的加载时间；</li><li><strong>JavaScript的优化</strong>：JavaScript代码是否进行了压缩，书写是否规范，有无考虑内存泄漏等；</li><li><strong>关键渲染路径优化：</strong>比如是否存在不必要的回流与重绘等；</li><li><strong>本地存储和浏览器缓存。</strong></li></ul><h1 id="前端页面的性能检测"><a href="#前端页面的性能检测" class="headerlink" title="前端页面的性能检测"></a>前端页面的性能检测</h1><h3 id="常见的性能检测工具"><a href="#常见的性能检测工具" class="headerlink" title="常见的性能检测工具"></a>常见的性能检测工具</h3><ol><li><strong>Chrome 任务管理器 :</strong> 查看当前所有进程关于GPU、网络、和内存的使用情况,  这些进程包括当前打开的标签页、安装的各种插件以及GPU、网络、渲染等浏览器的默认进程。通过监控这些数据, 可以定位存在内存泄漏或者网络资源加载异常的问题进程。</li></ol><blockquote><p>很熟悉了</p></blockquote><ol start="2"><li><strong>Network 面板</strong> : 可以查看网站资源的请求情况，包括加载时间、尺寸大小、优先级设置、HTTP缓存触发情况等信息，从而发现网站资源请求中存在的问题。</li></ol><blockquote><p>很熟悉了</p></blockquote><ol start="3"><li><p><strong>Coverage 面板</strong> : 监控并统计出网站应用运行过程中代码执行的覆盖率情况。该面板统计的对象是JavaScript脚本文件与CSS样式表文件。代码覆盖率低就意味着该代码文件存在着较多没有用到的代码，开发者可以根据这个结果对代码进行拆分，在需要的时候在进行加载。</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202311091430789.png" alt="img"></p></li></ol><blockquote><p>点击’更多工具’打开</p></blockquote><ol start="4"><li><strong>PageSpeed</strong> : <a href="https://pagespeed.web.dev/">https://pagespeed.web.dev/</a> 可以直接输入页面的URL来分析页面的性能</li></ol><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202311091310804.png" alt="img"></p><ol start="5"><li><strong>WEBPAGETEST</strong> : 可以对检测分析的环境配置进行自定义化，内容包括测试节点的物理位置、设备型号、浏览器版本、网络条件和检测次数等。<a href="https://www.webpagetest.org/">https://www.webpagetest.org/</a></li></ol><h3 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h3><p><code>Performance</code>(性能)面板主要是对网站应用的运行时性能表现进行检测与分析，其可以检测的内容包括：页面的每秒帧数（FPS）、CPU的使用情况、各种请求的时间花费、网络任务的执行情况。建议在<strong>无痕模式</strong>下使用该工具，因为该模式下网页不会受到缓存或其他插件程序等因素的影响</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202311091310746.png" alt="img"></p><p><strong>控制面板</strong></p><ul><li><p>屏幕截图：表示是否截取每一帧的屏幕截图，默认会勾选</p></li><li><p>内存：表示是否记录内存消耗，默认不会候选</p></li><li><p>Web Vitals：测试网页的加载速度及用户体验等</p></li><li><p>Disable javaScript samples：关闭JavaScript样本，减少在手机端运行时的开销</p></li><li><p>Enable advanced paint instrucmentation（slow）：表示是否开启加速渲染工具，用来记录渲染事件的相关细节，该功能比较消耗性能</p></li><li><p>Network：切换模拟网络环境，可以模拟弱网(2g&#x2F;3g)条件下网站的一些表现情况，然后根据弱网的具体表现进行相关优化</p></li><li><p>CPU：限制CPU的处理速度，主要用于模拟低速CPU运行时的性能。</p></li></ul><p><strong>概览面板</strong></p><p>在概览面板中，可以选择一个起始时间点，然后拖动鼠标左键来滑动选择面板中国的局部范围，来进行更小范围的性能观察。这部分的性能信息主要包括以下三个指标：</p><ul><li><p>FPS：衡量动画是否流畅的重要指标。</p></li><li><p>CPU：展示CPU的使用情况。</p></li><li><p>NET：展示各个请求所花费的具体时间</p></li></ul><p><strong>线程面板</strong></p><p>主线程在解析HTML和CSS、页面绘制及执行JavaScript的过程中，每个事件调用栈和耗时情况都会反应在这个图中。</p><p>每一个长条都代表一个事件，将鼠标悬浮至其上面时，就可以查看到相应的时间的执行耗时与事件名。</p><p>图中不同颜色表示不同的事件类型。横轴代表时间，纵轴代表具体的调用堆栈。调用堆栈就像是浏览器当中的解释器，可以利用它追踪函数的执行流。</p><blockquote><p>常见的事件类型有：</p></blockquote><ul><li>HTML解析；</li><li>JavaScript事件；</li><li>页面布局更改；</li><li>元素样式重新计算；</li><li>页面涂层的绘制。</li></ul><p><strong>统计面板</strong></p><p>统计面板会根据在概念面板中选择时间区域的不同，绘制出不同类型任务执行耗时的可视化图标</p><p>点击之后看到这个事件下对应的一些具体信息，这里还可以点击Range右侧链接，点击之后会直接跳到sources面板对应的代码位置，这个功能方便了定位代码</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202311091310556.png" alt="img"></p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202311091430160.png" alt="img"></p><p>统计面板中包含四个Tab，其含义如下：</p><ul><li>Summary：展示各类任务事件耗时环形图；</li><li>Bottom-Up：查看各个事件耗时的排序列表，列表包含两个维度：去除子事件后该事件本身的耗时和包含子事件从开始到结束的总耗时；</li><li>Call Tree：查看全部或指定火焰图中某个事件的调用栈；</li><li>Event Log：查看关于每个事件详细的日志。</li></ul><h3 id="LightHouse"><a href="#LightHouse" class="headerlink" title="LightHouse"></a>LightHouse</h3><p>为 Lighthouse 提供一个需要审查的网址，它将针对此页面运行一连串的测试，然后生成一个有关页面性能的报告，其内容包括：性能检测、可访问性检测、SEO检测、是否符合PWA的检测、其他是否符合最佳实践的检测。 检测报告不仅涉及上面这些方面的现状分析，同时还提供了一些优化指导建议，方便开发者快速发现潜在的性能瓶颈并实施优化改进。</p><p>在新版的Chrome浏览器中，将LightHouse集成在了开发者工具中，打开控制台，切换到LightHouse面板</p><p>可以看到报告详细给出了各种情况下的分数情况，从左到右分别是Performance(页面性能)、Accessibility(可访性)、Best Practise(最佳实践)、SEO(搜索引擎优化)、Progressive Web App(渐进式应用)。点击其中的每一项都可以看到给出的具体优化建议。</p><p><strong>检测得分</strong></p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202311091310791.png" alt="img"></p><p><strong>页面性能</strong></p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202311091310807.png" alt="img"></p><p><strong>优化建议</strong></p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202311091310335.png" alt="img"></p><p>根据每部分给出的评测结果以及优化建议，开发者就可以针对性的对网站页面进行优化。</p><h1 id="雅虎35条军规"><a href="#雅虎35条军规" class="headerlink" title="雅虎35条军规"></a>雅虎35条军规</h1><blockquote><p>可能没有35条, 因为有些已经不需要了</p></blockquote><h3 id="1-图片优化"><a href="#1-图片优化" class="headerlink" title="1. 图片优化"></a>1. 图片优化</h3><p><strong>优化图片</strong></p><ul><li><p>检查 GIF 图片的调色板大小是否匹配图片颜色数；</p></li><li><p>把 GIF 格式转换成 PNG 格式，看看是否节省空间；</p></li><li><p>运行 pngcrush 或其它工具来压缩 png 格式的图片；</p></li><li><p>运行 jpegtran 或其它工具来压缩 jpeg 格式的图片。</p></li></ul><p><strong>优化CSS Sprite</strong></p><ul><li><p>把图片横向合并而不是纵向，因为横向图片文件更小；</p></li><li><p>把颜色近似的图片合并到一张雪碧图，这样可以让颜色数更少，如果低于 256 色就可以用 png8 格式；</p></li><li><p>对移动端友好，合并时图片间的间距不要太大。虽然这对图片大小影响不是太大，但这样做可以节省用户代理把图片解压成像素映射时消耗的内存。100×100的图片是1万个像素，而1000×1000的图片就是100万个像素了。</p></li></ul><p><strong>禁止在HTML中缩放图片</strong></p><p>不要在 HTML 中缩放图片。不要因为可以设置图片的宽高就去用比需要的大得多的图片。</p><p>如果需要100px * 100px的图片，那就不要用500px  * 500px的。</p><p><strong>用小的且可以缓存的favicon</strong></p><ul><li><p><code>favicon.ico</code>是放在服务器根目录的图片，浏览器也会自动请求它，所以最好不要给一个<code>404 Not Found</code>响应。而且只要在同一个服务器上，每次请求它时都会发送<code>cookie</code>，此外这个图片还会干扰下载顺序，例如在<code>IE</code>中，当你在<code>onload</code>中请求额外组件时，将会先下载<code>favicon</code>。</p></li><li><p>所以为了缓解<code>favicon.ico</code>的缺点，应该确保：</p><ul><li><p>足够小，最好在<code>1K</code>以下；</p></li><li><p><code>favicon.ico</code> 一般是不进行更换的，所以可以给它设置<code>Expires</code>头，而且可以安全地设置为几个月，避免每一次打开页面都需要去进行请求。</p></li></ul></li></ul><h3 id="2-CSS-优化"><a href="#2-CSS-优化" class="headerlink" title="2. CSS 优化"></a>2. CSS 优化</h3><p><strong>将CSS样式放在顶部</strong></p><ul><li><p>将样式表移到 <code>&lt;head&gt;</code> 里会让页面加载地更快。这是因为把样式表移到 <code>&lt;head&gt;</code> 里允许页面逐步渲染。</p></li><li><p>我们希望浏览器尽早的去渲染获取到的内容，这对大页面和网速慢的用户很重要。给用户视觉反馈（比如进度指标）就非常重要，HTML 页面就是进度指标。当浏览器逐步加载页面头部，导航条，顶部 logo 等内容时，这些都是给等待页面的用户的视觉反馈，能够提高整体用户体验。</p></li><li><p>把样式表放在文档底部的问题是它阻止了许多浏览器的逐步渲染，包括 IE。这些浏览器阻止渲染来避免在样式更改时需要重绘页面元素。所以用户会卡在白屏。</p></li></ul><p><strong>避免使用CSS表达式</strong></p><p>CSS 表达式是强大的（可能也是危险的）设置动态 CSS 属性的方法。CSS 表达式的问题是它们可能比预期计算的更频繁。它们不仅在页面载入和调整大小时重新计算，也在滚动页面甚至是用户在页面上移动鼠标时计算。比如在页面上移动鼠标可能轻易计算超过10000次。要避免CSS表达式计算太多次，可以在它第一次计算后替换成确切值，或者用事件处理函数而不是CSS表达式。</p><p><strong>选择<code>&lt;link&gt;</code> 舍弃<code>@import</code></strong></p><p>上面提到了一个最佳实践：为了实现逐步渲染，<code>CSS</code>应该放在顶部。在IE中用<code>@import</code>与在底部用<code>&lt;link&gt;</code>效果一样，所以最好不要用它。</p><h3 id="3-Cookie-优化"><a href="#3-Cookie-优化" class="headerlink" title="3.Cookie 优化"></a>3.Cookie 优化</h3><p><strong>减少Cookie的体积</strong></p><p>HTTP Cookie 的使用有多种原因，比如授权和个性化。Cookie 的信息通过 http 头部在浏览器和服务器之间交换。</p><p>重要的是保证cookie尽可能的小，以最小化对用户响应时间的影响。可以对Cookie做如下优化：</p><ul><li>消除不必要的 <code>Cookie</code> , 来降低响应时间；</li><li>注意设置 <code>Cookie </code>到合适的域名级别，以免影响其它子域；</li><li>设置合适的 <code>Expires </code>日期。更早的有效期或者<code>none</code>可以更快的删除<code>cookie</code>，提高用户响应时间。</li></ul><p><strong>把组件放在不含<code>Cookie</code>的域下</strong></p><p>当浏览器请求静态图片并把 cookie 一起发送到服务器时，cookie 此时对服务器没什么用处。所以这些 cookie 只会增加无意义的网络流量。所以应该保证静态组件的请求是没有 cookie 的。可以创建一个子域名来托管所有静态组件。</p><p>比如，域名是<a href="http://www.example.org,可以把静态组件托管在static.example.org.不过,如果把cookie设置在顶级域名/">www.example.org，可以把静态组件托管在static.example.org。不过，如果把cookie设置在顶级域名</a> example.org 下，这些cookie仍然会被传给 static.example.org。这种情况下，可以启用一个全新的域名来托管静态组件。</p><p>注意：因为cookie是可以跨二级域名的，所以如果设置的顶级域名是example.org，那么static.example.org 也是可以被访问到的，因此需要启用一个全新的域名。</p><p>另外一个用没有 cookie 的域名提供组件的好处是，某些代理可能会阻止缓存带 cookie 的静态组件请求。</p><h3 id="4-服务端优化"><a href="#4-服务端优化" class="headerlink" title="4. 服务端优化"></a>4. 服务端优化</h3><p><strong>使用CDN（内容分发网络）</strong></p><ul><li>用户接近服务器就会减少响应时间。把内容发布到多个地理上分散的服务器可以让页面加载更快。</li><li>80-90%的终端用户响应时间花费在下载页面中的所有组件：图片、样式、脚本、falsh 等，这就是业绩黄金法则。</li><li>最好先分散静态内容，而不是一开始就重新设计应用程序结构。这不仅能够大大减少响应时间，还更容易表现出CDN的功劳。</li><li>内容分发网络（CDN）是一组分散在不同地理位置的web服务器，用来给用户更高效地发送内容。典型地，选择用来发送内容的服务器是基于网络距离的衡量标准的。</li></ul><p><strong>添加<code>Expires</code>或者<code>Cache-Control</code>头部</strong></p><p>这条规则有两个方面：</p><ul><li>对静态组件：通过设置 <code>Expires</code>头部来实现永不过期策略。</li><li>对动态组件：用合适的 <code>Cache-Control</code> 头部来帮助浏览器进行有条件性的请求。</li></ul><p>网站设计越来越丰富，这意味着更多脚本，样式，图片等。第一次访问的用户可能需要发出多个请求，但使用Expires可以让这些组件被缓存。这避免了访问子页面时没必要的 http 请求。Expires 一般用在图片上，但它应该用在所有的组件上，包括脚本、样式等。</p><p>浏览器使用缓存来减少HTTP请求数和大小，加快页面加载。服务器使用HTTP响应的Expires头部来告诉客户端一个组件可以缓存多久。注意，如果设置了Expires头部，当组件更新后，必须更改文件名。</p><p><strong>传输时用gzip等压缩组件</strong></p><p><code>HTTP </code>请求或响应的传输时间可以被显著减少。压缩可以通过减少 <code>http </code>响应的大小来缩短响应时间。从<code> HTTP/1.1</code> 开始，客户端通过<code>http</code>请求中的 <code>Accept-Encoding</code> 头部来提示支持的压缩：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTTP"><span class="hljs-attribute">Accept-Encoding</span><span class="hljs-punctuation">: </span>gzip, deflate<br></code></pre></td></tr></table></figure><p>如果服务器看到这个头部，它就会选用列表中的某个方法压缩响应。服务器通过<code>Content-Encoding</code> 头部来提示客户端：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTTP"><span class="hljs-attribute">Content-Encoding</span><span class="hljs-punctuation">: </span>gzip<br></code></pre></td></tr></table></figure><p><code>gzip </code>一般可减小响应的 <code>70%</code>。尽可能去<code>gzip</code>更多（文本）类型的文件，这也是提升用户体验最简单的方法。</p><p>html，脚本，样式，xml 和 json 等都应该被gzip，<strong>而图片，pdf等不应该被gzip</strong>，因为它们本身已被压缩过，gzip 它们只是浪费 cpu，甚至增加文件大小。</p><p> <strong>配置 <code>ETags</code></strong></p><blockquote><p>协商缓存</p></blockquote><p>实体标记（Entity tags，简称ETag）是服务器和浏览器之间判断浏览器缓存中某个组件是否匹配服务器端原组件的一种机制。实体就是组件：图片，脚本，样式等。ETag被当作验证实体的比最后更改（last-modified）日期更高效的机制。一个ETag是一个字符串，作为一个组件某一具体版本的唯一标识符。唯一的格式约束是字符串必须用引号括起来。服务器这样设置组件的ETag：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs HTTP"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Last-Modified</span><span class="hljs-punctuation">: </span>Tue, 12 Dec 2006 03:03:59 GMT<br><span class="hljs-attribute">ETag</span><span class="hljs-punctuation">: </span>&quot;10c24bc-4ab-457e1c1f&quot;<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>12195<br></code></pre></td></tr></table></figure><p>然后，如果浏览器要验证组件，它用 <code>If-None-Match</code> 头部来把 ETag 传回服务器。如果 ETag 匹配成功，服务器返回状态码304：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs HTTP"><span class="hljs-keyword">GET</span> <span class="hljs-string">/i/yahoo.gif</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>us.yimg.com<br><span class="hljs-attribute">If-Modified-Since</span><span class="hljs-punctuation">: </span>Tue, 12 Dec 2006 03:03:59 GMT<br><span class="hljs-attribute">If-None-Match</span><span class="hljs-punctuation">: </span>&quot;10c24bc-4ab-457e1c1f&quot;<br>HTTP/1.1 304 Not Modified<br></code></pre></td></tr></table></figure><p>ETag 的问题是它们被构造来使它们对特定的运行这个网站的唯一服务器。</p><p>浏览器从一个服务器获取组件，之后向另一个服务器验证，ETag 将不匹配。</p><p>然而服务器集群是处理请求的通用解决方案。如果不能解决多服务器间的 ETag 匹配问题，那么删除 ETag 可能更好。</p><p><strong>尽早清空缓冲区</strong></p><p>当用户请求一个页面，服务器一般要花 <code>200-500ms</code> 来渲染整个页面。这段时间，浏览器是空闲的（等待数据返回）。在 <code>php</code>中，有个方法 <code>flush()</code> 允许传输部分准备好的 <code>html</code> 响应给浏览器。这样的话浏览器就可以开始下载组件，而同时后台可以继续生成页面剩下的部分。这种好处更多是在忙碌的后台或轻前端网站可以看到。</p><p>较理想的清空缓冲区的位置是<code>HEAD</code>后面，因为<code>HTML</code>的<code>HEAD</code>部分通常更容易生成，并且允许引入任何<code>CSS</code>和<code>JavaScript</code>文件，这样就可以让浏览器在后台还在处理的时候就开始并行获取组件。</p><p> <strong>对Ajax用GET请求</strong></p><p>当使用 <code>XMLHttpRequest </code>时，<code>POST</code>请求被浏览器实现为两步：首先发送头部，然后发送数据。所以最好使用 <code>GET</code>，仅用一个 <code>TCP </code>包发送（除非<code>cookie</code>太多）。如果POST不提交任何数据，那它跟 GET 行为类似。但从语义上讲，获取数据应该用 <code>GET</code>，提交数据到服务器用 <code>POST</code>。</p><p><strong>避免图片<code>src</code>属性为空</strong></p><p>空<code>src</code>属性的图片的行为有两种形式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">&lt;img src=<span class="hljs-string">&quot;&quot;</span>&gt;  <span class="hljs-comment">// html标签：</span><br><span class="hljs-keyword">var</span> img = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>(); img.<span class="hljs-property">src</span> = <span class="hljs-string">&quot;&quot;</span> <span class="hljs-comment">// js</span><br></code></pre></td></tr></table></figure><ul><li>上面的两种形式都会造成同一种后果：浏览器会向服务器发送另一个请求。</li><li>发送大量的意料之外的流量，会削弱服务器，甚至可能会破坏用户数据。如果你在跟踪请求状态，通过 cookie 或其它，可能会破坏数据。即使 image 的请求不会返回图片，但所有的头部数据都被浏览器读取了，包括 cookie。即使剩下的响应体被丢弃，破坏可能已经发生。 这种行为的根源是 <code>uri </code>解析发生在浏览器。</li><li>RFC 3986 定义了这种行为，空字符串被当作相对路径，Firefox, Safari, 和 Chrome都正确解析。总之，浏览器解析空字符串为相对路径的行为被认为是符合预期的。</li><li>html5在4.8.2添加了对标签src属性的描述，指导浏览器不要发出额外的请求。幸运的是将来浏览器不会有这个问题了（仅在图片上）。不幸的是，<code>&lt;script src=&quot;&quot;&gt;</code>和<code>&lt;link href=&quot;&quot;&gt;</code>没有这样的规范。</li></ul><h3 id="5-JavaScript-优化"><a href="#5-JavaScript-优化" class="headerlink" title="5. JavaScript 优化"></a>5. <code>JavaScript </code>优化</h3><p><strong>把脚本放到底部</strong></p><ul><li>脚本会阻塞并行下载。HTTP&#x2F;1.1 规范建议浏览器每个域名下不要并行下载超过2个组件。如果图片分散在不同服务器，那么就能并行下载多个图片。如果脚本正在下载，浏览器就不开始任何其它下载任务，即使是在不同主机名下的。</li><li>有些情况下，把脚本移动到底部并不简单。比如，脚本中用了 <code>document.write</code> 来插入内容，它就不能被移动到底部。另外有可能有作用域问题。但大多数情况，这些问题都有办法解决。</li><li>一个替代建议是使用异步脚本。<code>defer/async</code>属性表明脚本不包含 <code>document.write</code>，并且提示浏览器可以继续渲染。如果脚本能异步加载，那么也就可以把它移动到底部，这样可以大大加快网页运行速度。</li><li>这里要注意<code>JavaScript</code>是会阻塞浏览器运行的，所以脚本文件尽量放到页面的最下面。</li></ul><p><strong>使用外部JavaScript和CSS</strong></p><ul><li>实际上，使用外部文件一般可以让页面加载更快，因为 JS 和 CSS 文件会被浏览器缓存。内而联的 JavaScript 和CSS 在每次 HTML 文档下载时都被下载。虽然内联减少了<code>http</code>请求，但增加了<code>HTML</code>文档大小。另一方面，如果 <code>JavaScript </code>和 <code>CSS </code>被缓存了，那么 HTML 文档可以减小大小而不增加 HTTP 请求。</li><li>核心因素就是 <code>JavaScript </code>和 <code>CSS </code>被缓存相对于 HTML 文档被请求的频率。如果网站用户每个会话打开了多个页面，许多页面重复使用相同的 JavaScript 和CSS，那么有很大可能用外部 JS 和 CSS 更好。</li><li>许多网站用这些指标计算后在中间位置。对这些网站来说，最佳方案还是用外部 JS 和 CSS 文件。唯一例外是内联更被主页偏爱。主页每个会话可能只会打开少量甚至一个页面，这时候内联可能更快。</li></ul><blockquote><p>根据实际业务需求进行选择</p></blockquote><p><strong>压缩JS和CSS</strong></p><ul><li>压缩就是删除代码中不必要的字符来减小文件大小，从而提高加载速度。当代码压缩时，注释删除，不需要的空格（空白，换行，tab）也被删除。在<code>JavaScript</code>中这样做能够提高响应性能，因为要下载的文件变小了。两个最常用的<code>JavaScript</code>代码压缩工具是<code>JSMin</code>和<code>YUI Compressor</code>，<code>YUI compressor</code>还可以压缩<code>CSS</code>。</li><li>混淆是对代码可选的优化。它比压缩更复杂，并且可能产生 <code>bug</code>。在对美国 Top10 网站的调查中，压缩可减小 <code>21%</code>，而混淆可以减小 <code>25%</code>。除了外部脚本和样式，内联的脚本和样式同样应该被压缩。</li><li>除了压缩外部脚本和样式，行内的<code>&lt;script&gt;</code>和<code>&lt;style&gt;</code>块也可以压缩。即使启用了<code>gzip</code>模块，先进行压缩也能够缩小<code>5%</code>或者更多的大小。<code>JavaScript</code>和<code>CSS</code>的用处越来越多，所以压缩代码会有不错的效果。</li></ul><p><strong>删除重复的脚本</strong></p><ul><li>在页面中两次引入相同的脚本会降低性能。当确实引入重复脚本，会发出不必要的<code>http</code>请求和浪费<code>js</code>执行时间。</li><li>除了产生没有意义的<code>HTTP</code>请求之外，多次对脚本求值也会浪费时间, 都会执行冗余的JavaScript代码。</li><li>避免不小心把相同脚本引入两次的一种方法就是在模版系统中实现脚本管理模块。</li></ul><p><strong>尽量减少DOM访问</strong></p><p>用 JavaScript 访问 DOM 元素是很慢的，所以为了让页面反应更迅速，应该：</p><ul><li>缓存访问过的元素的引用；</li><li>在 DOM 树外更新节点，然后添加到 DOM 树；</li><li>避免用JavaScript修复布局问题；</li></ul><p>注意，能用<code>CSS</code>解决的事情，就尽量不用<code>JS</code>操作<code>DOM</code>，DOM操作开销很大。</p><p><strong>用智能的事件处理器</strong></p><p>有时候页面看起来响应速度比较慢，是因为绑定到不同元素的大量事件处理函数执行太多次。一种更好的解决方法就是使用事件委托。另外，不必等到 <code>onload </code>事件来开始处理 <code>DOM </code>树，使用<code>DOMContentLoaded </code>会更快。大多时候需要的只是想访问的元素已在 <code>DOM </code>树中，所以不必等到所有图片下载完。</p><blockquote><p>注意：</p></blockquote><ul><li><code>onLoad</code>是的在页面所有文件加载完成后执行；</li><li><code>DomContentLoad</code>是<code>Dom</code>加载完成后执行，<strong>不必等待样式脚本和图片加载。</strong></li></ul><h3 id="6-移动端优化"><a href="#6-移动端优化" class="headerlink" title="6. 移动端优化"></a>6. 移动端优化</h3><p><strong>保持组件小于25K</strong></p><p>这个限制是因为<code>iPhone</code>不能缓存大于<code>25K</code>的组件，注意这里指的是未压缩的大小。这就是为什么缩减内容本身也很重要，因为单纯的<code>gzip</code>可能不够。</p><p> <strong>组件打包到一个复合文档中</strong></p><p>将组件打包到复合文档就像带有附件的电子邮件，它可以帮助我们通过一个 <code>HTTP </code>请求获取多个组件（请记住：<code>HTTP </code>请求很昂贵）。使用此技术时，首先检查用户代理是否支持它( <code>iPhone </code>就不支持)。</p><h3 id="7-内容优化"><a href="#7-内容优化" class="headerlink" title="7. 内容优化"></a>7. 内容优化</h3><p><strong>减少HTTP请求数</strong></p><p><code>80%</code>的终端用户响应时间都花在了前端上，大部分用于下载组件 <code>js/css/image/flash</code> 等。减少组件数必然能够减少渲染页面所需的 <code>http </code>请求数。这是让页面更快的关键。</p><blockquote><p>减少组件数的一个方法就是简化页面设计。保持富内容的页面且能减少 http 请求，有以下几个技术：</p></blockquote><ul><li><strong>Combined files</strong> (合并文件)：通过把所有脚本放在一个文件中的方式来减少请求数的，当然，也可以合并所有的<code>CSS</code>。如果各个页面的脚本和样式不一样的话，合并文件就是一项比较麻烦的工作了，但把这个作为站点发布过程的一部分确实可以提高响应时间。</li><li><strong>CSS Sprites</strong>（雪碧图）：雪碧图可以合并多个背景图片，通过 <code>background-image</code> 和<code>background-position</code> 来显示不同部分。</li><li><strong>Image maps</strong> （图片映射）：可以把多张图片合并成单张图片，总大小是一样的，但减少了请求数并加速了页面加载。图片映射只有在图像在页面中连续的时候才有用，比如导航条。给<code>image map</code>设置坐标的过程既无聊又容易出错，用<code>image map</code>来做导航也不容易，所以<strong>不推荐</strong>用这种方式。</li><li><strong>Inline images</strong> (内联图片)：使用 <code>data:url scheme</code> 来内联图片，将内嵌图像组合到（缓存的）样式表中同样也是一种减少 <code>HTTP</code> 请求并避免增加页面大小的方法。<code>Inline images</code> 这里是将矢量图标转换为<code>base64</code>编码，然后直接内嵌到<code>HTML</code>文件或者<code>CSS</code>文件当中，减少<code>http</code>请求。</li></ul><p>减少请求数是为第一次访问页面的用户提高性能的最重要的指导。</p><p><strong>减少DNS查询</strong></p><p>在浏览器地址栏输入网址，通过 DNS 查询得到网站真实 IP。DNS 查询被缓存来就可以提高性能。这种缓存可能发生在特定的缓存服务器（ISP&#x2F;local area network维护），或者用户的计算机。DNS 信息留存在操作系统 DNS 缓存中。大多浏览器有自己的缓存，独立于操作系统缓存。只要浏览器在自己的缓存里有某条DNS 记录，它就不会向操作系统发 DNS 解析请求。IE默认缓存 DNS 记录30分钟，FireFox 默认缓存1分钟。</p><p>当客户端的 DNS 缓存是空的，DNS 查找次数等于页面中的唯一域名数。减少DNS请求数可能会减少并行下载数。避免 DNS 查找减少响应时间，但减少并行下载数可能会增加响应时间。指导原则是组件可以分散在至少2个但不多于4个的不同域名。这是这两者的一个平衡点。</p><p><strong>避免重定向</strong></p><p>重定向用301或302状态码来完成。</p><blockquote><p>一个301响应 http 头的例子：</p></blockquote><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs HTTP"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">301</span> Moved Permanently<br><span class="hljs-attribute">Location</span><span class="hljs-punctuation">: </span>http://example.com/newuri<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/html<br></code></pre></td></tr></table></figure><ul><li>浏览器自动跳转到 <code>Location </code>指定的路径。重定向所需的所有信息都在 <code>http </code>头部，所以 <code>http</code>主体一般是空的。301和302响应一般不会被缓存，除非有额外的头部信息，比如 Expires 或 Cache-Control 指定要缓存。meta 刷新标签或 JavaScript 也可以跳转，但如果真要跳转，3xx跳转更好，主要是保证返回键可用。</li><li>最重要的是重定向会降低用户体验。在用户和 HTML 文档之间插入重定向会延迟页面中的所有内容，因为页面中的任何内容都无法呈现，并且在 HTML 文档到达之前不会开始下载任何组件。</li><li>最浪费的跳转之一发生在url尾部斜杠（&#x2F;）缺失。比如<a href="http://astrology.yahoo.com/astrology%E4%BC%9A301%E8%B7%B3%E8%BD%AC%E5%88%B0http://astrology.yahoo.com/astrology/%E3%80%82%E8%BF%99%E5%8F%AF%E4%BB%A5%E8%A2%ABApache%E7%AD%89%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BF%AE%E5%A4%8D%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%BD%BF%E7%94%A8%E7%9A%84%E6%98%AFApache%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%EF%BC%8C%E5%88%99%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8Alias%EF%BC%8Cmod_rewrite%E6%88%96DirectorySlash%E6%8C%87%E4%BB%A4%E6%9D%A5%E5%8F%96%E6%B6%88%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%82">http://astrology.yahoo.com/astrology会301跳转到http://astrology.yahoo.com/astrology/。这可以被Apache等服务器修复，如果使用的是Apache处理程序，则可以使用Alias，mod_rewrite或DirectorySlash指令来取消不必要的重定向。</a></li><li>重定向最常见的用途是把旧站点连接到新的站点，还可以连接同一站点的不同部分，针对用户的不同情况（浏览器类型，用户帐号类型等）做一些处理。用重定向来连接两个网站是最简单的，只需要少量的额外代码。虽然在这些时候使用重定向减少了开发人员的开发复杂度，但降低了用户体验。一种替代方案是用Alias和mod_rewrite，前提是两个代码路径都在相同的服务器上。如果是因为域名变化而使用了重定向，就可以创建一条CNAME（创建一个指向另一个域名的DNS记录作为别名）结合Alias或者mod_rewrite指令。</li></ul><p><strong>让Ajax可缓存</strong></p><p>使用 ajax 的好处是可以向用户提供很快的反馈，因为它是向后台异步请求数据。但是，这些异步请求不保证用户等待的时间——异步不意味着瞬时。提高ajax性能的最重要的方法是让响应被缓存，即在上面讨论的 Expires 。其它方法是：</p><ul><li>gzip 组件</li><li>减少 DNS 查找</li><li>压缩 JS</li><li>避免跳转</li><li>设置 ETags</li></ul><p><strong>延迟加载组件</strong></p><p>我们需要考虑什么是页面初始化时所必须的。剩下的内容和组件就可以延迟加载。<code>JavaScript </code>是理想的（延迟）候选者，可以切分到 <code>onload </code>事件之前和之后。比如拖放的 <code>js</code>库可以延迟，因为拖动必须在页面初始化之后。其它可延迟的包括隐藏的内容，折叠起来的图片等。</p><p><strong>预加载组件</strong></p><p>预加载看起来与延迟加载是相反的，但它的确有不同的目标。通过预加载可以利用浏览器的空闲时间来请求将来会用到的组件。这样当用户访问下一个页面时，会有更多的组件已经在缓存中，这样会极大加快页面加载。预加载类型：</p><ul><li>无条件预加载：一旦 <code>onload </code>触发，你立即获取另外的组件。比如谷歌会在主页这样加载搜索结果页面用到的雪碧图。</li><li>有条件预加载：基于用户动作，推测用户下一步会去哪里并加载相应组件。</li><li>预期的预加载：在发布重新设计的网站前提前加载。在旧网页预加载新网页的部分组件，那么切换到新网页时就不会是没有任何缓存了。</li></ul><p><strong>减少DOM元素的数量</strong></p><p>一个复杂的页面意味着更多的内容需要下载，以及更慢的 <code>DOM </code>访问。比如在有 500个DOM 元素的页面添加事件处理就和有 5000 个DOM 元素是有区别的。</p><p>如果页面 DOM 元素很多，那么意味着可能需要删除无用的内容和标签来优化。</p><p><strong>把组件分散到不同的域名</strong></p><p>把组件分散到不同的域名允许你最大化并行下载数。但要确保只用不超过<code>2-4</code>个域，因为存在<code>DNS</code>查找的代价。例如，可以把<code>HTML</code>和动态内容部署在<a href="http://www.example.org，而把静态组件分离到[static1.example.org]()和[static2.example.org]()。">www.example.org，而把静态组件分离到[static1.example.org]()和[static2.example.org]()。</a></p><p><strong>尽量少用 iframe</strong></p><p><code>iframe </code>允许 <code>html </code>文档被插入到父文档里。</p><p>iframe的优点</p><ul><li><p>帮助解决缓慢的第三方内容的加载，如广告和标志；</p></li><li><p>并行下载脚本；</p></li><li><p>安全沙箱；</p></li></ul><p>iframe的缺点</p><ul><li>即使空的也消耗（资源和时间）；</li><li>阻塞了页面的onload；</li><li>非语义化（标签）；</li></ul><p><strong>杜绝404</strong></p><p><code>http </code>请求是昂贵的，所以发出 <code>http </code>请求但获得没用的响应（如404）是完全不必要的，并且会降低用户体验。一些网站会有特别的 404 页面提高用户体验，但这仍然会浪费服务器资源。最坏的情况的是当链接指向外部 <code>js</code>但却得到 <code>404 </code>结果，这样首先会占用并行下载数，其次浏览器可能会把 <code>404 </code>响应体当作 <code>js</code>来解析，试图从里面找出可用的东西。</p>]]></content>
    
    
    <categories>
      
      <category>性能优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>知道HTTPS吗? 实现原理是什么？</title>
    <link href="/2023/11/02/https/"/>
    <url>/2023/11/02/https/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是-HTTPS"><a href="#什么是-HTTPS" class="headerlink" title="什么是 HTTPS?"></a>什么是 HTTPS?</h2><blockquote><p>HTTPS并不是一个新的协议, 它在HTTP和TCP的传输中<strong>建立了一个安全层</strong>，利用<strong>对称加密和非对称加密结合数字证书认证</strong>的方式，让传输过程的安全性大大提高。</p></blockquote><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202311021222407.png" alt="img" style="zoom:67%;" /><p>HTTP 协议采用<strong>明文传输</strong>信息，存在<strong>信息窃听</strong>、<strong>信息篡改</strong>和<strong>信息劫持</strong>的风险</p><p>具体来说，HTTP 数据经过 TCP 层，然后经过 WIFI 路由器、运营商和目标服务器，这些环节中都可能被中间人拿到数据并进行篡改，也就是我们常说的<strong>中间人攻击。</strong></p><p>而协议<code>TLS/SSL</code>具有<strong>身份验证</strong>、<strong>信息加密</strong>和<strong>完整性校验</strong>的功能，可以避免此类问题发生。安全层的主要职责就是<strong>对发起的 HTTP 请求的数据进行加密操作</strong> 和 <strong>对接收到的 HTTP 的内容进行解密操作</strong>。</p><p><strong><code>TLS/SSL</code><strong>全称</strong>安全传输层协议</strong>（Transport Layer Security）， 是介于<code>TCP</code>和<code>HTTP</code>之间的一层安全协议，不影响原有的<code>TCP</code>协议和<code>HTTP</code>协议，所以使用<code>HTTPS</code>基本上不需要对<code>HTTP</code>页面进行太多的改造。</p><p><code>TLS/SSL</code>的功能实现主要依赖三类基本算法：<strong>散列函数 hash</strong>、<strong>对称加密</strong>、<strong>非对称加密</strong>。</p><blockquote><p> 这三类算法的作用如下：</p></blockquote><ul><li>基于散列函数验证信息的完整性</li><li>对称加密算法采用协商的秘钥对数据加密</li><li>非对称加密实现身份认证和秘钥协商</li></ul><p><strong>散列函数</strong> : 在信息传输过程中，由于传输是明文传输，中间人可以修改信息后重新计算信息的摘要，所以需要对传输的信息和信息摘要进行加密。</p><p><strong>对称加密</strong> : 对称加密的优势就是信息传输使用一对一，需要共享相同的密码，密码的安全是保证信息安全的基础，服务器和 N 个客户端通信，需要维持 N 个密码记录且不能修改密码。</p><p><strong>非对称加密</strong> : 非对称加密的特点就是信息一对多，服务器只需要维持一个私钥就可以和多个客户端进行通信，但服务器发出的信息能够被所有的客户端解密，且该算法的计算复杂，加密的速度慢。</p><h2 id="HTTPS-是如何保证安全的"><a href="#HTTPS-是如何保证安全的" class="headerlink" title="HTTPS 是如何保证安全的?"></a>HTTPS 是如何保证安全的?</h2><p><strong>对称加密：</strong></p><ul><li>即通信的双方都使用同⼀个秘钥进行加解密，对称加密虽然很简单性能也好</li><li>但是无法解决首次把秘钥发给对方的问题，<strong>很容易被黑客拦截秘钥。</strong></li></ul><p><strong>非对称加密：</strong></p><ul><li>私钥 + 公钥 &#x3D; 密钥对</li><li>即用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据，只有对应的私钥才能解密</li><li>因为通信双方的收集都有⼀套自己的密钥对，通信之前双方会先把自己的公钥都先发给对方</li><li>然后对方再拿着这个公钥来加密数据响应给对方，等到到了对方那里，对方再用自己的私钥进行解密</li></ul><p><strong>非对称加密使用了一对密钥，公钥与私钥，所以安全性高，但加密与解密速度慢，影响性能。</strong></p><blockquote><p>有没有什么更好的方案呢?</p></blockquote><p>解决方案：两者结合</p><p><strong>结合两种加密方式， 解决的办法是将对称加密的密钥使用非对称加密的公钥进行加密，然后发送出去，接收方使用私钥进行解密得到对称加密的密钥，然后双方可以使用对称加密来进行沟通。</strong></p><p>尽管通过两者加密方式的结合，能够很好地实现加密传输，但实际上还是存在一些<strong>问题</strong></p><p>现在的方法也不一定是安全的，因为没有办法确定得到的公钥就一定是安全的公钥。可能存在一个中间人，截取了对方发给我们的公钥，然后将他自己的公钥发送给我们，当我们使用他的公钥加密后发送的信息，就可以被他用自己的私钥解密。然后他伪装成我们以同样的方法向对方发送信息，这样我们的信息就被窃取了，然而自己还不知道。</p><p>事实上 HTTPS 在上述结合对称和非对称加密的基础上，又添加了<strong>数字证书认证</strong>的步骤。</p><p>其目的就是<strong>让服务器证明自己的身份， 防止被中间人攻击。</strong></p><h2 id="数字证书是什么？"><a href="#数字证书是什么？" class="headerlink" title="数字证书是什么？"></a>数字证书是什么？</h2><p>首先使用一种 Hash 算法来对公钥和其他信息进行加密，生成一个信息摘要，然后让有公信力的认证中心（简称 CA ）用它的<strong>私钥</strong>对消息摘要加密，形成签名。最后将原始的信息和签名合在一起，称为数字证书。当接收方收到数字证书的时候，先根据原始信息使用同样的 Hash 算法生成一个摘要，然后使用 CA 的<strong>公钥</strong>来对数字证书中的签名进行解密，最后将解密获得的摘要和生成的摘要进行对比，就能发现得到的信息是否被更改了。</p><blockquote><p>这个方法最要的是认证中心的可靠性，一般浏览器里会内置一些顶层的认证中心的证书，相当于我们自动信任了他们，只有这样才能保证数据的安全。</p></blockquote><blockquote><p> 下面为具体流程</p></blockquote><p><strong>CA （有公信力的认证中心） 签发证书的过程：</strong></p><ul><li>首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 <code>Hash</code> 计算，得到一个 <code>Hash</code> 值；</li><li>然后 <code>CA</code> 会使用自己的私钥将该 <code>Hash</code> 值加密，生成 <code>Certificate Signature</code>，也就是 <code>CA</code> 对证书做了签名；</li><li>最后将 <code>Certificate Signature</code> 添加在文件证书上，形成数字证书；</li></ul><p><strong>客户端校验服务端的数字证书的过程：</strong></p><ul><li>首先客户端会使用同样的 <code>Hash</code> 算法获取该证书的 <code>Hash</code> 值 <code>H1</code>；</li><li>浏览器收到证书后可以使用 <code>CA</code> 的公钥解密 Certificate Signature 内容，得到一个 <code>Hash</code> 值 <code>H2</code> ；</li><li>最后比较 <code>H1</code> 和 <code>H2</code>，如果值相同，则为可信赖的证书，否则则认为证书不可信。</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>offset/client/scroll你都记清了吗?</title>
    <link href="/2023/10/27/scroll%20%20offset%20%20client/"/>
    <url>/2023/10/27/scroll%20%20offset%20%20client/</url>
    
    <content type="html"><![CDATA[<h2 id="offset家族"><a href="#offset家族" class="headerlink" title="offset家族"></a><code>offset</code>家族</h2><blockquote><p>都是整数值, 如果是小数会四舍五入</p></blockquote><ol><li><p><code>Element.offsetHeight</code>返回一个整数，包括**元素本身的高度、padding 和 border **，以及水平滚动条的高度 (如果存在滚动条）。</p></li><li><p><code>Element.offsetWidth</code>表示元素本身的宽度,  其他都与<code>Element.offsetHeight</code>一致。</p></li></ol><blockquote><p>这两个属性都是<strong>只读</strong>属性，只比<code>Element.clientHeight</code>和<code>Element.clientWidth</code>多了边框的高度或宽度。</p><p>如果元素的 CSS 设为不可见（比如<code>display: none;</code>），则返回<code>0</code>。</p></blockquote><ol start="3"><li><code>Element.offsetParent</code>属性返回最靠近当前元素的、并且 CSS 的<code>position</code>属性不等于<code>static</code>的上层元素。</li></ol><blockquote><p>该属性主要用于确定子元素位置偏移的计算基准，<code>Element.offsetTop</code>和<code>Element.offsetLeft</code>就是<code>offsetParent</code>元素计算的。</p><p>如果该元素是不可见的（<code>display</code>属性为<code>none</code>），或者位置是固定的（<code>position</code>属性为<code>fixed</code>），则<code>offsetParent</code>属性返回<code>null</code>。</p></blockquote><ol start="4"><li><p><code>Element.offsetLeft</code>返回当前元素左上角相对于最近的开启了定位的节点的水平位移</p></li><li><p><code>Element.offsetTop</code>返回垂直位移，单位为像素。通常，这两个值是指相对于父节点的位移。</p></li></ol><h2 id="client家族"><a href="#client家族" class="headerlink" title="client家族"></a><code>client</code>家族</h2><blockquote><p>都是整数值, 如果是小数会四舍五入</p></blockquote><ol><li><code>Element.clientHeight</code>表示<strong>元素节点本身的高度和</strong> **<code>padding</code>**，只对块级元素生效，对于行内元素返回<code>0</code>。</li></ol><blockquote><p>这个高度不包括<code>border</code>、<code>margin</code>。如果有水平滚动条，还要减去水平滚动条的高度。</p></blockquote><ol start="2"><li><p><code>Element.clientWidth</code>表示<strong>元素节点本身的宽度和</strong> <strong><code>padding</code></strong>, 其余和<code>Element.clientHeight</code>一致</p></li><li><p><code>Element.clientLeft</code>表示元素节点<strong>左边框的宽度</strong>，不包括左侧的<code>padding</code>和<code>margin</code>。如果没有设置左边框，或者是行内元素（<code>display: inline</code>），该属性返回<code>0</code>。</p></li><li><p><code>Element.clientTop</code>表示网页元素<strong>上边框的宽度</strong>，其他特点都与<code>clientLeft</code>相同。</p></li></ol><p><strong>判断滚动条是否滚动到底</strong> </p><ul><li>垂直滚动条 : <code>scrollHeight -scrollTop = clientHeight</code></li><li>水平滚动条 :  <code>scrollWidth - scrollLeft = clientWidth</code></li></ul><p><strong>其它</strong></p><ul><li><code>document.documentElement</code>的<code>clientHeight</code>属性，返回当前视口的高度（即浏览器窗口的高度），等同于<code>window.innerHeight</code>属性减去水平滚动条的高度（如果有的话）。</li><li><code>document.body</code>的高度则是网页的实际高度。一般来说，<code>document.body.clientHeight</code>(网页总高度)大于<code>document.documentElement.clientHeight</code>(视口高度)。</li></ul><h2 id="scroll家族"><a href="#scroll家族" class="headerlink" title="scroll家族"></a><code>scroll</code>家族</h2><blockquote><p>都是整数值, 如果是小数会四舍五入</p></blockquote><ol><li><p><code>Element.scrollHeight</code>表示当前元素的<strong>总高度，包括溢出容器、当前不可见的部分</strong>。它包括<code>padding</code>，但是不包括<code>border</code>、<code>margin</code>以及水平滚动条的高度（如果有水平滚动条的话），还包括伪元素（<code>::before</code>或<code>::after</code>）的高度。</p></li><li><p><code>Element.scrollWidth</code>属性表示当前元素的<strong>总宽度</strong>，其他地方都与<code>scrollHeight</code>属性类似。这两个属性只读。</p></li></ol><blockquote><p> 整张网页的总高度可以从<code>document.documentElement</code>或<code>document.body</code>上读取。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 返回网页的总高度</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">scrollHeight</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">scrollHeight</span><br></code></pre></td></tr></table></figure><ol start="3"><li><p><code>Element.scrollLeft</code>属性表示当前元素的水平滚动条<strong>向右侧滚动的距离。</strong></p></li><li><p><code>Element.scrollTop</code>属性表示当前元素的垂直滚动条<strong>向下滚动的距离</strong>。对于那些没有滚动条的网页元素，这两个属性总是等于<code>0</code>。</p></li></ol><p>如果要查看整张网页的水平的和垂直的滚动距离，要从<code>document.documentElement</code>元素上读取。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">scrollLeft</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">scrollTop</span><br></code></pre></td></tr></table></figure><p>这两个属性都<strong>可读写</strong>，<strong>设置该属性的值（不需要单位），会导致浏览器将当前元素自动滚动到相应的位置。</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310272108830.png" alt="image-20231027210801789"></p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网页特效</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器渲染之什么是合成层?</title>
    <link href="/2023/10/26/CSS%E5%90%88%E6%88%90%E5%B1%82/"/>
    <url>/2023/10/26/CSS%E5%90%88%E6%88%90%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<h2 id="居中为什么要使用-transform-为什么不使用-margin-Left-x2F-Top"><a href="#居中为什么要使用-transform-为什么不使用-margin-Left-x2F-Top" class="headerlink" title="居中为什么要使用 transform , 为什么不使用 margin Left&#x2F;Top ?"></a>居中为什么要使用 transform , 为什么不使用 margin Left&#x2F;Top ?</h2><p>在我们日常开发中经常会实现一些动画，有时候我们可能会选择改变 <code>top/left</code> 去实现，那么这个节点的渲染会发生在<strong>普通文档流</strong>中。该属性的变化会导致重排（<code>reflow/relayout</code>）</p><p>而使用 <code>transform</code> 和 <code>opacity</code> 实现动画能够让节点被放置到一个<strong>独立合成层</strong>中进行渲染绘制，动画不会影响其他图层，并且 <code>GPU</code>渲染相比 <code>CPU </code>能够更快，这会让你的动画变的更加流畅</p><h2 id="什么是合成层"><a href="#什么是合成层" class="headerlink" title="什么是合成层?"></a>什么是合成层?</h2><p>在讨论<code>合成层</code>之前我们先简单了解一下浏览器渲染，浏览器常见的渲染引擎有 Webkit&#x2F;Gecko 等，他们的主要渲染流程基本相同</p><blockquote><p>讨论一下 WebKit 简化的渲染流程。</p></blockquote><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310262312479.png" alt="img"></p><ol><li>浏览器下载并解析 HTML。</li><li>处理 <code>CSS</code> 构建 <code>CSSOM</code> 树，生成 <code>DOM</code> 树。</li><li><code>DOM</code> 与 <code>CSSOM</code> 合并成一个 <code>Render</code> 树。</li><li>有了 <code>Render Tree</code>，浏览器可以知道各个节点的 <code>CSS</code> 定义以及他们的从属关系，从而去计算出每个节点在屏幕中的位置，生成一个足够大的画布来容纳所有元素。</li><li>根据浏览器提供各层的信息合成图层，显示到屏幕上。</li></ol><p><code>合成层</code>就出现在最后一步流程中，这些合成图层中一些特殊的图层被认为是合成层（Compositing Layers）</p><p>首先合成就是将页面的各个部分分成多个层、单独<strong>光栅化</strong>它们并在合成器线程中合成为一个页面的技术。</p><blockquote><p>光栅化 : 浏览器根据文档的结构、每个元素的样式、页面的几何形状和绘制顺序转换为屏幕上的像素的过程</p></blockquote><ul><li>一般来说，拥有一些特定属性的渲染层，会被浏览器自动提升为合成层。</li><li>合成层拥有单独的图层（GraphicsLayer），和其他图层之间无不影响。</li><li>而其它不是合成层的渲染层，则和第一个拥有图层的父层共用一个，也就是普通文档流中的内容</li></ul><h2 id="提升为合成层的属性"><a href="#提升为合成层的属性" class="headerlink" title="提升为合成层的属性"></a>提升为合成层的属性</h2><p>我们看一些<strong>常见的提升为合成层的属性。</strong></p><ul><li>设置 <code>transform: translateZ(0)</code>，注意它必须是 <code>translateZ</code>，因为它使用 <code>GPU</code>来计算 <code>perspective distortion</code>（透视失真）。<code>perspective</code> 在 <code>3D</code>设计中是一个重要的属性。如果你使用 <code>translateX</code> 或 <code>translateY</code>，元素将会被绘制在普通文档流中 </li><li><code>backface-visibility: hidden</code> : 指定当元素背面朝向观察者时是否可见</li><li><code>transform</code> &#x2F; <code> opacity</code></li><li><code>video</code>、<code>canvas</code>、<code>iframe</code> 等元素。</li><li><code>will-change</code> :  告诉浏览器该元素会有哪些变化，这样浏览器可以提前做好对应的优化准备工作。<ul><li>当该属性的值为 <code>opacity</code>、<code>transform</code>、<code>top</code>、<code>left</code>、<code>bottom</code>、<code>right </code>时。</li></ul></li></ul><p><strong>隐式合成</strong>就是特定场景下，存在会被默认提升为合成层的情况。</p><ul><li>一个或多个非合成元素应出现在堆叠顺序上 (<code>z-index</code>) 的合成元素之上，会被提升为合成层。</li></ul><h2 id="合成层的好处和问题"><a href="#合成层的好处和问题" class="headerlink" title="合成层的好处和问题"></a>合成层的好处和问题</h2><p>合成层开启的<strong>好处</strong></p><ul><li><p>开启硬件加速，合成层的位图会交由 <code>GPU</code>合成，相比 <code>CPU </code>处理要快。</p></li><li><p>合成层发生 <code>repaint</code>的时候，不会影响其他图层。</p></li><li><p>对于 <code>transform </code>和 <code>opacity</code>效果，不会触发 <code>layout</code>和 <code>paint</code>。</p></li></ul><p>当然合成层也存在一些<strong>问题</strong>：</p><ul><li>如果我们把所有渲染工作都交给 <code>GPU</code>，在现有的优化下，它会导致渲染内存占用比大幅度提升，反而出现负面的效果。</li><li>另外隐式合成容易产生大量我们意料之外的合成层，过大的内存占用，会让页面变的卡顿，性能优化适得其反。</li></ul><p><strong>谨慎使用 <code>will-change</code></strong></p><p>除非你的元素的真的存在某个属性马上会发生变化，例如 <code>transform</code>，你可以使用 <code>will-change: transform</code> 告知浏览器，根据您打算更改的元素，浏览器可能可以预先安排，元素的改变和渲染速度都会变得更快。</p><blockquote><p>这些属性可能会给你带来一些副作用</p></blockquote><p><strong>但需要注意的是，不要创建太多的渲染层。因为每创建一个新的渲染层，就意味着新的内存分配和更复杂的层的管理。</strong></p><blockquote><p>如果你已经把一个元素放到一个新的合成层里，那么可以使用 Timeline 来确认这么做是否真的改进了渲染性能。别盲目提升合成层，一定要分析其实际性能表现。</p></blockquote><p>其实从性能方面考虑，最理想的渲染流水线是没有布局和绘制环节的，只需要做合成层的合并即可： </p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310262312540.png" alt="img"></p><p>为了实现上述效果，就需要只使用那些仅触发 <code>Composite </code>的属性。目前，<strong>只有两个属性是满足这个条件的：transforms 和 opacity。</strong></p><p><strong>合理管理合成层</strong>：</p><blockquote><p> 大多数人都很喜欢使用 <code>translateZ(0)</code> 来进行所谓的硬件加速，以提升性能</p><p>但是性能优化并没有所谓的”银弹” (可解决复杂问题的简单方案)，<code>translateZ(0)</code> 不是，本文列出的优化建议也不是。</p><p>抛开了对页面的具体分析，任何的性能优化都是站不住脚的，盲目的使用一些优化措施，结果可能会适得其反。</p></blockquote><ul><li>创建一个新的合成层并不是免费的，它得消耗额外的内存和管理资源。实际上，在内存资源有限的设备上，合成层带来的性能改善，可能远远赶不上过多合成层开销给页面性能带来的负面影响。因此切实的去分析页面的实际性能表现，不断的改进测试，才是正确的优化途径。</li></ul><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310262312522.png" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>浏览器原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GPU渲染</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GPU 和 CSS 硬件加速</title>
    <link href="/2023/10/25/GPU%E6%B8%B2%E6%9F%93/"/>
    <url>/2023/10/25/GPU%E6%B8%B2%E6%9F%93/</url>
    
    <content type="html"><![CDATA[<h3 id="从cpu聊起"><a href="#从cpu聊起" class="headerlink" title="从cpu聊起"></a>从<code>cpu</code>聊起</h3><p>cpu 每个核只有一个线程，也就是单控制流、单数据流。这样的架构导致 cpu 在一些场景下效率是不高的，比如 3d 渲染的场景。</p><blockquote><p>3d 渲染的流程是：</p></blockquote><ul><li>计算顶点数据，构成 3d 的图形</li><li>给每个三角形贴图，画上纹理</li><li>投影到二维的屏幕，计算每个像素的颜色（光栅化）</li><li>把一帧的数据写入显存的帧缓冲区</li></ul><p>顶点的数量是非常庞大的，而 cpu 只能顺序的一个个计算，所以处理这种 3d 渲染会特别费劲，于是就出现了专门用于这种 3d 数据的并行计算的硬件，也就是 GPU。</p><h3 id="GPU-的构成"><a href="#GPU-的构成" class="headerlink" title="GPU 的构成"></a>GPU 的构成</h3><p>和 cpu 的一个一个数据计算不同，gpu 是并行的，有成百上千个核心用于并行计算</p><p>gpu 也是有着指令、译码、执行的流程，只不过，每个指令会并行执行 n 个计算，是单控制流多数据流的，而 cpu 是单控制流单数据流。</p><p>所以，对于 3d 渲染这种要计算成万个顶点数据和像素点的场景，GPU 会比 CPU 高效很多。</p><h3 id="cpu-和-gpu-的区别"><a href="#cpu-和-gpu-的区别" class="headerlink" title="cpu 和 gpu 的区别"></a>cpu 和 gpu 的区别</h3><p>cpu 是通用的，能够执行各种逻辑和运算，而 gpu 则是主要是用于并行计算大批量的重复任务，不能处理复杂逻辑。</p><p>cpu 中控制器和缓存占据了很大一部分，而 gpu 中这两部分则很少，但是有更多的核心用于计算。</p><p>两者对比的话，cpu 相当于一个大学生，能够解决各种难题，但是计算 1 万个加法就没那么快，而 gpu 就像一帮小学生，解决不了难题，但是计算加法这种就很快，因为人多。</p><p>也就是说如果逻辑复杂，那么只能用 cpu，如果只是计算量大，并且每个计算都比较重复，那就比较适合 gpu。</p><blockquote><p>3d 的渲染中有大量这种重复却简单的计算，比如顶点数据和光栅化的像素数据，通过 gpu 就可以并发的一次计算成百上千个</p></blockquote><h3 id="css-硬件加速"><a href="#css-硬件加速" class="headerlink" title="css 硬件加速"></a>css 硬件加速</h3><p>css 大部分样式还是通过 cpu 来计算的，但 css 中也有一些 3d 的样式和动画的样式，计算这些样式同样有很多重复且大量的计算任务，可以交给 gpu 来跑。</p><p>浏览器在处理下面的 css 的时候，会使用 gpu 渲染：</p><ul><li>transform</li><li>opacity</li><li>filter</li><li>will-change</li></ul><p>浏览器是把内容分到不同的图层分别渲染的，最后合并到一起，而触发 gpu 渲染会新建一个图层，把该元素样式的计算交给 gpu。</p><p>opacity 需要改变每个像素的值，符合重复且大量的特点，会新建图层，交给 gpu 渲染。transform 是动画，每个样式值的计算也符合重复且大量的特点，也默认会使用 gpu 加速。同理 fiter 也是一样。</p><p><strong>由于GPU中的这些CSS属性不触发</strong><code>repaint</code>，因此不需要重绘，单独处理，所以能大大提高网页的性能。</p><p>这里要注意的是 gpu 硬件加速是需要新建图层的，而把该元素移动到新图层是个耗时操作，界面可能会闪一下，所以最好提前做。<code>will-change</code> 就是提前告诉浏览器在一开始就把元素放到新的图层，方便后面用 <code>gpu </code>渲染的时候，不需要做图层的新建。</p><p>有的时候我们想<strong>强制触发硬件渲染</strong>，就可以通过以下方式 :</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-attribute">will-change</span>: transform<br>transform:<span class="hljs-built_in">translate3d</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>transform: <span class="hljs-built_in">rotateZ</span>(<span class="hljs-number">360deg</span>)<br></code></pre></td></tr></table></figure><p>通过这些操作开启GPU硬件加速之后，有些时候可能会导致浏览器频繁闪烁或抖动，可以尝试以下办法解决：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-attribute">backface-visibility</span>:hidden;   // <span class="hljs-attribute">backface-visibility</span> 指定当元素背面朝向观察者时是否可见。<br><span class="hljs-attribute">perspective</span>:<span class="hljs-number">1000</span>;  //  <span class="hljs-attribute">perspective</span> 指定了观察者与 z=<span class="hljs-number">0</span> 平面的距离<br></code></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>gpu 硬件加速能减轻 cpu 压力，使得渲染更流畅，但是也会增加内存的占用，对于 transform、opacity、filter 默认会开启硬件加速。<strong>其余情况，建议只在必要的时候用</strong>。</p><p>使用GPU渲染也会影响字体的抗锯齿效果。这是因为GPU和CPU具有不同的渲染机制。即使最终硬件加速停止了，文本还是会在动画期间显示得很模糊。</p><h3 id="其它场景"><a href="#其它场景" class="headerlink" title="其它场景"></a>其它场景</h3><p>重复且大量的计算任务只有 3d 渲染一种场景么？</p><p>不是的，AI 领域的机器学习也很典型，它的特点是大量的神经元需要计算，但是每个计算都比较简单，也很适合用 gpu 来跑。</p><p>现在的 gpu 不只是能跑图形渲染，也提供了一些编程能力，这部分 api 有 opencl 标准。可以通过 gpu 的并行计算能力来跑一些有大量计算但是没有很多逻辑的的任务，会比 cpu 效率更高。</p>]]></content>
    
    
    <categories>
      
      <category>性能优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GPU渲染</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>😈请介绍一下TCP和UDP</title>
    <link href="/2023/10/24/TCP%E4%B8%8EUDP/"/>
    <url>/2023/10/24/TCP%E4%B8%8EUDP/</url>
    
    <content type="html"><![CDATA[<h3 id="1-TCP-和-UDP-的概念及特点"><a href="#1-TCP-和-UDP-的概念及特点" class="headerlink" title="1. TCP 和 UDP 的概念及特点"></a>1. TCP 和 UDP 的概念及特点</h3><p>⭐<strong>UDP</strong></p><p><code>UDP</code>的全称是<strong>用户数据报协议</strong>，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在传输层，处于IP协议的上一层。<code>UDP</code>有<strong>不提供数据包分组和组装和不能对数据包进行排序</strong>的缺点，也就是说，<strong>当报文发送之后，是无法得知其是否安全完整到达</strong>的。</p><p><code>UDP</code>有<strong>不提供数据包分组和组装和不能对数据包进行排序</strong>的缺点，也就是说，<strong>当报文发送之后，是无法得知其是否安全完整到达</strong>的。</p><blockquote><p>它的特点如下：</p></blockquote><p><strong>1）面向无连接</strong></p><p>首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。</p><p>具体来说就是：</p><ul><li><p>在发送端，应用层将数据传递给传输层的 <code>UDP</code> 协议，<code>UDP</code> 只会给数据增加一个 <code>UDP</code> 头标识下是 <code>UDP</code> 协议，然后就传递给网络层了</p></li><li><p>在接收端，网络层将数据传递给传输层，<code>UDP</code> 只去除 <code>IP</code> 报文头就传递给应用层，不会任何拼接操作</p></li></ul><p><strong>2）有单播，多播，广播的功能</strong></p><p><code>UDP</code> 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 <code>UDP</code> 提供了单播，多播，广播的功能。</p><p><strong>3）面向报文</strong></p><p>发送方的<code>UDP</code>对应用程序交下来的报文，在添加首部后就向下交付<code>IP</code>层。<code>UDP</code>对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文</p><p><strong>4）不可靠性</strong></p><p>首先不可靠性体现在<strong>无连接</strong>上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。</p><p>并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。</p><p>再者网络环境时好时坏，但是 <code>UDP</code> 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在<strong>某些实时性要求高的场景（比如电话会议）就需要使用</strong> <code>UDP</code> <strong>而不是</strong> <code>TCP</code><strong>。</strong></p><p><strong>5）头部开销小，传输数据报文时是很高效的。</strong><br><code>UDP</code> 头部包含了以下几个数据：</p><ul><li>两个十六位的端口号，分别为源端口（可选字段）和目标端口</li><li>整个数据报文的长度</li><li>整个数据报文的检验和（IPv4 可选字段），该字段用于发现头部信息和数据中的错误</li></ul><p>因此 <code>UDP</code> 的<strong>头部开销小</strong>，只有<code>8</code>字节，相比 <code>TCP</code> 的至少<code>20</code>字节要少得多，在传输数据报文时是很高效的。</p><p><code>UDP</code> <strong>协议为什么不可靠 ?</strong></p><p><code>UDP</code>在传输数据之前不需要先建立连接，远地主机的运输层在接收到<code>UDP</code>报文后，不需要确认，提供不可靠交付。总结就以下四点：</p><ul><li>不保证消息交付：不确认，不重传，无超时</li><li>不保证交付顺序：不设置包序号，不重排，不会发生队首阻塞</li><li>不跟踪连接状态：不必建立连接或重启状态机</li><li>不进行拥塞控制：不内置客户端或网络反馈机制</li></ul><p>⭐<strong>TCP</strong></p><p><code>TCP</code>的全称是传输控制协议 , 是一种<strong>面向连接的、可靠的</strong>、<strong>基于字节流</strong>的传输层通信协议。</p><p>流就是指不间断的数据结构。</p><blockquote><p>它有以下几个特点：</p></blockquote><p><strong>1）面向连接</strong></p><p>面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。</p><p><strong>2）仅支持单播传输</strong></p><p>每条<code>TCP</code>传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。</p><p><strong>3）面向字节流</strong></p><p><code>TCP</code>不像<code>UDP</code>一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。</p><p><strong>4）可靠传输</strong></p><p>对于可靠传输，判断丢包、误码靠的是<code>TCP</code>的段编号以及确认号。<code>TCP</code>为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(<code>ACK</code>)；如果发送端实体在合理的往返时延(<code>RTT</code>)内未收到确认，那么对应的数据（假设丢失了）将会被重传。</p><blockquote><ul><li><p>有状态<br>TCP 会精准记录哪些数据发送了，哪些数据被对方接收了，哪些没有被接收到，而且保证数据包按序到达，不允许半点差错。</p></li><li><p>可控制<br>当意识到丢包了或者网络环境不佳，TCP 会根据具体情况调整自己的行为，控制自己的发送速度或者重发。</p></li></ul></blockquote><p><strong>5）提供拥塞控制</strong></p><p>当网络出现拥塞的时候，<code>TCP</code>能够减小向网络注入数据的速率和数量，缓解拥塞。</p><p><strong>6）提供全双工通信</strong></p><p><code>TCP</code>允许通信双方的应用程序在任何时候都能发送数据，因为<code>TCP</code>连接的两端都设有缓存，用来临时存放双向通信的数据。当然，<code>TCP</code>可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于<code>MSS</code>）</p><p><strong>TCP 的重传机制</strong></p><p>由于<code>TCP</code>的下层网络（网络层）可能出现<strong>丢失、重复或失序</strong>的情况，<code>TCP</code>协议提供可靠数据传输服务。为保证数据传输的正确性，<code>TCP</code>会重传其认为已丢失（包括报文中的比特错误）的包。<code>TCP</code>使用两套独立的机制来完成重传，一是<strong>基于时间</strong>，二是<strong>基于确认信息</strong>。</p><p><code>TCP</code>在发送一个数据之后，就开启一个定时器，若是在这个时间内没有收到发送数据的<code>ACK</code>确认报文，则对该报文进行重传，在达到一定次数还没有成功时放弃并发送一个复位信号。</p><h3 id="2-TCP-和-UDP-的区别"><a href="#2-TCP-和-UDP-的区别" class="headerlink" title="2. TCP 和 UDP 的区别"></a>2. TCP 和 UDP 的区别</h3><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310241713024.png" alt="img"></p><h3 id="3-TCP-和-UDP-的使用场景"><a href="#3-TCP-和-UDP-的使用场景" class="headerlink" title="3. TCP 和 UDP 的使用场景"></a>3. TCP 和 UDP 的使用场景</h3><ul><li><code>TCP</code><strong>应用场景：</strong> 效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有<code>UDP</code>高。例如：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。</li><li><code>UDP</code><strong>应用场景：</strong> 效率要求相对高，对准确性要求相对低的场景。例如：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）。</li></ul><h3 id="4-TCP的拥塞控制机制"><a href="#4-TCP的拥塞控制机制" class="headerlink" title="4. TCP的拥塞控制机制"></a>4. TCP的拥塞控制机制</h3><blockquote><p>流量控制发生在发送端跟接收端之间，并没有考虑到整个网络环境的影响，如果说当前网络特别差，特别容易丢包，那么发送端就应该注意一些了。而这也正是拥塞控制需要处理的问题。</p></blockquote><p>对于拥塞控制来说，TCP 每条连接都需要维护两个核心状态:</p><ul><li>拥塞窗口（Congestion Window，cwnd）</li><li>慢启动阈值（Slow Start Threshold，ssthresh）</li></ul><blockquote><p>涉及到的算法(机制)有以下四种：</p></blockquote><ul><li><strong>慢启动（慢开始）</strong></li><li><strong>拥塞避免</strong></li><li><strong>快速重传</strong></li><li><strong>快速恢复</strong></li></ul><ol><li><strong>拥塞窗口</strong></li></ol><p>拥塞窗口（Congestion Window，<code>cwnd</code>）是指目前自己还能传输的数据量大小。</p><blockquote><p>那么之前介绍了接收窗口的概念，两者有什么区别呢？</p></blockquote><ul><li>接收窗口(rwnd)是接收端给的限制</li><li>拥塞窗口(cwnd)是发送端的限制</li></ul><p><strong>拥塞窗口(cwnd)是发送方的, 限制的是发送窗口的大小。</strong></p><p>有了这两个窗口，如何来计算发送窗口？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">发送窗口大小 = <span class="hljs-title function_">min</span>(rwnd, cwnd)<br></code></pre></td></tr></table></figure><p>取两者的较小值。而拥塞控制，就是来控制<code>cwnd</code>的变化。</p><ol start="2"><li><strong>慢启动（慢开始）</strong></li></ol><blockquote><p>拥塞控制首先就是要采用一种保守的算法来慢慢地适应整个网络, ，这种算法叫慢启动</p></blockquote><ul><li>首先，三次握手，双方宣告自己的接收窗口大小</li><li>初始化自己的拥塞窗口(cwnd)大小, 设置cwnd &#x3D; 1</li><li>思路：开始传输的时候不要发送大量数据，而是先测试一下网络的拥塞程度，由小到大增加拥塞窗口的大小。</li></ul><blockquote><p>发送端每收到一个 ACK，拥塞窗口大小加 1，也就是说，每经过一个 RTT，cwnd 翻倍。如果说初始窗口为 10，那么第一轮 10 个报文传完且发送端收到 ACK 后，cwnd 变为 20，第二轮变为 40，第三轮变为 80，以此类推。</p></blockquote><ul><li>为了防止<code>cwnd</code>增长过大引起网络拥塞，设置一个慢启动阈值（<code>ssthresh</code> 状态变量） <ul><li>当<code>cnwd &lt; ssthresh</code>，使用慢开始算法</li><li>当<code>cnwd = ssthresh</code>，既可使用慢开始算法，也可以使用拥塞避免算法</li><li>当<code>cnwd &gt; ssthresh</code>，使用<strong>拥塞避免</strong>算法</li></ul></li></ul><ol start="3"><li><strong>拥塞避免</strong></li></ol><ul><li>拥塞避免未必能够完全避免拥塞，是说在拥塞避免阶段<strong>将拥塞窗口控制为按线性增长</strong>，使网络不容易出现阻塞。</li><li>思路： 让拥塞窗口<code>cwnd</code>缓慢的增大，即每经过一个返回时间<code>RTT</code>就把发送方的拥塞控制窗口加<code>1</code></li></ul><blockquote><p>也就是说，以前一个 RTT 下来，cwnd翻倍，现在cwnd只是增加 1 而已。</p><p>当然，慢启动和拥塞避免是一起作用的，是一体的。</p></blockquote><ul><li>无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞，就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为<code>1</code>，执行慢开始算法。其中，判断网络出现拥塞的根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理。</li></ul><blockquote><p> 如图 : </p></blockquote><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310241713132.png" alt="img"></p><ol start="4"><li><strong>快速重传</strong></li></ol><ul><li>快速重传要求接收方在收到一个失序的报文段(即丢包)后就立即发出重复确认<code>ACK</code>（为的是使发送方及早知道有报文段没有到达对方）。发送方只要连续收到<strong>三个重复确认</strong>就立即重传对方尚未收到的报文段，而不用等到一个 RTO(超时重传时间, 是根据RTT计算得到) 的时间到了才重传</li><li>由于不需要等待设置的重传计时器到期，能尽早重传未被确认的报文段，能提高整个网络的吞吐量</li></ul><blockquote><p>例子 : 比如第 5 个包丢了，即使第 6、7 个包到达的接收端，接收端也一律返回第 4 个包的 ACK。当发送端收到 3 个重复的 ACK 时，意识到丢包了，于是马上进行重传，不用等到一个 RTO 的时间到了才重传。</p></blockquote><p><strong>选择性重传</strong></p><blockquote><p>那你可能会问了，既然要重传，那么只重传第 5 个包还是第5、6、7 个包都重传呢？</p></blockquote><p>当然第 6、7 个都已经到达了，已经传过去干嘛还要传？干脆<strong>记录一下哪些包到了，哪些没到，针对性地重传。</strong></p><p>在收到发送端的报文后，接收端回复一个 <code>ACK</code> 报文，那么在这个报文首部的<strong>可选项</strong>中，就可以加上**<code>SACK</code>**这个属性，通过<code>left edge</code>和<code>right edge</code>告知发送端已经收到了哪些区间的数据报。因此，即使第 5 个包丢包了，当收到第 6、7 个包之后，接收端依然会告诉发送端，这两个包到了。剩下第 5 个包没到，就重传这个包。</p><p>这个过程也叫做<strong>选择性重传</strong>(SACK，Selective Acknowledgment)，它解决的是如何重传的问题。</p><ol start="5"><li><strong>快速恢复</strong></li></ol><ul><li><p>当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把<code>ssthresh</code>门限减半。但是接下去并不执行慢开始算法。</p></li><li><p>考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将<code>cwnd</code>设置为<code>ssthresh</code>的大小，然后执行拥塞避免算法。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">// 以下按顺序执行<br>拥塞阈值 /<span class="hljs-operator">=</span> <span class="hljs-number">2</span><br>拥塞窗口大小 <span class="hljs-operator">=</span> 拥塞阈值<br>拥塞窗口大小线性增加<br></code></pre></td></tr></table></figure></li></ul><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310241713088.png" alt="img"></p><h3 id="5-TCP的流量控制机制"><a href="#5-TCP的流量控制机制" class="headerlink" title="5. TCP的流量控制机制"></a>5. TCP的流量控制机制</h3><blockquote><p>对于发送端和接收端而言，TCP 需要把发送的数据放到发送缓存区, 将接收的数据放到接收缓存区。<br>而流量控制所要做的事情，就是在通过接收缓存区的大小，控制发送端的发送。如果对方的接收缓存区满了，就不能再继续发送了。</p></blockquote><blockquote><p>TCP 滑动窗口分为两种: 发送窗口和接收窗口。</p></blockquote><p>一般来说，流量控制就是为了让发送方发送数据的速度不要太快，要让接收方来得及接收。TCP采用大小可变的<strong>滑动窗口</strong>进行流量控制，窗口大小的单位是字节。这里说的窗口大小其实就是每次传输的数据大小。</p><ul><li>当一个连接建立时(三次握手后)，连接的每一端分配一个缓冲区来保存输入的数据(初始化窗口大小)，并将缓冲区的大小发送给另一端。</li><li>当数据到达时，接收方发送确认，其中包含了自己剩余的缓冲区大小。（剩余的缓冲区空间的大小被称为窗口，指出窗口大小的通知称为窗口通告 。接收方在发送的每一确认中都含有一个窗口通告。) </li><li>如果接收方应用程序读数据的速度能够与数据到达的速度一样快，接收方将在每一确认中发送一个正的窗口通告。</li><li>如果发送方操作的速度快于接收方，接收到的数据最终将充满接收方的缓冲区，导致接收方通告一个零窗口。发送方收到一个零窗口通告时，必须停止发送，直到接收方重新通告一个正的窗口。</li></ul><h3 id="6-TCP的可靠传输机制"><a href="#6-TCP的可靠传输机制" class="headerlink" title="6. TCP的可靠传输机制"></a>6. TCP的可靠传输机制</h3><p><code>TCP</code> 的可靠传输机制是基于<strong>连续</strong> <code>ARQ</code> <strong>协议</strong>和<strong>滑动窗口协议</strong>的。</p><p><code>TCP</code> 协议在发送方维持了一个发送窗口</p><ul><li>发送窗口以前的报文段是已经发送并确认了的报文段，</li><li>发送窗口内包含了已经发送但未确认的报文段和允许发送但还未发送的报文段</li><li>发送窗口以后的报文段是缓存中还不允许发送的报文段。</li></ul><p>当<strong>发送方</strong>向<strong>接收方</strong>发送报文时，会依次发送窗口内的所有报文段，并且设置一个定时器，这个定时器可以理解为是最早发送但未收到确认的报文段。 </p><ul><li>如果在定时器的时间内收到某一个报文段的确认回答，则滑动窗口，将窗口的首部向后滑动到确认报文段的后一个位置。</li><li>此时如果还有已发送但没有确认的报文段，则重新设置定时器，如果没有了则关闭定时器。</li><li>如果定时器超时，则<strong>重新发送</strong>所有已经发送但还未收到确认的报文段，并将超时的间隔设置为以前的<strong>两倍</strong>。</li></ul><p>当发送方收到接收方的三个冗余的确认应答后，这是一种指示， 说明该报文段以后的报文段很有可能发生丢失了，那么发送方会启用<strong>快速重传</strong>的机制，就是当前定时器结束前，发送所有的<strong>已发送但确认</strong>的报文段。</p><p>接收方使用的是<strong>累计确认</strong>的机制，对于所有按序到达的报文段，接收方返回一个报文段的肯定回答。如果收到了一个乱序的报文段，那么接方会直接<strong>丢弃</strong>，并返回一个最近的按序到达的报文段的肯定回答。使用累计确认保证了返回的确认号之前的报文段都已经按序到达了，所以发送窗口可以移动到已确认报文段的后面。</p><p>发送窗口的大小是变化的，它是由接收窗口剩余大小和网络中拥塞程度来决定的，<code>TCP </code>就是通过控制发送窗口的长度来控制报文 段的发送速率。</p><p>但是 <code>TCP</code> 协议并不完全和滑动窗口协议相同，因为许多的 <code>TCP</code> 实现会将失序的报文段给<strong>缓存</strong>起来，并且发生重传时，只会重传一个报文段，因此 <code>TCP</code> 协议的可靠传输机制更像是窗口滑动协议和选择重传协议的一个混合体。</p><p><strong>TCP 如何保证传输过程的可靠性?</strong></p><ul><li><strong>校验和</strong>：发送方在发送数据之前计算校验和，接收方收到数据后同样计算，如果不一致，那么传输有误。</li><li><strong>确认应答，序列号</strong>：<code>TCP</code>进行传输时数据都进行了编号，每次接收方返回<code>ACK</code>都有确认序列号。</li><li><strong>超时重传</strong>：如果发送方发送数据一段时间后没有收到<code>ACK</code>，那么就重发数据。</li><li><strong>连接管理</strong>：三次握手和四次挥手的过程。</li><li><strong>流量控制</strong>：<code>TCP</code>协议报头包含16位的窗口大小，接收方会在返回<code>ACK</code>时同时把自己的即时窗口填入，发送方就根据报文中窗口的大小控制发送速度。</li><li><strong>拥塞控制</strong>：刚开始发送数据的时候，拥塞窗口是<code>1</code>，以后每次收到<code>ACK</code>，则拥塞窗口<code>+1</code>，然后将拥塞窗口和收到的窗口取<strong>较小值</strong>作为实际发送的窗口，如果发生超时重传，拥塞窗口重置为<code>1</code>。这样做的目的就是为了保证传输过程的高效性和可靠性。</li></ul><h3 id="7-❗TCP的三次握手和四次挥手"><a href="#7-❗TCP的三次握手和四次挥手" class="headerlink" title="7. ❗TCP的三次握手和四次挥手"></a>7. ❗TCP的三次握手和四次挥手</h3><p><strong>❗三次握手</strong></p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310241713110.png" alt="img"></p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310241713203.png" alt="img"></p><p>三次握手（Three-way Handshake）其实就是指建立一个<code>TCP</code>连接时，需要客户端和服务器总共发送<code>3</code>个包。进行三次握手的主要作用就是<strong>为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。</strong></p><blockquote><p>实质上其实就是连接服务器指定端口，建立<code>TCP</code>连接，并同步连接双方的序列号和确认号，交换<code>TCP</code>窗口大小信息。</p></blockquote><p>刚开始客户端处于 <code>Closed</code> 的状态，服务端处于 <code>Listen</code> 状态。</p><ul><li><strong>第一次握手</strong>：客户端给服务端发一个 <code>SYN</code> 报文，并指明客户端的初始化序列号 <code>ISN</code>，此时客户端处于   <code>SYN_SENT</code> 状态。</li></ul><blockquote><p>首部的同步位<code>SYN=1</code>，初始序号<code>seq=x</code>，<code>SYN=1</code>的报文段不能携带数据，但要消耗掉一个序号。</p></blockquote><ul><li><strong>第二次握手</strong>：服务器收到客户端的 <code>SYN</code> 报文之后，会以自己的 <code>SYN</code> 报文作为应答，并且也是指定了自己的初始化序列号 <code>ISN</code>。同时会把客户端的 <code>ISN + 1</code> 作为<code>ACK</code> 的值，表示自己已经收到了客户端的 <code>SYN</code>，此时服务器处于 <code>SYN_RCVD</code> 的状态。</li></ul><blockquote><p>在确认报文段中<code>SYN=1</code>，<code>ACK=1</code>，确认号<code>ack=x+1</code>，初始序号<code>seq=y</code></p></blockquote><ul><li><strong>第三次握手</strong>：客户端收到 <code>SYN</code> 报文之后，会发送一个 <code>ACK</code> 报文，当然，也是一样把服务器的 <code>ISN + 1</code> 作为 <code>ACK</code> 的值，表示已经收到了服务端的 <code>SYN</code> 报文，此时客户端处于 <code>ESTABLISHED</code> 状态。服务器收到 <code>ACK</code> 报文之后，也处于 <code>ESTABLISHED</code> 状态，此时，双方已建立起了连接。</li></ul><blockquote><p>确认报文段<code>ACK=1</code>，确认号<code>ack=y+1</code>，序号<code>seq=x+1</code>（初始为<code>seq=x</code>，第二个报文段所以要<code>+1</code>），   <code>ACK</code>报文段可以携带数据，不携带数据则不消耗序号。</p></blockquote><p><strong>那为什么要三次握手呢？两次不行吗？</strong></p><ul><li>如果是用两次握手，则会出现下面这种情况</li></ul><p>如果客户端发送第一个请求, 但是因为请求报文丢失服务端未收到, 于是客户端发送第二个请求, 这时候服务端收到请求, 客户端也收到了确认, 这时便建立了连接。</p><p>但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求,  于是就向客户端发出确认报文段，同意建立连接, 这时客户端收到了确认便建立了连接, 但是客户端不知道这个连接咋来的, 就忽略了这个确认, 那么服务端就一直等待客户端发送数据, 就会浪费服务端的资源。(以上都是建立在两次握手的情况下)</p><p><strong>简单来说就是以下三步：</strong></p><ul><li><strong>第一次握手：</strong> 客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 <code>SYN-SENT</code> 状态。</li><li><strong>第二次握手：</strong> 服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 <code>SYN-RECEIVED</code> 状态。</li><li><strong>第三次握手：</strong> 当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 <code>ESTABLISHED</code> 状态，服务端收到这个应答后也进入 <code>ESTABLISHED</code> 状态，此时连接建立成功。</li></ul><p><code>TCP</code> 三次握手的建立连接的过程就是相互确认初始序号的过程，告诉对方，什么样序号的报文段能够被正确接收。 第三次握手的作用是客户端对服务器端的初始序号的确认。如果只使用两次握手，那么服务器就没有办法知道自己的序号是否 已被确认。同时这样也是为了防止失效的请求报文段被服务器接收，而出现错误的情况。</p><p><strong>❗四次挥手</strong></p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310241713172.png" alt="img"></p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310241713016.png" alt="img"></p><p>双方都处于 <code>ESTABLISHED</code> 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：</p><ul><li><strong>第一次挥手</strong>： 客户端会发送一个 <code>FIN </code>报文，报文中会指定一个序列号。此时客户端处于 <code>FIN_WAIT1</code> 状态。</li></ul><blockquote><p>即发出连接释放报文段（<code>FIN=1</code>，序号<code>seq=u</code>）, 并停止再发送数据，主动关闭<code>TCP</code>连接，进入<code>FIN_WAIT1</code>（终止等待1）状态，等待服务端的确认。</p></blockquote><ul><li><strong>第二次挥手</strong>：服务端收到 <code>FIN </code>之后，会发送 <code>ACK</code> 报文，且把客户端的序列号值 <code>+1</code> 作为 <code>ACK</code> 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 <code>CLOSE_WAIT</code> 状态。因为<code>server</code>端可能还有没有发送完成的数据</li></ul><blockquote><p>即服务端收到连接释放报文段后即发出确认报文段（<code>ACK=1</code>，确认号<code>ack=u+1</code>，序号<code>seq=v</code>），服务端进入<code>CLOSE_WAIT</code>（关闭等待）状态，此时的<code>TCP</code>处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入<code>FIN_WAIT2</code>（终止等待2）状态，等待服务端发出的连接释放报文段。</p></blockquote><ul><li><strong>第三次挥手：</strong>等到<code>server</code>端数据都发送完毕之后,  这时服务端也想断开连接，和客户端的第一次挥手一样，发给 <code>FIN</code> 报文，且指定一个序列号。此时服务端处于 <code>LAST_ACK</code>的状态。</li></ul><blockquote><p>即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（<code>FIN=1</code>，<code>ACK=1</code>，序号<code>seq=w</code>，确认号<code>ack=u+1</code>），服务端进入<code>LAST_ACK</code>（最后确认）状态，等待客户端的确认。</p></blockquote><ul><li><strong>第四次挥手：</strong>客户端收到 <code>FIN</code> 之后，一样发送一个 <code>ACK</code> 报文作为应答，且把服务端的序列号值 <code>+1</code> 作为自己 <code>ACK</code> 报文的序列号值，此时客户端处于 <code>TIME_WAIT</code> 状态。需要过一阵子以确保服务端收到自己的 <code>ACK</code> 报文之后才会进入 <code>CLOSED</code> 状态，服务端收到 <code>ACK</code> 报文之后，就处于关闭连接了，处于 <code>CLOSED</code> 状态。</li></ul><blockquote><p>即客户端收到服务端的连接释放报文段后，对此发出确认报文段（<code>ACK=1</code>，<code>seq=u+1</code>，<code>ack=w+1</code>），客户端进入<code>TIME_WAIT</code>（时间等待）状态。此时<code>TCP</code>未释放掉，需要经过时间等待计时器设置的时间<code>2MSL</code>后，客户端才进入<code>CLOSED</code>状态。</p></blockquote><p><strong>为什么要四次挥手呢?</strong></p><p>因为当服务端收到客户端的<code>SYN</code>连接请求报文后，可以直接发送<code>SYN+ACK</code>报文。其中<code>ACK</code>报文是用来应答的，<code>SYN</code>报文是用来同步的。但是关闭连接时，当服务端收到<code>FIN</code>报文时，很可能并不会立即关闭<code>SOCKET</code>，所以只能先回复一个<code>ACK</code>报文，告诉客户端，”你发的<code>FIN</code>报文我收到了”。<strong>只有等到我服务端所有的报文都发送完了，我才能发送</strong><code>**FIN**</code><strong>报文</strong>，因此不能一起发送，故需要四次挥手。</p><p><strong>简单来说就是以下四步：</strong></p><ul><li><strong>第一次挥手：</strong> 若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。</li><li><strong>第二次挥手</strong>：服务端收到连接释放请求后，会告诉应用层要释放 <code>TCP</code> 链接。然后会发送 <code>ACK</code> 包，并进入 <code>CLOSE_WAIT</code> 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 <code>TCP</code> 连接是双向的，所以服务端仍旧可以发送数据给客户端。</li><li><strong>第三次挥手</strong>：服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 <code>LAST-ACK</code> 状态。</li><li><strong>第四次挥手：</strong> 客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 <code>TIME-WAIT</code> 状态。该状态会持续 <code>2MSL</code>（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 <code>CLOSED</code> 状态。当服务端收到确认应答后，也便进入 <code>CLOSED</code> 状态。</li></ul><p><code>TCP</code> 使用四次挥手的原因是因为 <code>TCP</code> 的连接是<strong>全双工</strong>的，所以需要双方分别释放到对方的连接，单独一方的连接释放，只代表不能再向对方发送数据，连接处于的是半释放的状态。</p><p>最后一次挥手中，客户端会等待一段时间再关闭的原因，是为了防止发送给服务器的确认报文段丢失或者出错，从而导致服务器端不能正常关闭。</p><h3 id="8-TCP-粘包是怎么回事，如何处理-为什么-UDP-不会"><a href="#8-TCP-粘包是怎么回事，如何处理-为什么-UDP-不会" class="headerlink" title="8. TCP 粘包是怎么回事，如何处理? 为什么 UDP 不会?"></a>8. TCP 粘包是怎么回事，如何处理? 为什么 UDP 不会?</h3><p>默认情况下, <code>TCP</code> 连接会启用<strong>延迟传送</strong>算法 (<code>Nagle</code> 算法), 在数据发送之前缓存他们. </p><p>如果短时间有多个数据发送, 会缓冲到⼀起作⼀次发送 (缓冲大小见 <code>socket.bufferSize</code>), 这样可以<strong>减少</strong> <code>**IO**</code> <strong>消耗提高性能.</strong></p><p>如果是传输⽂件的话, 那么根本不用处理粘包的问题, 来⼀个包拼⼀个包就好了。但是如果是多条消息, 或者是别的⽤途的数据那么就需要处理粘包.</p><p><strong>下面看⼀个例⼦</strong></p><p>连续调⽤两次 send 分别发送两段数据 data1 和 data2, 在接收端有以下⼏种常⻅的情况:</p><ul><li>A. 先接收到 data1, 然后接收到 data2 . </li><li>B. 先接收到 data1 的部分数据, 然后接收到 data1 余下的部分以及 data2 的全部. </li><li>C. 先接收到了 data1 的全部数据和 data2 的部分数据, 然后接收到了 data2 的余下的数据. </li><li>D. ⼀次性接收到了 data1 和 data2 的全部数据.</li></ul><blockquote><p>其中的 BCD 就是我们常见的粘包的情况.</p></blockquote><p>⽽对于处理粘包的问题, 常⻅的解决⽅案有 : </p><ul><li><strong>多次发送之前间隔⼀个等待时间</strong>：只需要等上⼀段时间再进⾏下⼀次 <code>send</code> 就好, 适⽤于交互频率特别低的场景. 缺点也很明显, 对于⽐较频繁的场景⽽⾔传输效率实在太低，不过⼏乎不⽤做什么处理.</li><li><strong>关闭 Nagle 算法</strong>：关闭 <code>Nagle</code> 算法, 在 <code>Node.js</code> 中你可以通过 <code>socket.setNoDelay()</code> ⽅法来关闭 <code>Nagle</code> 算法, 让每⼀次 <code>send</code> 都不缓冲直接发送。该方法比较适用于每次发送的数据都比较大 (但不是⽂件那么大), 并且频率不是特别高的场景<strong>。</strong>如果是每次发送的数据量比较小, 并且频率特别高的, 关闭 <code>Nagle</code> 纯属自废武功。</li><li><strong>进行封包&#x2F;拆包：</strong> 封包&#x2F;拆包是⽬前业内常⻅的解决⽅案了。即给每个数据包在发送之前, 于其前&#x2F;后放⼀些有特征的数据, 然后收到数据的时候根据特征数据分割出来各个数据包。</li></ul><p><strong>为什么udp不会粘包？</strong></p><ul><li><code>TCP</code>协议是面向流的协议，<code>UDP</code>是面向消息的协议。<code>UDP</code>段都是⼀条消息，应⽤程序必须<strong>以消息为单位</strong>提取数据，不能⼀次提取任意字节的数据</li><li><code>UDP</code>具有保护消息边界，在每个<code>UDP</code>包中就有了消息头（消息来源地址，端⼝等信息），这样对于接收端来说就容易进⾏区分处理了。传输协议把数据当作⼀条独⽴的消息在⽹上传输，接收端只能接收独⽴的消息。接收端⼀次只能接收发送端发出的⼀个<strong>数据包</strong> , 如果⼀次接受数据的大小小于发送端⼀次发送的数据⼤⼩，就会丢失⼀部分数据，即使丢失，接受端也不会分两次去接收。</li></ul><blockquote><p>祝大家程序员节快乐🎉🍾(10.24)</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树层序遍历, 你真的懂了吗？</title>
    <link href="/2023/10/21/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2023/10/21/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<p>⭐借鉴于代码随想录</p><p>二叉树的层序遍历，<strong>就是图论中的广度优先搜索在二叉树中的应用</strong>，需要借助队列来实现</p><blockquote><p> 此时又发现队列的一个应用了。</p></blockquote><p>来 — 一口气打十个!  (其实是九个)</p><hr><h3 id="1-二叉树的层序遍历"><a href="#1-二叉树的层序遍历" class="headerlink" title="1. 二叉树的层序遍历"></a>1. 二叉树的层序遍历</h3><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310211739444.png" alt="img"></p><p>层序遍历一个二叉树。就是从左到右一层一层的去遍历二叉树。这种遍历的方式和我们之前讲过的都不太一样。</p><p>需要借用一个辅助数据结构即队列来实现，<strong>队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。</strong></p><p><strong>而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。</strong></p><p>使用队列实现二叉树广度优先遍历，动画如下：</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310211739987.gif" alt="img"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> levelOrder = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">let</span> res = [], queue = [];<br>    <span class="hljs-keyword">if</span>(root === <span class="hljs-literal">null</span>)  <span class="hljs-keyword">return</span> res;<br>    queue.<span class="hljs-title function_">push</span>(root); <span class="hljs-comment">// root只是根节点</span><br>    <span class="hljs-keyword">while</span>(queue.<span class="hljs-property">length</span>) &#123;<br>        <span class="hljs-keyword">let</span> length = queue.<span class="hljs-property">length</span>; <span class="hljs-comment">// 记录当前层级有多少个节点</span><br>        <span class="hljs-keyword">let</span> curLevel = []; <span class="hljs-comment">// 存放每一层的所有节点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-keyword">let</span> node = queue.<span class="hljs-title function_">shift</span>(); <span class="hljs-comment">// 每次拿到队头元素</span><br>            curLevel.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">val</span>); <span class="hljs-comment">// 存放当前层下一层的节点</span><br>            node.<span class="hljs-property">left</span> &amp;&amp; queue.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">left</span>);<br>            node.<span class="hljs-property">right</span> &amp;&amp; queue.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">right</span>);<br>        &#125;<br>        res.<span class="hljs-title function_">push</span>(curLevel); <span class="hljs-comment">//把每一层的结果(所有节点)放到结果数组</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-二叉树的层序遍历-反着来"><a href="#2-二叉树的层序遍历-反着来" class="headerlink" title="2. 二叉树的层序遍历(反着来)"></a>2. 二叉树的层序遍历(反着来)</h3><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310211739428.png" alt="img"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> levelOrderBottom = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">let</span> res = [];<br>    <span class="hljs-keyword">let</span> queue = [];<br>    <span class="hljs-keyword">if</span>(root === <span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> res;<br>    queue.<span class="hljs-title function_">push</span>(root);<br>    <span class="hljs-keyword">while</span>(queue.<span class="hljs-property">length</span>) &#123;<br>        <span class="hljs-keyword">let</span> len = queue.<span class="hljs-property">length</span>;<br>        <span class="hljs-keyword">let</span> curLevel = [];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-keyword">let</span> node = queue.<span class="hljs-title function_">shift</span>();<br>            curLevel.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">val</span>);<br>            <span class="hljs-keyword">if</span>(node.<span class="hljs-property">left</span>) queue.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">left</span>);<br>            <span class="hljs-keyword">if</span>(node.<span class="hljs-property">right</span>) queue.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">right</span>);<br>        &#125;<br>        res.<span class="hljs-title function_">unshift</span>(curLevel)<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><p>最后改一下 push 的顺序就行</p><h3 id="3-二叉树的右视图"><a href="#3-二叉树的右视图" class="headerlink" title="3. 二叉树的右视图"></a>3. 二叉树的右视图</h3><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310211739435.png" alt="img"></p><p>依然是按照顶部到底部的顺序, 不要搞复杂了</p><p>这里就是当遍历到每一层最右边的节点时就加入到 curLevel 数组中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> rightSideView = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">let</span> res = [], queue = [];<br>    <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> res;<br>    queue.<span class="hljs-title function_">push</span>(root);<br>    <span class="hljs-keyword">while</span>(queue.<span class="hljs-property">length</span>) &#123;<br>        <span class="hljs-keyword">let</span> len = queue.<span class="hljs-property">length</span>;<br>        <span class="hljs-keyword">let</span> curLevel = [];<br>        <span class="hljs-keyword">while</span>(len--) &#123;<br>            <span class="hljs-keyword">let</span> node = queue.<span class="hljs-title function_">shift</span>();<br>            <span class="hljs-keyword">if</span>(!len) curLevel.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">val</span>);<br>            <span class="hljs-keyword">if</span>(node.<span class="hljs-property">left</span>) queue.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">left</span>);<br>            <span class="hljs-keyword">if</span>(node.<span class="hljs-property">right</span>) queue.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">right</span>);<br>        &#125;<br>        res.<span class="hljs-title function_">push</span>(curLevel);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="4-二叉树的层平均值"><a href="#4-二叉树的层平均值" class="headerlink" title="4. 二叉树的层平均值"></a>4. 二叉树的层平均值</h3><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310211739460.png" alt="img"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val, left, right) &#123;</span><br><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span><br><span class="hljs-comment"> *     this.left = (left===undefined ? null : left)</span><br><span class="hljs-comment"> *     this.right = (right===undefined ? null : right)</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">var</span> averageOfLevels = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">let</span> res = [], queue = [];<br>    queue.<span class="hljs-title function_">push</span>(root);<br>    <span class="hljs-keyword">while</span>(queue.<span class="hljs-property">length</span>) &#123;<br>        <span class="hljs-keyword">let</span> len = queue.<span class="hljs-property">length</span>;<br>        <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-keyword">let</span> node = queue.<span class="hljs-title function_">shift</span>();<br>            sum += node.<span class="hljs-property">val</span>;<br>            <span class="hljs-keyword">if</span>(node.<span class="hljs-property">left</span>) queue.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">left</span>);<br>            <span class="hljs-keyword">if</span>(node.<span class="hljs-property">right</span>) queue.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">right</span>);<br>        &#125;<br>        res.<span class="hljs-title function_">push</span>(sum / len)<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="5-N-叉树的层序遍历"><a href="#5-N-叉树的层序遍历" class="headerlink" title="5. N 叉树的层序遍历"></a>5. N 叉树的层序遍历</h3><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310211739433.png" alt="img"></p><blockquote><p> 跟模板没啥差别</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * // Definition for a Node.</span><br><span class="hljs-comment"> * function Node(val,children) &#123;</span><br><span class="hljs-comment"> *    this.val = val;</span><br><span class="hljs-comment"> *    this.children = children;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Node|null</span>&#125; <span class="hljs-variable">root</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[][]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> levelOrder = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">let</span> res = [], queue = [];<br>    <span class="hljs-keyword">if</span>(root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> res;<br>    queue.<span class="hljs-title function_">push</span>(root);<br>    <span class="hljs-keyword">while</span>(queue.<span class="hljs-property">length</span>) &#123;<br>        <span class="hljs-keyword">let</span> len = queue.<span class="hljs-property">length</span>;<br>        <span class="hljs-keyword">let</span> curLevel = [];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-keyword">let</span> node = queue.<span class="hljs-title function_">shift</span>();<br>            curLevel.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">val</span>);<br>          <span class="hljs-comment">// push所有子节点就行</span><br>            <span class="hljs-keyword">if</span>(node.<span class="hljs-property">children</span>) queue.<span class="hljs-title function_">push</span>(...node.<span class="hljs-property">children</span>)<br>        &#125;<br>        res.<span class="hljs-title function_">push</span>(curLevel);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="6-在每个树行中找最大值"><a href="#6-在每个树行中找最大值" class="headerlink" title="6. 在每个树行中找最大值"></a>6. 在每个树行中找最大值</h3><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310211739217.png" alt="img"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript">ar largestValues = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">let</span> res = [], queue = [];<br>    <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> res;<br>    queue.<span class="hljs-title function_">push</span>(root);<br>    <span class="hljs-keyword">while</span>(queue.<span class="hljs-property">length</span>) &#123;<br>        <span class="hljs-keyword">let</span> len = queue.<span class="hljs-property">length</span>;<br>        <span class="hljs-keyword">let</span> max = -<span class="hljs-title class_">Infinity</span>;  <span class="hljs-comment">// 注意有可能为负值, 所以不能取0</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-keyword">let</span> node = queue.<span class="hljs-title function_">shift</span>();<br>            max = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(max, node.<span class="hljs-property">val</span>);<br>            <span class="hljs-keyword">if</span>(node.<span class="hljs-property">left</span>) queue.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">left</span>);<br>            <span class="hljs-keyword">if</span>(node.<span class="hljs-property">right</span>) queue.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">right</span>);<br>        &#125;<br>        res.<span class="hljs-title function_">push</span>(max);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="7-填充每个节点的下一个右侧节点指针"><a href="#7-填充每个节点的下一个右侧节点指针" class="headerlink" title="7. 填充每个节点的下一个右侧节点指针"></a>7. 填充每个节点的下一个右侧节点指针</h3><p>这题将 “完美二叉树” 改为 “二叉树” 也没什么区别, 一模一样的代码 ~~</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310211739299.png" alt="img"></p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310211739194.png" alt="img"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * // Definition for a Node.</span><br><span class="hljs-comment"> * function Node(val, left, right, next) &#123;</span><br><span class="hljs-comment"> *    this.val = val === undefined ? null : val;</span><br><span class="hljs-comment"> *    this.left = left === undefined ? null : left;</span><br><span class="hljs-comment"> *    this.right = right === undefined ? null : right;</span><br><span class="hljs-comment"> *    this.next = next === undefined ? null : next;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Node</span>&#125; <span class="hljs-variable">root</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">Node</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> connect = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">let</span> queue = [];<br>    <span class="hljs-keyword">if</span>(root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root;<br>    queue.<span class="hljs-title function_">push</span>(root);<br>    <span class="hljs-keyword">while</span>(queue.<span class="hljs-property">length</span>) &#123;<br>        <span class="hljs-keyword">let</span> len = queue.<span class="hljs-property">length</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-keyword">let</span> node = queue.<span class="hljs-title function_">shift</span>();<br>          <span class="hljs-comment">// 因为前一个已经shift了, 后一个就是队首元素, 且要保证不是最后一个元素</span><br>            <span class="hljs-comment">// 如果是最后一个元素, 正好next就等于默认的null</span><br>            <span class="hljs-keyword">if</span>(i &lt; len - <span class="hljs-number">1</span>) node.<span class="hljs-property">next</span> = queue[<span class="hljs-number">0</span>]; <br>            <span class="hljs-keyword">if</span>(node.<span class="hljs-property">left</span>) queue.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">left</span>)<br>            <span class="hljs-keyword">if</span>(node.<span class="hljs-property">right</span>) queue.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">right</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="8-二叉树的最大深度"><a href="#8-二叉树的最大深度" class="headerlink" title="8. 二叉树的最大深度"></a>8. 二叉树的最大深度</h3><p>用层序遍历也挺简单, 最大深度就是层数</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310211739209.png" alt="img"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> maxDepth = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">let</span> queue = [], cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(root === <span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    queue.<span class="hljs-title function_">push</span>(root);<br>    <span class="hljs-keyword">while</span>(queue.<span class="hljs-property">length</span>) &#123;<br>        <span class="hljs-keyword">let</span> len = queue.<span class="hljs-property">length</span>;<br>        cnt++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-keyword">let</span> node = queue.<span class="hljs-title function_">shift</span>();<br>            <span class="hljs-keyword">if</span>(node.<span class="hljs-property">left</span>) queue.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">left</span>);<br>            <span class="hljs-keyword">if</span>(node.<span class="hljs-property">right</span>) queue.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">right</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="9-二叉树的最小深度"><a href="#9-二叉树的最小深度" class="headerlink" title="9. 二叉树的最小深度"></a>9. 二叉树的最小深度</h3><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310211739223.png" alt="img"></p><p>如果某一层的节点没有左右子节点, 那么最小深度就是这一层的层数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> minDepth = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">let</span> queue = [], cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    queue.<span class="hljs-title function_">push</span>(root);<br>    <span class="hljs-keyword">while</span>(queue.<span class="hljs-property">length</span>) &#123;<br>        <span class="hljs-keyword">let</span> len = queue.<span class="hljs-property">length</span>;<br>        cnt++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-keyword">let</span> node = queue.<span class="hljs-title function_">shift</span>();<br>            <span class="hljs-comment">// 如果某一层的节点没有左右子节点, 那么最小深度就是这一层的层数</span><br>            <span class="hljs-keyword">if</span>(!node.<span class="hljs-property">left</span> &amp;&amp; !node.<span class="hljs-property">right</span>)<span class="hljs-keyword">return</span> cnt;<br>            <span class="hljs-keyword">if</span>(node.<span class="hljs-property">left</span>) queue.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">left</span>);<br>            <span class="hljs-keyword">if</span>(node.<span class="hljs-property">right</span>) queue.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">right</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>over</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>介绍下 HTTP 的演化过程和优化？</title>
    <link href="/2023/10/20/HTTP%E6%BC%94%E5%8C%96/"/>
    <url>/2023/10/20/HTTP%E6%BC%94%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h3 id="1-HTTP-x2F-1-0-存在的问题"><a href="#1-HTTP-x2F-1-0-存在的问题" class="headerlink" title="1. HTTP&#x2F;1.0 存在的问题"></a>1. HTTP&#x2F;1.0 存在的问题</h3><ul><li>队头阻塞问题：因为只有⼀个连接，所以如果有⼀个请求被阻塞，后续请求也会被阻塞。</li><li>无法多路复用：只能按顺序传输⼀个请求和响应，无法同时传输多个请求和响应。</li><li>每次请求需要新建连接：每次请求都需要新建连接，连接的建⽴和关闭过程会消耗时间。</li></ul><h3 id="2-HTTP-x2F-1-0-到-HTTP-x2F-1-1-的优化："><a href="#2-HTTP-x2F-1-0-到-HTTP-x2F-1-1-的优化：" class="headerlink" title="2. HTTP&#x2F;1.0 到 HTTP&#x2F;1.1 的优化："></a>2. HTTP&#x2F;1.0 到 HTTP&#x2F;1.1 的优化：</h3><ul><li><strong>持久连接</strong>：在 HTTP&#x2F;1.0 中，每次请求都需要建⽴⼀个新的TCP连接，⽽在 HTTP&#x2F;1.1 中，引⼊了持久连接（也称为复⽤连接），这样可以在⼀个<code>TCP</code>连接上发送多个<code>HTTP</code>请求和响应，减少了<code>TCP</code>连接的建立和关闭所需的时间和资源消耗。 </li><li>**管线化 [1]**：在 HTTP&#x2F;1.1 中，⽀持请求管线化，即客户端可以同时发送多个请求，在服务端处理完第⼀个请求之前不必等待其它请求的返回。这种⽅式虽然提⾼了性能，但由于各个请求之间存在依赖关系，当其中⼀个请求出错时，会导致后续请求都失败.</li><li><strong>缓存方面</strong>，在 http1.0 中主要使用 header 里的 If-Modified-Since、Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略，例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。</li><li><strong>支持 Host 字段:</strong>  http1.1 中新增了 host 字段，通过在请求头中添加 Host 字段来区分不同的主机。用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此有了 host 字段，这样就可以将请求发往到同一台服务器上的不同网站。</li><li><strong>支持断点续传</strong> :  HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能。http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li><li><strong>新增 HTTP 方法</strong> :  http1.1 相对于 http1.0 还新增了很多请求方法，如 PUT、HEAD、OPTIONS 等。</li></ul><p><strong>什么是管线化(管道网络运输)?</strong></p><blockquote><p>管道（pipeline）网络传输是指：可以在同一个 <code>TCP</code> 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。但是服务器还是按照顺序回应请求。如果前面的回应特别慢，后面就会有许多请求排队等着。这称为队头堵塞。</p></blockquote><h3 id="3-HTTP-x2F-1-1-到-HTTP-x2F-2-的优化："><a href="#3-HTTP-x2F-1-1-到-HTTP-x2F-2-的优化：" class="headerlink" title="3. HTTP&#x2F;1.1 到 HTTP&#x2F;2 的优化："></a>3. HTTP&#x2F;1.1 到 HTTP&#x2F;2 的优化：</h3><ul><li><strong>二进制协议</strong>：HTTP&#x2F;2 是一个二进制协议。在 HTTP&#x2F;1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP&#x2F;2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础。</li><li><strong>数据流：</strong> HTTP&#x2F;2 使用了数据流的概念，因为 HTTP&#x2F;2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP&#x2F;2 将每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送时，都必须标记数据流 ID ，用来区分它属于哪个数据流。</li><li><strong>多路复用</strong>：HTTP&#x2F;1.x 中⼀个 TCP 连接只能同时处理⼀个请求，而 HTTP&#x2F;2 中⽀持多路复用，即同⼀个连接客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送,  这样就避免了”队头堵塞”[1] 的问题。</li><li><strong>头信息压缩：</strong> HTTP&#x2F;2 实现了头信息压缩，由于 HTTP 1.1 协议不带状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP&#x2F;2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表(首部表)，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了。</li><li><strong>服务器推送：</strong> HTTP&#x2F;2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送提前给客户端推送必要的资源，这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服务器主动推送的是静态资源，和 WebSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的。</li></ul><p><strong>什么是队头堵塞?</strong></p><blockquote><p>队头阻塞是由 HTTP 基本的“请求 - 应答”模型所导致的。HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列。队列里的请求是没有优先级的，只有入队的先后顺序，排在最前面的请求会被最优先处理。如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本，造成了队头堵塞的现象。</p></blockquote><p> <strong>页面有多张图片，HTTP是怎样的加载表现？</strong></p><ul><li>在HTTP 1下，浏览器对一个域名下最大<code>TCP</code>连接数为6，所以会请求多次。可以用多域名部署解决。这样可以提高同时请求的数目，加快页面图片的获取速度。</li><li>在HTTP 2下，可以一瞬间加载出来很多资源，因为，HTTP2支持<strong>多路复用</strong>，可以在一个TCP连接中发送多个HTTP请求。</li></ul><p><strong>HTTP2的头部压缩算法是怎样的？</strong></p><p><code>HTTP2</code>的头部压缩是<code>HPACK</code>算法。在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，采用<strong>哈夫曼编码</strong>来压缩整数和字符串，可以达到50%~90%的高压缩率。具体来说 : </p><ul><li>在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，<strong>对于相同的数据，不再通过每次请求和响应发送；</strong></li><li>首部表在<code>HTTP/2</code>的连接存续期内始终存在，由客户端和服务器共同渐进地更新；</li><li>每个新的首部键值对要么被追加到当前表的末尾，要么替换表中之前的值。</li></ul><h3 id="4-HTTP-x2F-2-到-HTTP-x2F-3-的优化："><a href="#4-HTTP-x2F-2-到-HTTP-x2F-3-的优化：" class="headerlink" title="4. HTTP&#x2F;2 到 HTTP&#x2F;3 的优化："></a>4. HTTP&#x2F;2 到 HTTP&#x2F;3 的优化：</h3><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310202352356.png" alt="img"></p><blockquote><p>了解</p></blockquote><p><code>HTTP/3</code>基于<code>UDP</code>协议实现了类似于<code>TCP</code>的多路复用数据流、传输可靠性等功能，这套功能被称为<code>QUIC</code>协议。</p><ul><li><strong>流量控制、传输可靠性功能</strong>：<code>QUIC</code>在<code>UDP</code>的基础上增加了一层来保证数据传输可靠性，它提供了数据包重传、拥塞控制、以及其他一些<code>TCP</code>中的特性。</li><li><strong>集成</strong><code>**TLS**</code><strong>加密功能</strong>：目前<code>QUIC</code>使用<code>TLS1.3</code>，减少了握手所花费的<code>RTT</code>数。</li><li><strong>多路复用</strong>：同一物理连接上可以有多个独立的逻辑数据流，实现了数据流的单独传输，解决了<code>TCP</code>的队头阻塞问题。</li><li><strong>快速握手</strong>：由于基于<code>UDP</code>，可以实现使用<code>0 ~ 1</code>个<code>RTT</code>来建立连接。</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你了解浏览器安全吗?</title>
    <link href="/2023/10/18/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8/"/>
    <url>/2023/10/18/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="1-什么是-XSS-攻击？"><a href="#1-什么是-XSS-攻击？" class="headerlink" title="1.  什么是 XSS 攻击？"></a>1.  什么是 XSS 攻击？</h2><blockquote><p>概念</p></blockquote><p>XSS 攻击指的是<strong>跨站脚本攻击</strong>，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 <code>cookie</code> 等。</p><p>XSS 的<strong>本质</strong>是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。</p><p>攻击者可以通过这种攻击方式可以进行以下操作：</p><ul><li>获取页面的数据，如<code>DOM</code>、<code>cookie</code>、<code>localStorage</code>；</li><li><code>DOS</code>攻击，发送合理请求，占用服务器资源，从而使用户无法访问服务器；</li><li>破坏页面结构；</li><li>流量劫持（将链接指向某网站）；</li></ul><blockquote><p>攻击类型</p></blockquote><p><code>XSS</code> 可以分为<strong>存储型</strong>、<strong>反射型</strong>和 <strong>DOM</strong> 型：</p><ul><li>存储型指的是恶意脚本会存储在目标服务器上，当浏览器请求数据时，脚本从服务器传回并执行。</li><li>反射型指的是攻击者诱导用户访问一个带有恶意代码的 URL 后，服务器端接收数据后处理，然后把带有恶意代码的数据发送到浏览器端，浏览器端解析这段带有 XSS 代码的数据后当做脚本执行，最终完成 XSS 攻击。 </li><li>DOM 型指的通过修改页面的 DOM 节点形成的 XSS。</li></ul><p><strong>1）存储型 XSS 的攻击步骤：</strong></p><ol><li>攻击者将恶意代码提交到⽬标⽹站的数据库中。</li><li>⽤户打开⽬标⽹站时，⽹站服务端将恶意代码从<strong>数据库</strong>取出，拼接在 <code>**HTML**</code> 中返回给浏览器。</li><li>⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。</li><li>恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。</li></ol><p>这种攻击常⻅于带有⽤户保存数据的⽹站功能，如论坛发帖、商品评论、⽤户私信等。</p><p><strong>2）反射型 XSS 的攻击步骤：</strong></p><ol><li>攻击者构造出特殊的 URL，其中包含恶意代码。</li><li>⽤户打开带有恶意代码的 URL 时，⽹站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。</li><li>⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。</li><li>恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。</li></ol><p>反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库⾥，反射型 XSS 的恶意代码存在 <strong>URL</strong> ⾥。</p><p>反射型 XSS 漏洞常⻅于通过 URL 传递参数的功能，如⽹站搜索、跳转等。 由于需要⽤户主动打开恶意的 URL 才能⽣效，攻击者往往会结合多种⼿段诱导⽤户点击。</p><p><strong>3）DOM 型 XSS 的攻击步骤：</strong></p><ol><li>攻击者构造出特殊的 URL，其中包含恶意代码。</li><li>⽤户打开带有恶意代码的 URL。</li><li>⽤户浏览器接收到响应后解析执⾏，<strong>前端</strong> <code>**JavaScript**</code> 取出 URL 中的恶意代码并执⾏。</li><li>恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。</li></ol><p>DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执⾏恶意代码由<strong>浏览器端</strong>完成，属于前端JavaScript ⾃身的安全漏洞，⽽其他两种 XSS 都属于服务端的安全漏洞。</p><h2 id="2-如何防御-XSS-攻击？"><a href="#2-如何防御-XSS-攻击？" class="headerlink" title="2. 如何防御 XSS 攻击？"></a>2. 如何防御 XSS 攻击？</h2><p>可以看到<code>XSS</code>危害如此之大， 那么在开发网站时就要做好防御措施，具体措施如下：</p><ol><li>可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服务器端拼接后返回（不使用服务端渲染）。另一种是对需要插入到 HTML 中的代码做好充分的<strong>转义</strong>。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。</li><li>使用 <code>**CSP**</code> ，CSP 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。</li></ol><ul><li>CSP 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要<strong>配置规则</strong>，如何拦截由浏览器自己来实现。</li><li>通常有两种方式来开启 <code>CSP</code>，一种是设置 HTTP 首部中的 <code>Content-Security-Policy</code>，一种是设置 <code>meta</code> 标签的方式</li></ul><ol start="3"><li>对一些敏感信息进行保护，比如 <code>cookie</code> 使用 <code>http-only</code>，使得脚本无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。</li></ol><h2 id="3-什么是-CSRF-攻击？"><a href="#3-什么是-CSRF-攻击？" class="headerlink" title="3. 什么是 CSRF 攻击？"></a>3. 什么是 CSRF 攻击？</h2><blockquote><p>概念</p></blockquote><p>CSRF 攻击指的是<strong>跨站请求伪造攻击</strong>，攻击者利用受害者在登录状态下访问恶意网站，通过构造一个伪装成受害者已经授权的请求来欺骗服务器执行非法操作，从而实现攻击目的。</p><p>CSRF 攻击通常需要攻击者构造特定的请求，诱使用户点击或触发。</p><blockquote><ol><li>用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；</li><li>在用户信息通过验证后，网站A产生<code>Cookie</code>信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；(比如登录银行网站)</li><li>用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；(网站 B 中含有恶意代码)</li><li>网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A(比如说隐藏的表单, 给账户转钱, 或者修改密码)</li><li>浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。</li></ol></blockquote><p>CSRF 攻击的<strong>本质是利用 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。</strong></p><blockquote><p> 攻击类型</p></blockquote><p>常见的 <code>CSRF</code> 攻击有<strong>三种</strong>：</p><ul><li><code>GET</code> 类型的 <code>CSRF</code> 攻击，比如在网站中的一个 <code>img</code> 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交。</li><li><code>POST</code> 类型的 <code>CSRF</code> 攻击，比如构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。</li><li>链接类型的 <code>CSRF </code>攻击，比如在 <code>a</code> 标签的 <code>href</code> 属性里构建一个请求，然后诱导用户去点击。</li></ul><h2 id="4-如何防御-CSRF-攻击？"><a href="#4-如何防御-CSRF-攻击？" class="headerlink" title="4. 如何防御 CSRF 攻击？"></a>4. 如何防御 CSRF 攻击？</h2><p><strong>CSRF 攻击可以使用以下方法来防护：</strong></p><ol><li><strong>进行同源检测</strong>，服务器根据 <code>http</code> 请求头中 <code>origin</code> 或者 <code>referer</code> 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 <code>origin</code> 或者 <code>referer</code> 信息都不存在的时候，直接阻止请求。这种方式的缺点是有些情况下 <code>referer</code> 可以被伪造，同时还会把搜索引擎的链接也给屏蔽了。所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。（<code>Referer</code> 字段会告诉服务器该网页是从哪个页面链接过来的）</li></ol><p>浏览器同源策略：协议、域名和端口都相同即同源；</p><p>Cookie同源策略：域名相同即同源；</p><p>在HTTP协议中，每个异步请求都会携带两个header, 用来标记来源域名：</p><ul><li><code>Origin Header</code></li><li><code>Referer Header</code></li></ul><ol start="2"><li><strong>使用 CSRF Token 进行验证</strong>，服务器向用户返回一个随机数 Token ，<strong>当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证</strong>。这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果请求经过负载平衡转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证了。这种情况可以通过改变 token 的构建方式来解决。</li></ol><p>请求中携带token </p><ul><li>对于GET请求，将token附在请求地址之后，如：<code>http://url?token=tokenValue</code></li><li>对于POST请求，要在Form表单后面加上 。</li></ul><p>服务端验证token是否正确</p><ul><li>服务端拿到客户端给的token后，先解密token, 再比对随机字符串是否一致、时间是否有效，如果字符串对比一致且在有效期内，则说明token正确。</li></ul><ol start="3"><li><strong>在设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三方使用</strong>，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title class_">Set</span>-<span class="hljs-title class_">Cookie</span>: <span class="hljs-title class_">SameSite</span> = <span class="hljs-title class_">Strict</span>;<br><span class="hljs-title class_">Set</span>-<span class="hljs-title class_">Cookie</span>: <span class="hljs-title class_">SameSite</span> = <span class="hljs-title class_">Lax</span>;<br><span class="hljs-title class_">Set</span>-<span class="hljs-title class_">Cookie</span>: <span class="hljs-title class_">SameSite</span> = <span class="hljs-title class_">None</span>; <span class="hljs-title class_">Secure</span>  <span class="hljs-comment">// 有效</span><br></code></pre></td></tr></table></figure><ul><li>Strict： 最为严格，完全禁止第三方Cookie, 跨站点时，任何情况都不发送Cookie;</li><li>Lax： 限制稍微宽松，大多数情况下时不发送第三方Cookie的，除了a链接、预加载请求和GET表单；</li><li>None： 关闭SameSite属性，但必须同时设置Secure属性</li></ul><ol start="4"><li><strong>对 Cookie 进行双重验证</strong>，服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。并且这种方法比 CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 <code>XSS</code> 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。</li></ol><blockquote><p>除了 XSS 和 CSRF , iframe 的滥用和恶意第三方库也可能引起前端安全的问题, 这里就不叙述了。</p></blockquote><h2 id="5-什么是中间人攻击？如何防范中间人攻击？"><a href="#5-什么是中间人攻击？如何防范中间人攻击？" class="headerlink" title="5. 什么是中间人攻击？如何防范中间人攻击？"></a>5. 什么是中间人攻击？如何防范中间人攻击？</h2><p>中间⼈ (Man-in-the-middle attack, MITM) 是指攻击者与通讯的两端分别创建独⽴的联系, 并交换其所收到的数据, 使通讯的两端认为他们正在通过⼀个私密的连接与对⽅直接对话, 但事实上整个会话都被攻击者完全控制。在中间⼈攻击中，<strong>攻击者可以拦截通讯双方的通话并插⼊新的内容。</strong></p><p>攻击者不仅能获得双方的通信信息，还能修改通信信息。</p><blockquote><p>攻击过程如下:</p></blockquote><ul><li>客户端发送请求到服务端，请求被中间⼈截获</li><li>服务器向客户端发送公钥</li><li>中间⼈截获公钥，保留在⾃⼰⼿上。然后⾃⼰⽣成⼀个<strong>伪造的</strong>公钥，发给客户端</li><li>客户端收到伪造的公钥后，⽣成加密hash值发给服务器</li><li>中间⼈获得加密hash值，⽤⾃⼰的私钥解密获得真秘钥,同时⽣成<strong>假的</strong>加密hash值，发给服务器</li><li>服务器⽤私钥解密获得假密钥,然后加密数据传输给客户端</li></ul><h2 id="6-网络劫持有哪几种，如何防范？"><a href="#6-网络劫持有哪几种，如何防范？" class="headerlink" title="6. 网络劫持有哪几种，如何防范？"></a>6. 网络劫持有哪几种，如何防范？</h2><p>⽹络劫持分为<strong>两种</strong>:</p><p>（1）<strong>DNS劫持</strong>: </p><p>输⼊京东被强制跳转到淘宝这就属于<code>dns</code>劫持</p><ul><li>DNS强制解析: 通过修改运营商的本地DNS记录，来引导⽤户流量到缓存服务器</li><li><code>302</code>跳转的⽅式: 通过监控⽹络出⼝的流量，分析判断哪些内容是可以进⾏劫持处理的,再对劫持的内存发起<code>302</code>跳转的回复，引导⽤户获取内容</li></ul><p>（2）<strong>HTTP劫持</strong>: </p><p>访问⾕歌但是⼀直有贪玩蓝⽉的⼴告 , 由于http明⽂传输,运营商会修改你的http响应内容(即加⼴告)</p><p><code>DNS</code>劫持由于涉嫌违法，已经被监管起来，现在很少会有<code>DNS</code>劫持，⽽<code>http</code>劫持依然⾮常盛⾏，最有效的办法就是全站<code>HTTPS</code>，将<code>HTTP</code>加密，这使得运营商⽆法获取明⽂，就⽆法劫持你的响应内容。</p>]]></content>
    
    
    <categories>
      
      <category>浏览器原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于浏览器的单进程/多进程架构</title>
    <link href="/2023/10/17/%E6%B5%8F%E8%A7%88%E5%99%A8--/"/>
    <url>/2023/10/17/%E6%B5%8F%E8%A7%88%E5%99%A8--/</url>
    
    <content type="html"><![CDATA[<p>Chrome打开一个页面需要启动多少进程？</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310171854683.png" alt="img"></p><p><strong>仅仅打开了1个页面，为什么有4个进程？</strong></p><p>在解答这个问题之前，我们需要了解一下进程与线程的概念。</p><h3 id="1-进程和线程"><a href="#1-进程和线程" class="headerlink" title="1. 进程和线程"></a>1. 进程和线程</h3><p>计算机中的并行处理就是同一时刻处理多个任务, 比如我们要计算三个表达式的值，并显示出结果。</p><ul><li>正常情况下程序可以使用<strong>单线程</strong>来处理，也就是分四步按照顺序分别执行这四个任务。</li><li>但如果采用<strong>多线程</strong>，我们只需分“两步走” : 第一步，使用三个线程同时执行前三个任务；第二步，再执行第四个显示任务。</li></ul><p><strong>通过对比发现用单线程执行需要四步，而使用多线程只需要两步。因此，使用并行处理能大大提升性能。</strong></p><p>多线程可以并行处理任务，但是线程是不能单独存在的，它是由进程来启动和管理的。</p><blockquote><p>什么是进程呢?</p></blockquote><p>一个<strong>进程</strong>就是一个程序的运行实例。</p><p>详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。</p><blockquote><p>单线程与多线程的进程对比图</p></blockquote><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310171854780.png" alt="img"></p><p><strong>从图中可以看到，线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率。</strong></p><p><strong>进程和线程之间的关系有以下4个特点。</strong></p><ol><li><strong>进程中的任意一线程执行出错，都会导致整个进程的崩溃。</strong></li><li><strong>线程之间共享进程中的数据。</strong></li><li><strong>当一个进程关闭之后，操作系统会回收进程所占用的内存。</strong></li></ol><ul><li>当一个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。</li></ul><ol start="4"><li><strong>进程之间的内容相互隔离</strong></li></ol><ul><li>正是因为进程之间的数据是严格隔离的，所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进行数据的通信这时候，就需要使用用于进程间通信（IPC）的机制了。</li></ul><h3 id="2-单进程浏览器时代"><a href="#2-单进程浏览器时代" class="headerlink" title="2. 单进程浏览器时代"></a>2. 单进程浏览器时代</h3><p>单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里些模块包含了网络、插件、JavaScript运行环境、渲染引擎和页面等。<img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310171854877.png" alt="img"></p><p>如此多的功能模块运行在一个进程里，是导致单进程浏览器<strong>不稳定、不流畅和不安全</strong>的一个主要因素。</p><p><strong>不稳定</strong></p><ul><li>早期浏览器需要借助于插件来实现诸如Web视频、Web游戏等各种强大的功能，但是插件是最容易出问题的模块，并且还运行在浏览器进程之中，所以一个插件的意外崩溃会引起整个浏览器的崩溃</li><li>除了插件之外，渲染引擎模块也是不稳定的，通常一些复杂的JavaScript代码就有可能引起渲染引擎模块的崩溃。和插件一样，渲染引擎的崩溃也会导致整个浏览器的崩溃。</li></ul><p><strong>不流畅</strong></p><ul><li>单进程浏览器中所有页面的渲染模块、JavaScript执行环境以及插件都是运行在同一个线程中的，这就意味着同一时刻只能有一个模块可以执行。<strong>当有脚本发生无限循环时，</strong>它会独占整个线程，这样导致其他运行在该线程中的模块就没有机会被执行。因为浏览器中所有的页面都运行在该线程中，所以这些页面都没有机会去执行任务，这样就会导致整个浏览器失去响应，变卡顿。</li><li>除了上述脚本或者插件会让单进程浏览器变卡顿外，<strong>页面的内存泄漏</strong>也是单进程变慢的一个重要原因。通常浏览器的内核都是非常复杂的，运行一个复杂点的页面再关闭页面，会存在内存不能完全回收的情况，这样导致的问题是使用时间越长，内存占用越高，浏览器会变得越慢。</li></ul><p><strong>不安全</strong></p><ul><li>插件可以使用C&#x2F;C++等代码编写，<strong>通过插件可以获取到操作系统的任意资源，</strong>当你在页面运行一个插件时也就意味着这个插件能完全操作你的电脑。如果是个恶意插件，那么它就可以释放病毒、窃取你的账号密码，引发安全性问题。</li><li><strong>页面脚本可以通过浏览器的漏洞来获取系统权限</strong>，这些脚本获取系统权限之后也可以对你的电脑做一些恶意的事情，同样也会引发安全问题。</li></ul><blockquote><p>好在现代浏览器已经解决了这些问题，是如何解决的呢？这就得聊聊我们这个“多进程浏览器时代”了。</p></blockquote><h3 id="3-多进程浏览器时代"><a href="#3-多进程浏览器时代" class="headerlink" title="3. 多进程浏览器时代"></a>3. 多进程浏览器时代</h3><blockquote><p>多进程浏览器架构的特点</p></blockquote><p><strong>稳定</strong></p><ul><li>由于进程是相互隔离的，所以当一个页面或者插件崩溃时，影响到的仅仅是当前的页面进程或者插件进程，并不会影响到浏览器和其他页面，这就完美地解决了页面或者插件的崩溃会导致整个浏览器崩溃，也就是不稳定的问题。</li></ul><p><strong>流畅</strong></p><ul><li>JavaScript也是运行在渲染进程中的，所以即使<strong>JavaScript阻塞了渲染进程</strong>，影响到的也只是当前的渲染页面，而并不会影响浏览器和其他页面，因为其他页面的脚本是运行在它们自己的渲染进程中的。所以即使Chrome中运行上面死循环的脚本时，没有响应的仅仅也是当前的页面。</li><li>对于<strong>内存泄漏的解决方法</strong>那就更简单了，因为当关闭一个页面时，整个渲染进程也会被关闭，之后该进程所占用的内存都会被系统回收，这样就轻松解决了浏览器页面的内存泄漏问题。</li></ul><p><strong>安全</strong></p><ul><li>采用多进程架构的额外好处是可以使用安全沙箱。沙箱可以看成是操作系统给进程上了一把锁，沙箱里面的程序可以运行，但是不能在你的硬盘上写入任何数据，也不能在敏感位置读取任何数据。</li><li>例如你的文档和桌面。Chrome把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。</li></ul><blockquote><p>目前的多进程架构</p></blockquote><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310171854713.png" alt="img"></p><p>从图中可以看出，最新的Chrome浏览器包括：</p><p>1个浏览器（Browser）主进程、1个 GPU 进程、1个网络（NetWork）进程、多个渲染进程和多个插件进程。</p><blockquote><p>下面来逐个分析下这几个进程的功能：</p></blockquote><p><strong>Browser浏览器进程</strong></p><p>主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。</p><p><strong>渲染进程</strong></p><p>核心任务是将 HTML、CSS 和 JS 转换为用户可以与之交互的网页，排版引擎Blink和JS引擎V8都是运行在该进程中，默认情况下，Chrome会为每个Tab标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</p><p><strong>GPU进程</strong></p><p>Chrome刚开始发布的时候是没有GPU进程的。而GPU的使用初衷是为了实现3D CSS的效果，只是随后网页、Chrome的UI界面都选择采用GPU来绘制，这使得GPU成为浏览器普遍的需求。最后，Chrome在其多进程架构上也引入了GPU进程。</p><p><strong>NetWork网络进程</strong></p><p>主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</p><p><strong>插件进程</strong></p><p>主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。</p><p>讲到这里，现在应该就明白文章开头提到的问题了：</p><p><strong>仅仅打开了1个页面，为什么有4个进程？</strong></p><p>开1个页面至少需要1个网络进程、1个浏览器进程、1个GPU进程以及1个渲染进程，共4个；如果打开的页面有运行插件的话，还需要再加上1个插件进程。</p><h3 id="4-渲染进程中的线程"><a href="#4-渲染进程中的线程" class="headerlink" title="4. 渲染进程中的线程"></a>4. 渲染进程中的线程</h3><p>我们平时看到的浏览器呈现出页面过程中，大部分工作都是在渲染进程中完成，所以我们来看一下渲染进程中的线程。</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310171854633.png" alt="img"></p><p><strong>GUI渲染线程：</strong></p><ul><li>负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。</li><li>当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行</li><li>注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时&#x2F;执行完时立即被执行。</li></ul><p><strong>JS引擎线程：</strong></p><ul><li><p>也称为JS内核，负责处理Javascript脚本程序。如V8引擎</p></li><li><p>JS引擎线程负责解析Javascript脚本，运行代码。</p></li><li><p>JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序</p></li><li><p>同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</p></li></ul><p><strong>事件触发线程</strong></p><ul><li>归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）</li><li>当<code>js</code>代码在解析时，遇到事件比如鼠标事件时，会将这些任务添加到事件触发线程中</li><li>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理</li><li>注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）</li></ul><p><strong>定时触发器线程</strong></p><ul><li>指setInterval与setTimeout所在线程</li><li>浏览器定时计数器并不是由JavaScript引擎计数的，因为JS引擎是单线程的，所以如果处于阻塞状态，那么就会影响记计时的准确，所以需要单独的线程来负责计时器工作。</li><li>计时完毕后，添加到事件队列中，等待JS引擎空闲后执行。</li><li>注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。</li></ul><p><strong>异步http请求线程：</strong></p><ul><li>XMLHttpRequest连接后浏览器开的一个线程，比如请求有回调函数，异步线程就会将回调函数加入事件队列，等待JS引擎空闲执行</li><li>将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。</li></ul>]]></content>
    
    
    <categories>
      
      <category>浏览器原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>进程/线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你了解发布-订阅模式吗?</title>
    <link href="/2023/10/16/%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%E5%90%97/"/>
    <url>/2023/10/16/%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%E5%90%97/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是发布订阅模式"><a href="#什么是发布订阅模式" class="headerlink" title="什么是发布订阅模式"></a>什么是发布订阅模式</h3><blockquote><p>在软件架构中，发布&#x2F;订阅（Publish–subscribe pattern）是一种消息范式，消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者）。而是将发布的消息分为不同的类别，无需了解哪些订阅者（如果有的话）可能存在。同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者（如果有的话）存在。</p></blockquote><p>发布-订阅模式的发布和订阅都由统一的一个调度中心来处理，那也就是说这个模式呢是有三部分组成的</p><ul><li>发布者：将消息事件发布到调度中心</li><li>订阅者： 把自己想关注的消息事件，注册到调度中心</li><li>调度中心：处理事件注册与发布</li></ul><blockquote><p>有什么作用呢，就是在异步编程中实现更松的解耦</p></blockquote><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310162023791.png" alt="img"></p><h3 id="与观察者模式的区别❗"><a href="#与观察者模式的区别❗" class="headerlink" title="与观察者模式的区别❗"></a>与观察者模式的区别❗</h3><ul><li><p><strong>实现方式：</strong>在观察者模式中，观察者（Observer）通常会直接订阅（Subscribe）主题（Subject）的更新，而主题则会在状态改变时直接调用观察者的方法。而在发布订阅模式中，发布者（Publisher）和订阅者（Subscriber）通常不会直接交互，而是<strong>通过一个调度中心（Message broker 或 Event bus）来进行通信。</strong></p></li><li><p><strong>耦合性：</strong>观察者模式中的观察者和主题之间的耦合性相对较高，因为观察者需要直接订阅主题。而在发布订阅模式中，由于引入了调度中心，发布者和订阅者之间的耦合性较低。</p></li><li><p><strong>使用场景：</strong>观察者模式通常用于处理较为简单的一对多依赖关系，例如GUI中的事件处理等。而发布订阅模式则更适合处理复杂的异步处理和跨系统通信等场景，例如消息队列、事件驱动架构等。</p></li></ul><p><strong><code>观察者模式：直接和公司签</code></strong><br><strong><code>订阅者模式：签大厂的外包公司</code></strong></p><h3 id="JS实现发布订阅模式"><a href="#JS实现发布订阅模式" class="headerlink" title="JS实现发布订阅模式"></a>JS实现发布订阅模式</h3><blockquote><p>先列举下需要实现发布-订阅模式的思路，目的呢就是实现三个方法，添加、删除、派发</p></blockquote><p>🐾<strong>第一步：</strong> 实现发布订阅模式的第一步是创建一个可以存储事件及其对应回调函数的容器。在JavaScript中，我们可以使用一个对象来作为这个容器。每个事件都是对象的一个属性，其值是一个数组，用来存储所有订阅了该事件的回调函数。</p><p>🐾<strong>第二步</strong>： 第二步是添加一个名为subscribe的方法，该方法允许监听器订阅特定的事件。这个方法需要两个参数：一个是事件名，另一个是当事件被触发时应该调用的回调函数。</p><p>🐾<strong>第三步：</strong> 第三步是实现取消订阅的功能：添加一个名为unsubscribe的方法来实现这个功能。这个方法需要两个参数：一个是事件名，另一个是要取消订阅的回调函数。</p><p>🐾<strong>第四步：</strong> 第四步是实现事件发布的功能，我们可以添加一个名为publish的方法来实现这个功能。这个方法需要两个参数：一个是事件名，另一个是当事件被触发时应该传递给回调函数的数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PubSub</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span> = &#123;&#125;;<br>  &#125;<br><br>  <span class="hljs-title function_">subscribe</span>(<span class="hljs-params">event, callback</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event]) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event] = [];<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event].<span class="hljs-title function_">push</span>(callback);<br>  &#125;<br><br>  <span class="hljs-title function_">unsubscribe</span>(<span class="hljs-params">event, callback</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event]) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;事件无效&#x27;</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event].<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">cb</span> =&gt;</span> cb !== callback);<br>  &#125;<br><br>  <span class="hljs-title function_">publish</span>(<span class="hljs-params">event, data</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event]) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;该事件未注册&#x27;</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event].<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">callback</span> =&gt;</span> <span class="hljs-title function_">callback</span>(...data));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>🐾使用示例： 至此我们已经完成了一个基本的发布订阅模式，下面展示一下它的具体使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建一个新的PubSub实例</span><br><span class="hljs-keyword">const</span> pubsub = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PubSub</span>();<br><br><span class="hljs-comment">// 定义两个回调函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">callback1</span>(<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;这里是第一个回调: &#x27;</span> + data);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">callback2</span>(<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;这里是第二个回调: &#x27;</span> + data);<br>&#125;<br><br><span class="hljs-comment">// 订阅一个事件</span><br>pubsub.<span class="hljs-title function_">subscribe</span>(<span class="hljs-string">&#x27;myEvent&#x27;</span>, callback1);<br>pubsub.<span class="hljs-title function_">subscribe</span>(<span class="hljs-string">&#x27;myEvent&#x27;</span>, callback2);<br><br><span class="hljs-comment">// 输出两个回调函数的 console</span><br>pubsub.<span class="hljs-title function_">publish</span>(<span class="hljs-string">&#x27;myEvent&#x27;</span>, <span class="hljs-string">&#x27;Hello, world!&#x27;</span>); <br><br><span class="hljs-comment">// 取消订阅 callback1</span><br>pubsub.<span class="hljs-title function_">unsubscribe</span>(<span class="hljs-string">&#x27;myEvent&#x27;</span>, callback1);<br><br><span class="hljs-comment">// callback1 的订阅被取消了，仅打印 callback2 的 console</span><br>pubsub.<span class="hljs-title function_">publish</span>(<span class="hljs-string">&#x27;myEvent&#x27;</span>, <span class="hljs-string">&#x27;Hello, world!&#x27;</span>); <br></code></pre></td></tr></table></figure><h3 id="错误处理与功能优化"><a href="#错误处理与功能优化" class="headerlink" title="错误处理与功能优化"></a>错误处理与功能优化</h3><p>首先是类型判断与错误处理，我们应当检查参数的类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PubSub</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span> = &#123;&#125;;<br>  &#125;<br><br>  <span class="hljs-title function_">subscribe</span>(<span class="hljs-params">event, callback</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> event !== <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Event name must be a string&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Callback must be a function&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event]) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event] = [];<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event].<span class="hljs-title function_">push</span>(callback);<br>  &#125;<br><br>  <span class="hljs-title function_">unsubscribe</span>(<span class="hljs-params">event, callback</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> event !== <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Event name must be a string&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Callback must be a function&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event]) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event].<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">cb</span> =&gt;</span> cb !== callback);<br>  &#125;<br><br>  <span class="hljs-title function_">publish</span>(<span class="hljs-params">event, data</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> event !== <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Event name must be a string&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event]) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event].<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">callback</span> =&gt;</span> <span class="hljs-title function_">callback</span>(data));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>开发中我们会遇到一些一次性事件，不会被触发第二次了，我们可以加一个参数来省去手动清除事件的负担：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">publish</span>(<span class="hljs-params">event, data, once = <span class="hljs-literal">false</span></span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> event !== <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Event name must be a string&#x27;</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event]) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event].<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">callback</span> =&gt;</span> <span class="hljs-title function_">callback</span>(data));<br>  <span class="hljs-keyword">if</span>(once) <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event];<br>&#125;<br></code></pre></td></tr></table></figure><p>如果一个回调函数在被调用时订阅了相同的事件，可能会导致<strong>无限循环</strong>。这是因为<code>publish</code>方法会立即调用所有的回调函数，而这些回调函数可能会改变监听器列表。<br>上面的代码并没有考虑这个问题，但测试后发现并不会发生无限循环的情况，这是什么原因呢？问题出在 for 和 forEach 中，<strong>forEach 方法在开始循环时就已经确定了循环的次数，所以，即使在回调函数中添加或删除了元素，也不会影响forEach的循环次数；</strong>而 <strong>for 循环会实时检查</strong>数组的长度，故而会出现上述的情况。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>强制缓存和协商缓存?</title>
    <link href="/2023/10/07/%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98%E5%92%8C%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98/"/>
    <url>/2023/10/07/%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98%E5%92%8C%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<blockquote><p>原文 <a href="https://juejin.cn/post/7127194919235485733?searchId=2023100709440962FECF52597D2C3CBEA0#heading-4">中高级前端工程师都需要熟悉的技能–前端缓存 - 掘金</a></p></blockquote><p>HTTP 缓存可以分为协商缓存和强制缓存两种类型。</p><blockquote><p>强缓存</p></blockquote><p>强制缓存是指浏览器在请求资源时，不会发送任何请求头，直接从本地缓存中读取资源，从⽽提⾼响应速度,  只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。</p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310171848158.png" alt="img" style="zoom:50%;" /><blockquote><p>协商缓存</p></blockquote><ul><li>协商缓存是指浏览器在请求资源时，会发送⼀些请求头到服务器，询问服务器资源是否已经发⽣改变。如果资源未发⽣改变，服务器将返回 304 状态码，告诉浏览器可以从缓存中读取资源，从⽽减少了⽹络带宽的使⽤。强制缓存失效之后，浏览器在请求头中携带相应的缓存字段来向服务器发请求，由服务器根据这个字段，来决定是否使用缓存，这就是协商缓存。</li></ul><h3 id="1-基于-Expires-字段实现的强缓存"><a href="#1-基于-Expires-字段实现的强缓存" class="headerlink" title="1. 基于 Expires 字段实现的强缓存"></a>1. 基于 Expires 字段实现的强缓存</h3><p>使用响应头的<code>Expires</code>字段去实现强缓存</p><p><code>Expires</code> 头部：指定资源过期的时间，如果在过期时间之前再次请求该资源，浏览器将直接从缓存中读取资源。</p><p>比如说将某一资源设置响应头为:<code>Expires:new Date(&quot;2022-7-30 23:59:59&quot;)</code>；</p><p>那么，该资源在2022-7-30 23:59:59 之前，都会去本地的磁盘（或内存）中读取，不会去服务器请求。</p><blockquote><p>Expires判断强缓存是否过期的机制是: 获取本地时间戳，并对先前拿到的资源文件中的Expires字段的时间做比较, 但是Expires<strong>过度依赖本地时间</strong>，如果本地与服务器时间不同步，就会出现资源无法被缓存或者资源永远被缓存的情况。</p></blockquote><h3 id="2-基于-Cache-control-实现的强缓存"><a href="#2-基于-Cache-control-实现的强缓存" class="headerlink" title="2. 基于 Cache-control 实现的强缓存"></a>2. 基于 Cache-control 实现的强缓存</h3><p><code>Cache-Control</code> 头部：可以指定资源的缓存策略，包括 max-age,  public、private、no-cache 等，控制浏览器的缓存⾏为。</p><p>通过在资源的响应头中设置 <code>Cache-Control:max-age=N</code>，N就是需要缓存的秒数。</p><p>那么,  从第一次请求资源的时候开始，往后N秒内，资源若再次请求，则直接从磁盘（或内存中读取），不与服务器做任何交互。</p><blockquote><p>Cache-control中因为max-age后面的值是一个滑动时间，从服务器第一次返回该资源时开始倒计时。所以也就不需要比对客户端和服务端的时间，解决了Expires所存在的巨大漏洞。</p></blockquote><h3 id="3-基于-lasted-modified-实现的协商缓存"><a href="#3-基于-lasted-modified-实现的协商缓存" class="headerlink" title="3. 基于 lasted-modified 实现的协商缓存"></a>3. 基于 lasted-modified 实现的协商缓存</h3><ol><li>浏览器在第一次请求资源时，在服务器端读出文件修改时间，将读出来的修改时间赋给响应头的<code>last-modified</code>字段。然后设置<code>Cache-control:no-cache(跳过强缓存校验，直接进行协商缓存)</code>. </li><li>当客户端读取到<code>last-modified</code>的时候，会在下次的请求标头中携带一个字段<code>If-Modified-Since(这个请求头中的If-Modified-Since就是上一次请求设置在响应头中的 last-modified)</code>。  </li><li>当再次请求资源时, 服务端需要拿到请求头中的 <code>If-Modified-Since</code> 这个时间并再次读取该资源的修改时间, 让他们两个做一个比对来决定是读取缓存还是返回新的资源。如果没有发生变化，返回 304 状态码并读取缓存，否则返回新的资源并将资源修改时间赋值给响应头的<code>last-modified</code> 字段。</li></ol><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310071059690.png" alt="img"></p><p>使用以上方式的协商缓存存在两个非常明显的漏洞。这两个漏洞都是基于文件是通过比较修改时间来判断是否更改而产生的。</p><ol><li>因为是更具文件修改时间来判断的，所以，在文件内容本身不修改的情况下，依然有可能更新文件修改时间（比如修改文件名再改回来），这样，就有可能文件内容明明没有修改，但是缓存依然失效了。</li><li>当文件在极短时间内完成修改的时候（比如几百毫秒）。因为文件修改时间记录的最小单位是秒，所以，如果文件在几百毫秒内完成修改的话，文件修改时间不会改变，这样，即使文件内容修改了，依然不会返回新的文件。</li></ol><blockquote><p>为了解决上述的这两个问题。从http1.1开始新增了一个头信息，ETag(Entity 实体标签)</p></blockquote><h3 id="4-基于-ETag-实现的协商缓存"><a href="#4-基于-ETag-实现的协商缓存" class="headerlink" title="4. 基于 ETag 实现的协商缓存"></a>4. 基于 ETag 实现的协商缓存</h3><ol><li>第一次请求某资源的时候，服务端读取文件并计算出文件指纹，将文件指纹放在响应头的<code>etag</code>字段中跟资源一起返回给客户端。</li><li>第二次请求某资源的时候，客户端自动从缓存中读取出上一次服务端返回的<code>ETag</code>也就是文件指纹。并赋给请求头的<code>if-None-Match</code>字段，让上一次的文件指纹跟随请求一起回到服务端。</li><li>服务端拿到请求头中的<code>if-None-Match</code>字段值（也就是上一次的文件指纹），并再次读取目标资源并生成文件指纹，两个指纹做对比。如果两个文件指纹完全吻合，说明文件没有被改变，则直接返回304状态码和一个空的响应体并<code>return</code>(这个时候已经读取了缓存)。如果两个文件指纹不吻合，则说明文件被更改，那么返回新的资源并将新的文件指纹重新存储到响应头的<code>ETag</code>字段</li></ol><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202310071059655.png" alt="img"></p><blockquote><p> ETag 的缺点</p></blockquote><ol><li>ETag需要计算文件指纹这样意味着，服务端需要更多的计算开销。。如果文件尺寸大，数量多，并且计算频繁，那么ETag的计算就会影响服务器的性能。显然，ETag在这样的场景下就不是很适合。</li><li>ETag有强验证和弱验证，所谓将强验证，ETag生成的哈希码深入到每个字节。哪怕文件中只有一个字节改变了，也会生成不同的哈希值，它可以保证文件内容绝对的不变。但是，强验证非常消耗计算量。ETag还有一个弱验证，弱验证是提取文件的部分属性来生成哈希值。因为不必精确到每个字节，所以他的整体速度会比强验证快，但是准确率不高。会降低协商缓存的有效性。</li></ol><h3 id="5-缓存位置"><a href="#5-缓存位置" class="headerlink" title="5. 缓存位置"></a>5. 缓存位置</h3><p>当强缓存命中或者<code>协商缓存</code>中服务器返回304的时候，我们直接从缓存中获取资源。那这些资源究竟缓存在什么位置呢？</p><p>浏览器中的缓存位置一共有四种，按优先级从高到低排列分别是：</p><ul><li>Service Worker</li><li>Memory Cache</li><li>Disk Cache</li><li>Push Cache</li></ul><blockquote><p>Service Worker</p></blockquote><p>Service Worker 借鉴了 Web Worker的 思路，即让 JS 运行在主线程之外，由于它脱离了浏览器的窗体，因此无法直接访问DOM。虽然如此，但它仍然能帮助我们完成很多有用的功能，比如离线缓存、消息推送和网络代理等功能。其中的离线缓存就是 <strong>Service Worker Cache</strong>。</p><blockquote><p> Memory Cache 和 Disk Cache</p></blockquote><p><strong>Memory Cache</strong>指的是内存缓存，从效率上讲它是最快的。但是从存活时间来讲又是最短的，当渲染进程结束后，内存缓存也就不存在了。</p><p><strong>Disk Cache</strong>就是存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，但是他的优势在于存储容量和存储时长。稍微有些计算机基础的应该很好理解，就不展开了。</p><p>好，现在问题来了，既然两者各有优劣，那浏览器如何决定将资源放进内存还是硬盘呢？主要策略如下：</p><ul><li>比较大的JS、CSS文件会直接被丢进磁盘，反之丢进内存</li><li>内存使用率比较高的时候，文件优先进入磁盘</li></ul><blockquote><p>Push Cache</p></blockquote><p>即推送缓存，这是浏览器缓存的最后一道防线。它是 HTTP&#x2F;2 中的内容，虽然现在应用的并不广泛，但随着 HTTP&#x2F;2 的推广，它的应用越来越广泛。</p><h3 id="6-总结一下"><a href="#6-总结一下" class="headerlink" title="6. 总结一下"></a>6. 总结一下</h3><ul><li>需要注意的是，协商缓存虽然可以减少⽹络带宽的使⽤，但是需要服务器进⾏资源⽐较，会增加服务器的负载</li><li>关于强缓存，cache-control是Expires的完全替代方案，在可以使用cache-control的情况下不要使用expires</li><li>关于协商缓存,etag并不是last-modified的完全替代方案，而是补充方案，具体用哪一个，取决于业务场景。</li><li>有哈希值的文件设置强缓存即可。没有哈希值的文件（比如index.html）设置协商缓存</li><li>有些缓存是从磁盘读取，有些缓存是从内存读取，有什么区别？答：从内存读取的缓存更快。</li><li>所有带304的资源都是协商缓存，所有标注（从内存中读取&#x2F;从磁盘中读取）的资源都是强缓存。</li></ul>]]></content>
    
    
    <categories>
      
      <category>浏览器原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kmp算法(JS版)</title>
    <link href="/2023/09/30/kmp%E7%AE%97%E6%B3%95(JS%E7%89%88)/"/>
    <url>/2023/09/30/kmp%E7%AE%97%E6%B3%95(JS%E7%89%88)/</url>
    
    <content type="html"><![CDATA[<h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><p>KMP是一种高效的字符串匹配算法，用来在主字符串中查找模式字符串的位置</p><blockquote><p>比如在“hello,world”主串中查找“world”模式串的位置)。</p></blockquote><h5 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h5><blockquote><p>在失配时,  将模板字符串失配字符的下标退回到前面相应位置 ，这样就可以跳过大多数的失配步骤。而每次p串移动的步数就是通过查找next[ ]数组确定的。比如 : </p><p>父亲字符串 :  aabaabaaf</p><p>模板字符串 :  aabaaf</p><p>当模板字符串的<code>f</code>不匹配父字符串的<code>b</code> 时, 模板字符串中字符<code>f</code> 对应的下标<code>j</code>就会退回到包括前5个字符组成的子串的最长相同前后缀的长度, 也就是2, 于是退回到下标为2的位置, 从模板字符串的<code>b</code>字符继续开始和父字符串进行匹配, 至始至终父字符串的匹配下标都未移动哦~</p></blockquote><p><code>KMP</code> 主要分两步：</p><ol><li>求next数组</li><li>匹配字符串</li></ol><h5 id="举例-详解"><a href="#举例-详解" class="headerlink" title="举例 + 详解"></a>举例 + 详解</h5><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309300214173.png" alt="image-20230930021353085"></p><blockquote><p>详解 : 都在注释中了</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> readline = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;readline&quot;</span>);<br><span class="hljs-keyword">const</span> rl = readline.<span class="hljs-title function_">createInterface</span>(&#123;<br>  <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span>,<br>  <span class="hljs-attr">output</span>: process.<span class="hljs-property">stdout</span>,<br>&#125;);<br><span class="hljs-keyword">const</span> num = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">const</span> rows = [];<br>rl.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;line&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)&#123;<br>  rows.<span class="hljs-title function_">push</span>(data);<br>  <span class="hljs-keyword">if</span> (rows.<span class="hljs-property">length</span> == num) &#123;<br>    <span class="hljs-keyword">const</span> res = [];<br>    <span class="hljs-keyword">const</span> n = <span class="hljs-title class_">Number</span>(rows[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">const</span> m = <span class="hljs-title class_">Number</span>(rows[<span class="hljs-number">2</span>]);<br>    <span class="hljs-keyword">const</span> p = rows[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">const</span> s = rows[<span class="hljs-number">3</span>];<br>    <span class="hljs-comment">// 初始化next数组为0, 单个数字是没有前后缀的, 也没有长度</span><br>    <span class="hljs-keyword">const</span> next = [<span class="hljs-number">0</span>]<br>    <span class="hljs-comment">// 求next数组 : next[i]就是包括i之前这个子串最长相等前后缀的长度</span><br>    <span class="hljs-comment">// j代表前缀的末尾位置, 前缀从下标0开始, i代表后缀的末尾位置, 后缀是从下标1开始, 因为单个数字是没有前后缀的</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br> <span class="hljs-comment">// 关于 j &gt; 0 : 因为下标为0时j无法回退到前一个数字的next值, 也就是数组下标-1也有问题, 所以要进行判定</span><br> <span class="hljs-comment">// 关于 while : 因为j的回退也是需要持续进行的, 直到前后缀一致或者j回退到下标为0的位置, 这个地方也是易错点</span><br> <span class="hljs-comment">// 关于 j = next[j - 1] : 当不匹配时, j要回退到前一个数字的next值的位置, 也就是包括i在内的字符串的最长相同前后缀的长度</span><br>      <span class="hljs-keyword">while</span>(j &amp;&amp; p[i] != p[j]) j = next[j - <span class="hljs-number">1</span>];<br>      <span class="hljs-comment">// 当匹配时, j++, 因为j不仅代表前缀末尾的位置, 也代表着包括i之前这个子串的最长相等前后缀的长度, 此时匹配了肯定要加一</span><br>      <span class="hljs-keyword">if</span>(p[i] === p[j])j++; <br>      <span class="hljs-comment">// 因为j代表着包括i之前这个子串的最长相等前后缀的长度, 也就是我们要求的next[i]的值, 最后赋值即可</span><br>      next[i] = j;<br>    &#125;<br>    <span class="hljs-comment">// 进行匹配</span><br>    <span class="hljs-comment">// 都从第一个数开始匹配, 所以下标都从0开始, i为父字符串下标, j为模板字符串下标</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>  <span class="hljs-comment">// 当j为0时, 无需回退且数组也会越界</span><br>  <span class="hljs-comment">// while的作用: 由于移动后可能仍然失配, 所以目的是要保持匹配</span><br>  <span class="hljs-comment">// 当不匹配时, j回退到前一个数字的next值的位置, 继续下一步匹配, 注意这时候i是不变的, 也就是说i一直向后, 只有j是不断回退</span><br>      <span class="hljs-keyword">while</span> (j &amp;&amp; s[i] != p[j]) j = next[j - <span class="hljs-number">1</span>]; <br>      <span class="hljs-comment">// 当匹配成功时, j++</span><br>      <span class="hljs-keyword">if</span> (s[i] == p[j]) j++;<br>      <span class="hljs-comment">// 如果模板字符串已全匹配完, 则匹配完成</span><br>      <span class="hljs-keyword">if</span> (j == n) &#123;<br>        res.<span class="hljs-title function_">push</span>(i - n + <span class="hljs-number">1</span>);<br>        j = next[j - <span class="hljs-number">1</span>];<br>      &#125;<br>      <span class="hljs-comment">// 如果未匹配完成, 则i++, 继续下一个字符的匹配</span><br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27; &#x27;</span>));<br>    rl.<span class="hljs-title function_">close</span>();<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><blockquote><p>over</p></blockquote><blockquote><p>例子2  + 无注释版</p></blockquote><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309301301231.png" alt="image-20230930130110140"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">haystack</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">needle</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> strStr = <span class="hljs-keyword">function</span>(<span class="hljs-params">haystack, needle</span>) &#123;<br>    <span class="hljs-keyword">let</span> next = [<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>, i = <span class="hljs-number">1</span>; i &lt; needle.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">while</span>(j &amp;&amp; needle[i] != needle[j]) j = next[j - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span>(needle[i] === needle[j]) j++;<br>        next[i] = j;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; haystack.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">while</span>(j &amp;&amp; needle[j] !== haystack[i]) j = next[j - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span>(needle[j] === haystack[i]) j++;<br>        <span class="hljs-keyword">if</span>(j === needle.<span class="hljs-property">length</span>) &#123;<br>            <span class="hljs-keyword">return</span> i - j + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串匹配</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手写Promise!!</title>
    <link href="/2023/09/18/%E6%89%8B%E5%86%99Promise/"/>
    <url>/2023/09/18/%E6%89%8B%E5%86%99Promise/</url>
    
    <content type="html"><![CDATA[<blockquote><p>原文 : <a href="https://juejin.cn/post/7269640045043777576">https://juejin.cn/post/7269640045043777576</a></p></blockquote><p>首先，<code>Promise</code>肯定是一个类，所以我们才可以<code>new</code>它，然后<code>Promise实例化</code>的时候给它传入一个回调我们叫它<code>executor</code>方法，Promise 内部会<code>立即调用</code>这个<code>executor方法</code>，并且会传入<code>resolve</code>和<code>reject</code>两个函数作为调用参数，另外在 Promise 类的原型上应该提供一个<code>then</code>方法，它里面可以传入两个回调，分别为<code>Promise成功的回调</code>和<code>Promise失败的回调</code>。调用<code>resolve</code>后会走入<code>成功的回调中</code>，调用<code>reject</code>后会走入<code>失败的回调中</code>。</p><h2 id="初级版本-Promise"><a href="#初级版本-Promise" class="headerlink" title="初级版本 Promise"></a>初级版本 Promise</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PENDING</span> = <span class="hljs-string">&quot;PENDING&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">FULFILLED</span> = <span class="hljs-string">&quot;FULFILLED&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">REJECTED</span> = <span class="hljs-string">&quot;REJECTED&quot;</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Promise</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-literal">undefined</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = <span class="hljs-literal">undefined</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PENDING</span>;<br>    <span class="hljs-comment">// 定义两个数组解决异步调用resolve或者reject的问题</span><br>    <span class="hljs-comment">// 充当队列把then里边的回调存起来</span><br>    <span class="hljs-comment">// 有的时候，我们会给同一个promise实例执行多次then方法, 那么相应的onFulfilled和onRejected回调必须按照其发起调用的顺序执行。</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onResolvedCallbacks</span> = [];<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span> = [];<br><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">resolve</span> = (<span class="hljs-params">value</span>) =&gt; &#123;<br>      <span class="hljs-comment">// 当状态为pending状态的时候才可以去改变状态，并且分别将value和reason赋值给对应值，并去执行相应回调函数</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">FULFILLED</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onResolvedCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> <span class="hljs-title function_">fn</span>());<br>      &#125;<br>    &#125;;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">reject</span> = (<span class="hljs-params">reason</span>) =&gt; &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = reason;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">REJECTED</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> <span class="hljs-title function_">fn</span>());<br>      &#125;<br>    &#125;;<br>      <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-title function_">executor</span>(resolve,reject)<br>      &#125; <span class="hljs-keyword">catch</span>(err) &#123;<br>        <span class="hljs-title function_">reject</span>(err); <span class="hljs-comment">//有报错会直接执行reject函数将状态变为失败rejected</span><br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-title function_">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>) &#123;<br>    <span class="hljs-comment">//当执行到then的时候，状态已经是fulfilled状态或者是rejected状态，那么就直接执行回调，并且将value/reason作为第一个参数</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">FULFILLED</span>) &#123;<br>      onFulfilled &amp;&amp; <span class="hljs-title function_">onFulfilled</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">REJECTED</span>) &#123;<br>      onRejected &amp;&amp; <span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>);<br>    &#125;<br>     <span class="hljs-comment">//当执行到then的时候，状态还是pending状态，那么需要将回调存起来，等到状态改变的时候再去执行</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">onResolvedCallbacks</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">onFulfilled</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>      &#125;);<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>);<br>      &#125;);<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">Promise</span>;<br></code></pre></td></tr></table></figure><h2 id="链式调用-Promise"><a href="#链式调用-Promise" class="headerlink" title="链式调用 Promise"></a>链式调用 Promise</h2><blockquote><p>内部调用 then 方法时，返回了一个新的 promise，并让这个新的 promise 接管了它下一个 then 方法。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PENDING</span> = <span class="hljs-string">&quot;PENDING&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">FULFILLED</span> = <span class="hljs-string">&quot;FULFILLED&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">REJECTED</span> = <span class="hljs-string">&quot;REJECTED&quot;</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Promise</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-literal">undefined</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = <span class="hljs-literal">undefined</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PENDING</span>;<br>    <span class="hljs-comment">// 定义两个数组解决异步调用resovle或者reject的问题</span><br>    <span class="hljs-comment">// 充当队列把then里边的回调存起来</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onResolvedCallbacks</span> = [];<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span> = [];<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">resolve</span> = (<span class="hljs-params">value</span>) =&gt; &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">FULFILLED</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onResolvedCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> <span class="hljs-title function_">fn</span>());<br>      &#125;<br>    &#125;;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">reject</span> = (<span class="hljs-params">reason</span>) =&gt; &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = reason;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">REJECTED</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> <span class="hljs-title function_">fn</span>());<br>      &#125;<br>    &#125;;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-title function_">executor</span>(resolve, reject);<br>    &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>      <span class="hljs-title function_">reject</span>(err); <span class="hljs-comment">//有报错会直接执行reject函数将状态变为失败rejected</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-title function_">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>) &#123;<br>    <span class="hljs-keyword">const</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">FULFILLED</span>) &#123;<br>        <span class="hljs-comment">// onFulfilled方法可能返回值或者promise</span><br>        <span class="hljs-keyword">const</span> x = <span class="hljs-title function_">onFulfilled</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>        <span class="hljs-title function_">resolvePromise</span>(promise2, x, resolve, reject);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">REJECTED</span>) &#123;<br>        <span class="hljs-comment">// onRejected方法可能返回值或者promise</span><br>        <span class="hljs-keyword">const</span> x = <span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>);<br>        <span class="hljs-title function_">resolvePromise</span>(promise2, x, resolve, reject);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onResolvedCallbacks</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-keyword">const</span> x = <span class="hljs-title function_">onFulfilled</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>          <span class="hljs-title function_">resolvePromise</span>(promise2, x, resolve, reject);<br>        &#125;);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-keyword">const</span> x = <span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>);<br>          <span class="hljs-title function_">resolvePromise</span>(promise2, x, resolve, reject);<br>        &#125;);<br>      &#125;<br>    &#125;);<br>    <span class="hljs-keyword">return</span> promise2;<br>  &#125;<br>&#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">Promise</span>;<br></code></pre></td></tr></table></figure><blockquote><p>这里最主要的就是<code>resolvePromise</code>，来看下它做了什么：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">resolvePromise</span>(<span class="hljs-params">promise2, x, resolve, reject</span>) &#123;<br>  <span class="hljs-keyword">if</span> (promise2 === x) &#123;<br>    <span class="hljs-comment">// 防止循环引用</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">reject</span>(<br>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<br>        <span class="hljs-string">&quot;UnhandledPromiseRejectionWarning: TypeError: Chaining cycle detected for promise #&lt;Promise&gt;&quot;</span><br>      )<br>    );<br>  &#125;<br>  <span class="hljs-keyword">let</span> called; <span class="hljs-comment">// 声明变量called，相当于加了一把锁，让promise只能调用一次成功或者失败回调，防止死循环。</span><br>  <span class="hljs-comment">// 判断x的类型 x是对象或函数才有可能是一个promise</span><br>  <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&quot;object&quot;</span> &amp;&amp; x !== <span class="hljs-literal">null</span>) || <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">const</span> then = x.<span class="hljs-property">then</span>;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>        <span class="hljs-comment">// 只能认为它是一个promise</span><br>        then.<span class="hljs-title function_">call</span>(<br>          x,<br>          <span class="hljs-function">(<span class="hljs-params">y</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span>;<br>            called = <span class="hljs-literal">true</span>;<br>            <span class="hljs-title function_">resolvePromise</span>(promise2, y, resolve, reject); <span class="hljs-comment">// 精髓, 递归解析</span><br>          &#125;,<br>          <span class="hljs-function">(<span class="hljs-params">r</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span>;<br>            called = <span class="hljs-literal">true</span>;<br>            <span class="hljs-title function_">reject</span>(r);<br>          &#125;<br>        );<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(x);<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>      <span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span>;<br>      called = <span class="hljs-literal">true</span>;<br>      <span class="hljs-title function_">reject</span>(e);<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(x);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>因为<code>promise</code>在<code>EventLoop</code>里面是个微任务，不过我们可以简单通过<code>setTimout</code>模拟。</p><p>然后我们再加上一些报错的捕获代码以及一些参数的兼容代码，以及实现<code>catch</code>方法。</p></blockquote><h2 id="完全版本-Promise"><a href="#完全版本-Promise" class="headerlink" title="完全版本 Promise"></a>完全版本 Promise</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PENDING</span> = <span class="hljs-string">&quot;PENDING&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">FULFILLED</span> = <span class="hljs-string">&quot;FULFILLED&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">REJECTED</span> = <span class="hljs-string">&quot;REJECTED&quot;</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Promise</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-literal">undefined</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = <span class="hljs-literal">undefined</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PENDING</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onResolvedCallbacks</span> = [];<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span> = [];<br><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">resolve</span> = (<span class="hljs-params">value</span>) =&gt; &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">FULFILLED</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onResolvedCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> <span class="hljs-title function_">fn</span>());<br>      &#125;<br>    &#125;;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">reject</span> = (<span class="hljs-params">reason</span>) =&gt; &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = reason;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">REJECTED</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> <span class="hljs-title function_">fn</span>());<br>      &#125;<br>    &#125;;<br><br>    <span class="hljs-comment">// executor执行时增加try catch，防止执行用户传入的函数直接就报错了，这时我们应该直接reject promise。</span><br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-title function_">executor</span>(resolve, reject);<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>      <span class="hljs-title function_">reject</span>(e);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-title function_">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>) &#123;<br>    <span class="hljs-comment">// 这里兼容下 onFulfilled 和 onRejected 的传参</span><br>    onFulfilled = <span class="hljs-keyword">typeof</span> onFulfilled === <span class="hljs-string">&quot;function&quot;</span> ? onFulfilled : <span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> v;<br>    onRejected =<br>      <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">&quot;function&quot;</span><br>        ? onRejected<br>        : <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">throw</span> err;<br>          &#125;;<br>    <span class="hljs-comment">// 调用onFulfilled和onRejected时，需要包裹setTimeout</span><br>    <span class="hljs-keyword">const</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">FULFILLED</span>) &#123;<br>        <span class="hljs-comment">// 用 setTimeout 模拟异步</span><br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">const</span> x = <span class="hljs-title function_">onFulfilled</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>            <span class="hljs-title function_">resolvePromise</span>(promise2, x, resolve, reject);<br>          &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>            <span class="hljs-title function_">reject</span>(e);<br>          &#125;<br>        &#125;, <span class="hljs-number">0</span>);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">REJECTED</span>) &#123;<br>        <span class="hljs-comment">// 用 setTimeout 模拟异步</span><br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">const</span> x = <span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>);<br>            <span class="hljs-title function_">resolvePromise</span>(promise2, x, resolve, reject);<br>          &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>            <span class="hljs-title function_">reject</span>(e);<br>          &#125;<br>        &#125;, <span class="hljs-number">0</span>);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onResolvedCallbacks</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-comment">// 用 setTimeout 模拟异步</span><br>          <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>              <span class="hljs-keyword">const</span> x = <span class="hljs-title function_">onFulfilled</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>              <span class="hljs-title function_">resolvePromise</span>(promise2, x, resolve, reject);<br>            &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>              <span class="hljs-title function_">reject</span>(e);<br>            &#125;<br>          &#125;, <span class="hljs-number">0</span>);<br>        &#125;);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-comment">// 用 setTimeout 模拟异步</span><br>          <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>              <span class="hljs-keyword">const</span> x = <span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>);<br>              <span class="hljs-title function_">resolvePromise</span>(promise2, x, resolve, reject);<br>            &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>              <span class="hljs-title function_">reject</span>(e);<br>            &#125;<br>          &#125;, <span class="hljs-number">0</span>);<br>        &#125;);<br>      &#125;<br>    &#125;);<br><br>    <span class="hljs-keyword">return</span> promise2;<br>  &#125;<br>  <span class="hljs-comment">// catch函数实际上里面就是调用了then方法</span><br>  <span class="hljs-keyword">catch</span>(errCallback) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-literal">null</span>, errCallback);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 解决链式调用</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">resolvePromise</span>(<span class="hljs-params">promise2, x, resolve, reject</span>) &#123;<br>  <span class="hljs-keyword">if</span> (promise2 === x) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">reject</span>(<br>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<br>        <span class="hljs-string">&quot;UnhandledPromiseRejectionWarning: TypeError: Chaining cycle detected for promise #&lt;Promise&gt;&quot;</span><br>      )<br>    );<br>  &#125;<br>  <span class="hljs-keyword">let</span> called;<br>  <span class="hljs-comment">// 判断x的类型 x是对象或函数才有可能是一个promise</span><br>  <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&quot;object&quot;</span> &amp;&amp; x !== <span class="hljs-literal">null</span>) || <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">const</span> then = x.<span class="hljs-property">then</span>;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>        <span class="hljs-comment">// 只能认为它是一个promise</span><br>        then.<span class="hljs-title function_">call</span>(<br>          x,<br>          <span class="hljs-function">(<span class="hljs-params">y</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span>;<br>            called = <span class="hljs-literal">true</span>;<br>            <span class="hljs-title function_">resolvePromise</span>(promise2, y, resolve, reject);<br>          &#125;,<br>          <span class="hljs-function">(<span class="hljs-params">r</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span>;<br>            called = <span class="hljs-literal">true</span>;<br>            <span class="hljs-title function_">reject</span>(r);<br>          &#125;<br>        );<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(x);<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>      <span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span>;<br>      called = <span class="hljs-literal">true</span>;<br>      <span class="hljs-title function_">reject</span>(e);<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(x);<br>  &#125;<br>&#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">Promise</span>;<br></code></pre></td></tr></table></figure><h2 id="测试-promise-是否符合规范"><a href="#测试-promise-是否符合规范" class="headerlink" title="测试 promise 是否符合规范"></a>测试 promise 是否符合规范</h2><ol><li><p>首先安装依赖包 <code>npm i promises-aplus-tests -D</code></p></li><li><p>在我们的代码中添加</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">defer</span> = <span class="hljs-title class_">Promise</span>.<span class="hljs-property">deferred</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">let</span> dfd = &#123;&#125;;<br>  dfd.<span class="hljs-property">promise</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>      dfd.<span class="hljs-property">resolve</span> = resolve;<br>      dfd.<span class="hljs-property">reject</span> = reject;<br>  &#125;);<br>  <span class="hljs-keyword">return</span> dfd;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意别忘了 <code>module.exports = Promise;</code></p></blockquote></li><li><p>运行 <code>promises-aplus-tests 文件名</code> 即可</p></li><li><p>有 872 个测试用例，全部通过即可以认为这是一个标准的 promise。</p></li></ol><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309181510458.png" alt="image-20230918151029374"></p><h2 id="实现Promise的各种方法"><a href="#实现Promise的各种方法" class="headerlink" title="实现Promise的各种方法"></a>实现Promise的各种方法</h2><blockquote><p>Promise 的实例方法有 then&#x2F;catch&#x2F;finally 三种，静态方法有 all&#x2F;race&#x2F;allSettled&#x2F;any&#x2F;resolve&#x2F;reject 六种</p><p>then 和 catch 上面已经实现过了</p></blockquote><h3 id="实现-Promise-resolve"><a href="#实现-Promise-resolve" class="headerlink" title="实现 Promise.resolve"></a>实现 Promise.resolve</h3><p>实现 resolve 静态方法有三个要点:</p><ol><li>传参为一个 Promise, 则直接返回它。</li><li>传参为一个 thenable 对象，返回的 Promise 会跟随这个对象，采用它的最终状态作为自己的状态。</li><li>其他情况，直接返回以该值为成功状态的promise对象。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">resolve</span> = <span class="hljs-function">(<span class="hljs-params">param</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span>(param <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) <span class="hljs-keyword">return</span> param;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span>(param &amp;&amp; param.<span class="hljs-property">then</span> &amp;&amp; <span class="hljs-keyword">typeof</span> param.<span class="hljs-property">then</span> === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>      <span class="hljs-comment">// param 状态变为成功会调用resolve，将新 Promise 的状态变为成功，反之亦然</span><br>      param.<span class="hljs-title function_">then</span>(resolve, reject);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_">resolve</span>(param);<br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现-Promise-reject"><a href="#实现-Promise-reject" class="headerlink" title="实现 Promise.reject"></a>实现 Promise.reject</h3><p>Promise.reject 中传入的参数会作为一个 reason 原封不动地往下传, 实现如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">reject</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">reason</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-title function_">reject</span>(reason);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="实现-Promise-prototype-finally"><a href="#实现-Promise-prototype-finally" class="headerlink" title="实现 Promise.prototype.finally"></a>实现 Promise.prototype.finally</h3><p>无论当前 Promise 是成功还是失败，调用finally之后都会执行 finally 中传入的函数，并且将值原封不动的往下传。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">finally</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">callback</span>()).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> value;<br>    &#125;)<br>  &#125;, <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">callback</span>()).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">throw</span> error;<br>    &#125;)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h3 id="实现-Promise-all"><a href="#实现-Promise-all" class="headerlink" title="实现 Promise.all"></a>实现 Promise.all</h3><p>对于 <code>all</code> 方法而言，需要完成下面的核心功能:</p><ol><li>传入参数为一个空的可迭代对象，则直接进行<code>resolve</code>。</li><li>如果参数中有一个<code>promise</code>失败，那么<code>Promise.all</code>返回的<code>promise</code>对象失败。</li><li>在任何情况下，<code>Promise.all</code> 返回的 <code>promise</code> 的完成状态的结果都是一个数组</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">all</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">promises</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> result = [];<br>    <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> len = promises.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">if</span>(len === <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-title function_">resolve</span>(result);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>   <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>      <span class="hljs-comment">// 为什么不直接 promise[i].then, 因为promise[i]可能不是一个promise</span><br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(promise[i]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>        result[i] = data;<br>        index++;<br>        <span class="hljs-keyword">if</span>(index === len) <span class="hljs-title function_">resolve</span>(result);<br>      &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>        <span class="hljs-title function_">reject</span>(err);<br>      &#125;)<br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><h3 id="实现-Promise-allSettled"><a href="#实现-Promise-allSettled" class="headerlink" title="实现 Promise.allSettled"></a>实现 Promise.allSettled</h3><p>Promise.allSettled() 方法只有等到参数数组的所有 Promise 实例都发生状态变更，返回的 Promise 实例才会发生状态变更，无论是执行 resolve 回调还是 reject 回调的状态。<br>打个比方：多名员工分别同时进行多个项目，你要求每个一个项目都必须完成，然后得到所有项目是令你满意还是令你不满意的。强调的是最终结果。</p><p>同时因为 Promise.allSettled() 和 Promise.all() 都是对所有 Promise 实例的一种处理，下面就可以利用 Promise.all() 来实现 Promise.allSettled() 方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">MyPromise</span>.<span class="hljs-property">allSettled</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">promises</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(<br>    promises.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span><br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(item).<span class="hljs-title function_">then</span>(<br>        <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> (&#123; <span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;fulfilled&#x27;</span>, value &#125;),<br>        <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> (&#123; <span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;rejected&#x27;</span>, reason &#125;)<br>      )<br>    )<br>  );<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="实现-Promise-race"><a href="#实现-Promise-race" class="headerlink" title="实现 Promise.race"></a>实现 Promise.race</h3><p><code>race</code> 的实现相比之下就简单一些，只要有一个 <code>promise</code> 执行完，直接 <code>resolve</code> 并停止执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">race</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">promises</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span>(promises.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-title function_">resolve</span>();<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">let</span> len = promises.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">if</span>(len === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(promise[i]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(data);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>        <span class="hljs-title function_">reject</span>(err);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;)<br>    &#125;<br>   &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现-Promise-any"><a href="#实现-Promise-any" class="headerlink" title="实现 Promise.any"></a>实现 Promise.any</h3><p>Promise.any() 方法是返回任意一个最快执行 resolve 回调的 Promise 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">MyPromise</span>.<span class="hljs-property">any</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">promises</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (promises.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">resolve</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">let</span> result = [];<br>      <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; promises.<span class="hljs-property">length</span>; i++) &#123;<br>        promises[i].<span class="hljs-title function_">then</span>(<br>          <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-title function_">resolve</span>(value);<br>          &#125;,<br>          <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;<br>            result[i] = reason;<br>            <span class="hljs-comment">// 如果所有都失败则返回失败</span><br>            <span class="hljs-keyword">if</span> (++index === promises.<span class="hljs-property">length</span>) &#123;<br>              <span class="hljs-keyword">return</span> <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AggregateError</span>(result));<br>            &#125;<br>          &#125;<br>        );<br>      &#125;<br>    &#125;<br>  &#125;);<br>&#125;;<br><br></code></pre></td></tr></table></figure><blockquote><p>over</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>手写</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手写函数汇总</title>
    <link href="/2023/09/15/%E6%89%8B%E5%86%99%E5%87%BD%E6%95%B0/"/>
    <url>/2023/09/15/%E6%89%8B%E5%86%99%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="JavaScript-基础"><a href="#JavaScript-基础" class="headerlink" title="JavaScript 基础"></a>JavaScript 基础</h2><h3 id="1-手写-Object-create"><a href="#1-手写-Object-create" class="headerlink" title="1. 手写 Object.create"></a>1. 手写 Object.create</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">create</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"></span>) &#123;&#125;<br>  F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = obj<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-手写-instanceof-方法"><a href="#2-手写-instanceof-方法" class="headerlink" title="2.  手写 instanceof 方法"></a>2.  手写 instanceof 方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myInstanceof</span>(<span class="hljs-params">left, right</span>) &#123;<br>  <span class="hljs-keyword">let</span> proto = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(left),<br>  prototype = right.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <br> <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!proto) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (proto === prototype) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    proto = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(proto);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-手写-new-操作符"><a href="#3-手写-new-操作符" class="headerlink" title="3. 手写 new 操作符"></a>3. 手写 new 操作符</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">newOperator</span>(<span class="hljs-params">ctor, ...args</span>) &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> ctor !== <span class="hljs-string">&#x27;function&#x27;</span>)&#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;newOperator function the first param must be a function&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">let</span> obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(ctor.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br>    <span class="hljs-keyword">let</span> res = ctor.<span class="hljs-title function_">apply</span>(obj, args);<br><br>    <span class="hljs-comment">// 如果构造函数的返回值 res 是一个对象或函数，则直接返回它。否则，返回新创建的对象 obj</span><br>    <span class="hljs-keyword">let</span> isObject = (<span class="hljs-keyword">typeof</span> res === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; res !== <span class="hljs-literal">null</span>);<br>    <span class="hljs-keyword">let</span> isFunction = (<span class="hljs-keyword">typeof</span> res === <span class="hljs-string">&#x27;function&#x27;</span>);<br>    <span class="hljs-keyword">return</span> (isObect || isFunction ) ? res : obj;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="4-手写-Promise-简洁版"><a href="#4-手写-Promise-简洁版" class="headerlink" title="4. 手写 Promise (简洁版)"></a>4. 手写 Promise (简洁版)</h3><p>详细的可看自己的博客 , 这里未实现链式调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PENDING</span> = <span class="hljs-string">&quot;PENDING&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">FULFILLED</span> = <span class="hljs-string">&quot;FULFILLED&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">REJECTED</span> = <span class="hljs-string">&quot;REJECTED&quot;</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Promise</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-literal">undefined</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = <span class="hljs-literal">undefined</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PENDING</span>;<br>    <span class="hljs-comment">// 定义两个数组解决异步调用resolve或者reject的问题</span><br>    <span class="hljs-comment">// 充当队列把then里边的回调存起来</span><br>    <span class="hljs-comment">// 有的时候，我们会给同一个promise实例执行多次then方法, 那么相应的onFulfilled和onRejected回调必须按照其发起调用的顺序执行。</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onResolvedCallbacks</span> = [];<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span> = [];<br><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">resolve</span> = (<span class="hljs-params">value</span>) =&gt; &#123;<br>      <span class="hljs-comment">// 当状态为pending状态的时候才可以去改变状态，并且分别将value和reason赋值给对应值，并去执行相应回调函数</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">FULFILLED</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onResolvedCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> <span class="hljs-title function_">fn</span>());<br>      &#125;<br>    &#125;;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">reject</span> = (<span class="hljs-params">reason</span>) =&gt; &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = reason;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">REJECTED</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> <span class="hljs-title function_">fn</span>());<br>      &#125;<br>    &#125;;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-title function_">executor</span>(resolve, reject);<br>    &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>      <span class="hljs-title function_">reject</span>(err); <span class="hljs-comment">//有报错会直接执行reject函数将状态变为失败rejected</span><br>    &#125;<br>  &#125;<br><br>  <span class="hljs-title function_">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>) &#123;<br>    <span class="hljs-comment">//当执行到then的时候，状态已经是fulfilled状态或者是rejected状态，那么就直接执行回调，并且将value/reason作为第一个参数</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">FULFILLED</span>) &#123;<br>      onFulfilled &amp;&amp; <span class="hljs-title function_">onFulfilled</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">REJECTED</span>) &#123;<br>      onRejected &amp;&amp; <span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>);<br>    &#125;<br>    <span class="hljs-comment">//当执行到then的时候，状态还是pending状态，那么需要将回调存起来，等到状态改变的时候再去执行</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">onResolvedCallbacks</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">onFulfilled</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>      &#125;);<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>);<br>      &#125;);<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">Promise</span>;<br></code></pre></td></tr></table></figure><h3 id="5-手写-Promise-的各种方法"><a href="#5-手写-Promise-的各种方法" class="headerlink" title="5. 手写 Promise 的各种方法"></a>5. 手写 Promise 的各种方法</h3><p>Promise 的实例方法有 then&#x2F;catch&#x2F;finally 三种，静态方法有 all&#x2F;race&#x2F;allSettled&#x2F;any&#x2F;resolve&#x2F;reject 六种</p><h4 id="5-1-手写-Promise-resolve"><a href="#5-1-手写-Promise-resolve" class="headerlink" title="5.1. 手写 Promise.resolve"></a>5.1. 手写 Promise.resolve</h4><p>以下几种关于 Promise 各种方法实现的具体细节可看<a href="https://www.yuque.com/zweirdo/zxyob8/kg4i04ywgxe469w1#JKyuC">JavaScript八股</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">resolve</span> = <span class="hljs-function">(<span class="hljs-params">param</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span>(param <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) <span class="hljs-keyword">return</span> param;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span>(param &amp;&amp; param.<span class="hljs-property">then</span> &amp;&amp; <span class="hljs-keyword">typeof</span> param.<span class="hljs-property">then</span> === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>      <span class="hljs-comment">// param 状态变为成功会调用resolve，将新 Promise 的状态变为成功，反之亦然</span><br>      param.<span class="hljs-title function_">then</span>(resolve, reject);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_">resolve</span>(param);<br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-2-手写-Promise-reject"><a href="#5-2-手写-Promise-reject" class="headerlink" title="5.2. 手写 Promise.reject"></a>5.2. 手写 Promise.reject</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">reject</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">reason</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-title function_">reject</span>(reason);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-3-手写-Promise-prototype-finally"><a href="#5-3-手写-Promise-prototype-finally" class="headerlink" title="5.3. 手写 Promise.prototype.finally"></a>5.3. 手写 Promise.prototype.finally</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">finally</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">callback</span>()).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> value;<br>    &#125;)<br>  &#125;, <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">callback</span>()).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">throw</span> error;<br>    &#125;)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-4-手写-Promise-all"><a href="#5-4-手写-Promise-all" class="headerlink" title="5.4. 手写 Promise.all"></a>5.4. 手写 Promise.all</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">all</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">promises</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(promises)) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">`promises must be a array`</span>)<br>    <span class="hljs-keyword">let</span> result = [];<br>    <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> len = promises.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">if</span>(len === <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-title function_">resolve</span>(result);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>   <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>      <span class="hljs-comment">// 为什么不直接 promise[i].then, 因为promise[i]可能不是一个promise</span><br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(promise[i]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>        result[i] = data;<br>        index++;<br>        <span class="hljs-keyword">if</span>(index === len) <span class="hljs-title function_">resolve</span>(result);<br>      &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>        <span class="hljs-title function_">reject</span>(err);<br>      &#125;)<br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-5-手写-Promise-allSettled"><a href="#5-5-手写-Promise-allSettled" class="headerlink" title="5.5. 手写 Promise.allSettled"></a>5.5. 手写 Promise.allSettled</h4><p>因为 Promise.allSettled() 和 Promise.all() 都是对<strong>所有 Promise 实例</strong>的一种处理，下面就可以利用 Promise.all() 来实现 Promise.allSettled() 方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">MyPromise</span>.<span class="hljs-property">allSettled</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">promises</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(<br>    promises.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span><br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(item).<span class="hljs-title function_">then</span>(<br>        <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> (&#123; <span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;fulfilled&#x27;</span>, value &#125;),<br>        <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> (&#123; <span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;rejected&#x27;</span>, reason &#125;)<br>      )<br>    )<br>  );<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="5-6-手写-Promise-race"><a href="#5-6-手写-Promise-race" class="headerlink" title="5.6. 手写 Promise.race"></a>5.6. 手写 Promise.race</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">race</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">promises</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> len = promises.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">if</span>(len === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(promise[i]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(data);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>        <span class="hljs-title function_">reject</span>(err);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;)<br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-手写防抖函数"><a href="#6-手写防抖函数" class="headerlink" title="6. 手写防抖函数"></a>6. 手写防抖函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn, delay</span>) &#123;<br>  <span class="hljs-keyword">let</span> timer;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>    timer &amp;&amp; <span class="hljs-built_in">clearTimeout</span>(timer);<br>    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>    &#125;, delay);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-手写节流函数"><a href="#7-手写节流函数" class="headerlink" title="7. 手写节流函数"></a>7. 手写节流函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 定时器版本</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn, delay</span>) &#123;<br>  <span class="hljs-keyword">let</span> timer;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!timer) &#123;<br>      timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>        timer = <span class="hljs-literal">null</span>;<br>      &#125;, delay);<br>    &#125;<br>  &#125;;<br>&#125;<br><br><span class="hljs-comment">// 时间戳版本</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">throole</span>(<span class="hljs-params">fn, delay</span>) &#123;<br>  <span class="hljs-keyword">let</span> st = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-keyword">let</span> now = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>    <span class="hljs-keyword">if</span> (delay - (now - st) &lt;= <span class="hljs-number">0</span>) &#123;<br>      fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>      st = now;<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-手写类型判断函数"><a href="#8-手写类型判断函数" class="headerlink" title="8. 手写类型判断函数"></a>8. 手写类型判断函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getType</span>(<span class="hljs-params">value</span>) &#123;<br>  <span class="hljs-comment">// 判断数据是 null 的情况</span><br>  <span class="hljs-keyword">if</span> (value === <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">return</span> value + <span class="hljs-string">&quot;&quot;</span>;<br>  &#125;<br>  <span class="hljs-comment">// 判断数据是引用类型的情况</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&quot;object&quot;</span>) &#123;<br>    <span class="hljs-keyword">let</span> valueClass = <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(value), <span class="hljs-comment">// 重点</span><br>    type = valueClass.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot; &quot;</span>)[<span class="hljs-number">1</span>].<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    type.<span class="hljs-title function_">pop</span>();<br>    <span class="hljs-keyword">return</span> type.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">toLowerCase</span>();<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 判断数据是基本数据类型的情况和函数的情况</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> value;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-手写-call-函数"><a href="#9-手写-call-函数" class="headerlink" title="9. 手写 call 函数"></a>9. 手写 call 函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 给函数对象添加方法: mycall</span><br><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">mycall</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">thisArg, ...otherArgs</span>) &#123;<br>    <span class="hljs-comment">// this -&gt; 调用的函数对象</span><br>    <span class="hljs-comment">// thisArg -&gt; 传入的第一个参数, 要绑定的this</span><br>    <span class="hljs-comment">// console.log(this) // -&gt; 当前调用的函数对象</span><br><br>    <span class="hljs-comment">// 判断调用对象</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&quot;function&quot;</span>)  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;Error&quot;</span>);<br><br>    <span class="hljs-comment">// 获取thisArg, 并且确保是一个对象类型</span><br>    thisArg = (thisArg === <span class="hljs-literal">null</span> || thisArg === <span class="hljs-literal">undefined</span>)? <span class="hljs-attr">window</span>: <span class="hljs-title class_">Object</span>(thisArg)<br><br>    <span class="hljs-keyword">const</span> fnKey = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;fn&#x27;</span>);<br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(thisArg, fnKey, &#123;<br>        <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 不可枚举</span><br>        <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">value</span>: <span class="hljs-variable language_">this</span><br>    &#125;)<br>    thisArg[fnKey](...otherArgs) <span class="hljs-comment">// 通过thisArg调用方法, 相当于改变了this指向</span><br><br>    <span class="hljs-keyword">delete</span> thisArg[fnKey] <span class="hljs-comment">// 最后要删除</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-手写-apply-函数"><a href="#10-手写-apply-函数" class="headerlink" title="10. 手写 apply 函数"></a>10. 手写 apply 函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hyapply</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">thisArg, otherArgs</span>) &#123;<br><br>  <span class="hljs-comment">// 判断调用对象</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&quot;function&quot;</span>)  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;Error&quot;</span>);<br><br>  <span class="hljs-comment">// 获取thisArg, 并且确保是一个对象类型</span><br>  thisArg = (thisArg === <span class="hljs-literal">null</span> || thisArg === <span class="hljs-literal">undefined</span>)? <span class="hljs-attr">window</span>: <span class="hljs-title class_">Object</span>(thisArg)<br>  <span class="hljs-comment">// 上方的window可以改成globalThis更严谨</span><br><br>  <span class="hljs-keyword">const</span> fnKey = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;fn&#x27;</span>); <span class="hljs-comment">// 防止篡改thisArg原有的属性</span><br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(thisArg, fnKey, &#123;  <br>    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">value</span>: <span class="hljs-variable language_">this</span>    <span class="hljs-comment">// this指向调用者</span><br>  &#125;)<br>  thisArg[fnKey](...otherArgs)   <span class="hljs-comment">// 和call的区别就是后面的参数是数组形式</span><br>  <span class="hljs-keyword">delete</span> thisArg[fnKey];  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="11-手写-bind-函数"><a href="#11-手写-bind-函数" class="headerlink" title="11. 手写 bind 函数"></a>11. 手写 bind 函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hybind</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">thisArg, ...otherArgs</span>) &#123;<br><br>  <span class="hljs-comment">// 判断调用对象</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&quot;function&quot;</span>)  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;Error&quot;</span>);<br><br>  thisArg = thisArg === <span class="hljs-literal">null</span> || thisArg === <span class="hljs-literal">undefined</span> ? <span class="hljs-attr">window</span>: <span class="hljs-title class_">Object</span>(thisArg)<br>  <span class="hljs-keyword">const</span> fnKey = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;fn&#x27;</span>); <span class="hljs-comment">// 防止篡改thisArg原有的属性</span><br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(thisArg, fnKey, &#123;<br>    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">value</span>: <span class="hljs-variable language_">this</span><br>  &#125;)<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...newArgs</span>) =&gt;</span> &#123;  <span class="hljs-comment">// 返回一个函数拿去调用</span><br>    <span class="hljs-keyword">var</span> allArgs = [...otherArgs, ...newArgs]  <span class="hljs-comment">// 可能还会传参数</span><br>    thisArg[fnKey](...allArgs)<br>    <span class="hljs-comment">// 因为下次调用还会使用这个fnKey , 所以不要删除</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="12-手写柯里化函数"><a href="#12-手写柯里化函数" class="headerlink" title="12. 手写柯里化函数"></a>12. 手写柯里化函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a,b,c</span>)&#123;<br>  <span class="hljs-keyword">return</span> a+b+c;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">curring</span>(<span class="hljs-params">fn</span>)&#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">cur</span>(<span class="hljs-params">...args</span>)&#123;<br>    <span class="hljs-keyword">if</span>(args.<span class="hljs-property">length</span>&gt;=fn.<span class="hljs-property">length</span>)&#123;<br>      <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>,args);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...newargs</span>)&#123;<br>        <span class="hljs-keyword">return</span> cur.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>,args.<span class="hljs-title function_">concat</span>(newargs));<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> cur;<br>&#125;<br><span class="hljs-keyword">let</span> add=<span class="hljs-title function_">curring</span>(foo);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)); <span class="hljs-comment">// 6</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)); <span class="hljs-comment">// 6</span><br></code></pre></td></tr></table></figure><h3 id="13-实现AJAX请求"><a href="#13-实现AJAX请求" class="headerlink" title="13. 实现AJAX请求"></a>13. 实现AJAX请求</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">SERVER_URL</span> = <span class="hljs-string">&quot;/server&quot;</span>;<br><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br><span class="hljs-comment">// 创建 Http 请求</span><br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-variable constant_">SERVER_URL</span>, <span class="hljs-literal">true</span>);<br><span class="hljs-comment">// 设置状态监听函数</span><br>xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">readyState</span> !== <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-comment">// 当请求成功时</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>    <span class="hljs-title function_">handle</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">response</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>);<br>  &#125;<br>&#125;;<br><span class="hljs-comment">// 设置请求失败时的监听函数</span><br>xhr.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>);<br>&#125;;<br><span class="hljs-comment">// 设置请求头信息</span><br>xhr.<span class="hljs-property">responseType</span> = <span class="hljs-string">&quot;json&quot;</span>;<br>xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>);<br><span class="hljs-comment">// 发送 Http 请求</span><br>xhr.<span class="hljs-title function_">send</span>(<span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure><h3 id="14-使用Promise封装AJAX请求"><a href="#14-使用Promise封装AJAX请求" class="headerlink" title="14. 使用Promise封装AJAX请求"></a>14. 使用Promise封装AJAX请求</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getJSON</span>(<span class="hljs-params">url</span>) &#123;<br>  <span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>    xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, url, <span class="hljs-literal">true</span>);<br>    xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">readyState</span> !== <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span>;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">response</span>);  <span class="hljs-comment">// 注意</span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>));<br>      &#125;<br>    &#125;;<br>    xhr.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>));<br>    &#125;;<br>    xhr.<span class="hljs-property">responseType</span> = <span class="hljs-string">&quot;json&quot;</span>;<br>    xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>);<br>    xhr.<span class="hljs-title function_">send</span>(<span class="hljs-literal">null</span>);<br>  &#125;);<br>  <span class="hljs-keyword">return</span> promise;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="15-浅拷贝的各种实现方法"><a href="#15-浅拷贝的各种实现方法" class="headerlink" title="15. 浅拷贝的各种实现方法"></a>15. 浅拷贝的各种实现方法</h3><p>手写浅拷贝</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">shallowClone</span> = (<span class="hljs-params">target</span>) =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> target === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; target !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">const</span> cloneTarget = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(target) ? []: &#123;&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> prop <span class="hljs-keyword">in</span> target) &#123;<br>      <span class="hljs-keyword">if</span> (target.<span class="hljs-title function_">hasOwnProperty</span>(prop)) &#123;<br>          cloneTarget[prop] = target[prop];<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cloneTarget;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> target;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Object.assign</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;sy&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span> &#125;;<br><span class="hljs-keyword">const</span> obj2 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, obj, &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;sss&#x27;</span>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2);<span class="hljs-comment">//&#123; name: &#x27;sss&#x27;, age: 18 &#125;</span><br></code></pre></td></tr></table></figure><p>数组方法 concat </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> newArr = arr.<span class="hljs-title function_">concat</span>();<br>newArr[<span class="hljs-number">1</span>] = <span class="hljs-number">100</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<span class="hljs-comment">//[ 1, 2, 3 ]</span><br></code></pre></td></tr></table></figure><p>数组方法 slice</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> newArr = arr.<span class="hljs-title function_">slice</span>();<br>newArr[<span class="hljs-number">0</span>] = <span class="hljs-number">100</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<span class="hljs-comment">//[1, 2, 3]</span><br></code></pre></td></tr></table></figure><p>…展开运算符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> newArr = [...arr];<span class="hljs-comment">//跟arr.slice()是一样的效果</span><br></code></pre></td></tr></table></figure><h3 id="16-深拷贝的实现方法"><a href="#16-深拷贝的实现方法" class="headerlink" title="16. 深拷贝的实现方法"></a>16. 深拷贝的实现方法</h3><p>JSON.parse(JSON.stringify(obj))</p><p>它的原理就是利用JSON.stringify 将js对象序列化（JSON字符串），再使用JSON.parse来反序列化(还原)js对象。这时候两个对象的引用就不相同了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj1 = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">b</span>: &#123;<span class="hljs-attr">c</span>: <span class="hljs-number">0</span>&#125; &#125;;<br><span class="hljs-keyword">let</span> obj2 = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj1));<br>obj1.<span class="hljs-property">a</span> = <span class="hljs-number">1</span>;<br>obj1.<span class="hljs-property">b</span>.<span class="hljs-property">c</span> = <span class="hljs-number">1</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1); <span class="hljs-comment">// &#123;a: 1, b: &#123;c: 1&#125;&#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2); <span class="hljs-comment">// &#123;a: 0, b: &#123;c: 0&#125;&#125;</span><br></code></pre></td></tr></table></figure><p>函数库lodash的_.cloneDeep方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> _ = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;lodash&#x27;</span>);<br><span class="hljs-keyword">var</span> obj1 = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">b</span>: &#123; <span class="hljs-attr">f</span>: &#123; <span class="hljs-attr">g</span>: <span class="hljs-number">1</span> &#125; &#125;,<br>    <span class="hljs-attr">c</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>&#125;;<br><span class="hljs-keyword">var</span> obj2 = _.<span class="hljs-title function_">cloneDeep</span>(obj1);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1.<span class="hljs-property">b</span>.<span class="hljs-property">f</span> === obj2.<span class="hljs-property">b</span>.<span class="hljs-property">f</span>);<span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p><strong>⭐ 手写实现深拷贝函数</strong></p><p>具体优化细节可以看<a href="https://www.yuque.com/zweirdo/zxyob8/mkhhq2eoodzvocnb#ggm18">18_深拷贝-事件总线</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isObject</span>(<span class="hljs-params">originValue</span>) &#123;<br>    <span class="hljs-keyword">const</span> myType = <span class="hljs-keyword">typeof</span> originValue;<br>    <span class="hljs-keyword">return</span> myType != <span class="hljs-literal">null</span> &amp;&amp; (myType === <span class="hljs-string">&quot;function&quot;</span> || myType === <span class="hljs-string">&quot;object&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepCopy</span>(<span class="hljs-params">originValue, map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>()</span>) &#123;<br>  <br>    <span class="hljs-comment">// 1.如果值是Symbol的类型</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> originValue === <span class="hljs-string">&quot;symbol&quot;</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Symbol</span>(originValue.<span class="hljs-property">description</span>)<br>    &#125;<br><br>    <span class="hljs-comment">// 2.如果是原始类型或者promise, 直接返回</span><br>    <span class="hljs-comment">// 如果你深拷贝一个 Promise 对象，可能会破坏其异步行为，并且导致意外行为。</span><br>    <span class="hljs-comment">// 这样可以避免破坏异步行为和意外行为。</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isObject</span>(originValue) || originValue <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) &#123;<br>        <span class="hljs-keyword">return</span> originValue<br>    &#125;<br><br>    <span class="hljs-comment">// 3.如果是set类型</span><br>    <span class="hljs-keyword">if</span> (originValue <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Set</span>) &#123;<br>        <span class="hljs-keyword">const</span> newSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> setItem <span class="hljs-keyword">of</span> originValue) &#123;<br>            newSet.<span class="hljs-title function_">add</span>(<span class="hljs-title function_">deepCopy</span>(setItem))<br>        &#125;<br>        <span class="hljs-keyword">return</span> newSet<br>    &#125;<br><br>    <span class="hljs-comment">// 4. 判断值是否为map类型</span><br>    <span class="hljs-keyword">if</span> (originValue <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Map</span>) &#123;<br>        <span class="hljs-keyword">const</span> newMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [i, j] <span class="hljs-keyword">of</span> originValue) &#123;<br>            newMap.<span class="hljs-title function_">set</span>(<span class="hljs-title function_">deepCopy</span>(i, map), <span class="hljs-title function_">deepCopy</span>(j, map));<br>        &#125;<br>        <span class="hljs-keyword">return</span> newMap;<br>    &#125;<br><br>    <span class="hljs-comment">// 5. 处理日期对象</span><br>    <span class="hljs-keyword">if</span> (originValue <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Date</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(originValue.<span class="hljs-title function_">getTime</span>());<br>    &#125;<br><br>    <span class="hljs-comment">// 6. 处理正则表达式对象</span><br>    <span class="hljs-keyword">if</span> (originValue <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">RegExp</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(originValue);<br>    &#125;<br><br>    <span class="hljs-comment">// 7.如果是函数function类型, 不需要进行深拷贝</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> originValue === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>        <span class="hljs-keyword">return</span> originValue<br>    &#125;<br><br>    <span class="hljs-comment">// 8.处理循环引用</span><br>    <span class="hljs-keyword">if</span> (map.<span class="hljs-title function_">get</span>(originValue)) &#123;<br>        <span class="hljs-keyword">return</span> map.<span class="hljs-title function_">get</span>(originValue)<br>    &#125;<br><br>    <span class="hljs-comment">// 9.判断是对象或者数组类型</span><br>    <span class="hljs-keyword">const</span> newObj = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(originValue) ? []: &#123;&#125;<br>    map.<span class="hljs-title function_">set</span>(originValue, newObj)<br><br>    <span class="hljs-comment">// 遍历普通的key</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> originValue) &#123;<br>        newObj[key] = <span class="hljs-title function_">deepCopy</span>(originValue[key], map);<br>    &#125;<br><br>    <span class="hljs-comment">// 单独遍历symbol</span><br>    <span class="hljs-keyword">const</span> symbolKeys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertySymbols</span>(originValue)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> symbolKey <span class="hljs-keyword">of</span> symbolKeys) &#123;<br>        newObj[<span class="hljs-title class_">Symbol</span>(symbolKey.<span class="hljs-property">description</span>)] = <span class="hljs-title function_">deepCopy</span>(originValue[symbolKey], map)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> newObj<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="17-判断循环引用的方法"><a href="#17-判断循环引用的方法" class="headerlink" title="17. 判断循环引用的方法"></a>17. 判断循环引用的方法</h3><p>原生</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">isCycleObject</span> = (<span class="hljs-params">obj, parent</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> parentArr = parent || [obj]; <span class="hljs-comment">//  如果没有传入父级, parentArr就代表包含当前对象的数组</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(parentArr);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> obj) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj[i] === <span class="hljs-string">&quot;object&quot;</span>) &#123;<br>      <span class="hljs-keyword">let</span> flag = <span class="hljs-literal">false</span>;<br>      parentArr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">pObj</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (pObj === obj[i]) &#123;<br>          flag = <span class="hljs-literal">true</span>;<br>        &#125;<br>      &#125;);<br>      <span class="hljs-keyword">if</span> (flag) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      flag = <span class="hljs-title function_">isCycleObject</span>(obj[i], [...parentArr, obj[i]]); <span class="hljs-comment">// 递归调用这个子对象</span><br>      <span class="hljs-keyword">if</span> (flag) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;;<br><br><span class="hljs-keyword">var</span> a = &#123; <span class="hljs-attr">b</span>: &#123; <span class="hljs-attr">c</span>: &#123;&#125; &#125; &#125;;<br><br>a.<span class="hljs-property">b</span>.<span class="hljs-property">c</span>.<span class="hljs-property">d</span> = a;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">isCycleObject</span>(a));<br><span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>递归 + 哈希表</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isCircular</span>(<span class="hljs-params">obj, hash = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>()</span>) &#123;<br>  <span class="hljs-keyword">if</span> (obj === <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&#x27;object&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>  <span class="hljs-keyword">if</span> (hash.<span class="hljs-title function_">has</span>(obj)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>  hash.<span class="hljs-title function_">set</span>(obj, <span class="hljs-literal">true</span>)<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hasOwnProperty</span>.<span class="hljs-title function_">call</span>(obj, key)) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isCircular</span>(obj[key], hash)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><h3 id="1-实现数组的扁平化"><a href="#1-实现数组的扁平化" class="headerlink" title="1. 实现数组的扁平化"></a>1. 实现数组的扁平化</h3><p>实现数组扁平化有 6 种方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript">ary = ary.<span class="hljs-title function_">flat</span>(<span class="hljs-title class_">Infinity</span>); <span class="hljs-comment">// Infinity 代表扁平多少层</span><br>ary = str.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/(\[|\])/g</span>, <span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;,&#x27;</span>) <span class="hljs-comment">// 把括号全部替换为空字符串</span><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]]];<br><span class="hljs-keyword">let</span> fn = <span class="hljs-keyword">function</span>(<span class="hljs-params">ary</span>) &#123;<br>  <span class="hljs-keyword">let</span> result = [];<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; ary.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">let</span> item = ary[i];<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(item))&#123;<br>      result = result.<span class="hljs-title function_">concat</span>(<span class="hljs-title function_">fn</span>(item));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      result.<span class="hljs-title function_">push</span>(item);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">fn</span>(arr))  <span class="hljs-comment">// [ 1, 2, 3, 4, 5 ]</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">flatten</span>(<span class="hljs-params">ary</span>) &#123;<br>    <span class="hljs-keyword">return</span> ary.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">pre, cur</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> pre.<span class="hljs-title function_">concat</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(cur) ? <span class="hljs-title function_">flatten</span>(cur) : cur);<br>    &#125;, []);<br>&#125;<br><span class="hljs-comment">//只要有一个元素有数组，那么循环继续</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">flatten</span>(<span class="hljs-params">arr</span>) &#123;<br>    <span class="hljs-keyword">while</span> (arr.<span class="hljs-title function_">some</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(item))) &#123;<br>        arr = [].<span class="hljs-title function_">concat</span>(...arr);<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]];<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">flatten</span>(<span class="hljs-params">arr</span>) &#123;<br>    <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;,&#x27;</span>).<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Number</span>);<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">flatten</span>(arr)); <span class="hljs-comment">//  [ 1, 2, 3, 4 ]</span><br></code></pre></td></tr></table></figure><p>以上数组 <code>arr.toString()</code> 之后 直接变成了 <code>1,2,3,4</code></p><h3 id="2-实现数组各个方法"><a href="#2-实现数组各个方法" class="headerlink" title="2. 实现数组各个方法"></a>2. 实现数组各个方法</h3><p>flat</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">_flat</span>(<span class="hljs-params">arr, depth</span>) &#123;<br>  <span class="hljs-keyword">if</span>(!<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(arr) || depth &lt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> arr;<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">prev, cur</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(cur)) &#123;<br>      <span class="hljs-keyword">return</span> prev.<span class="hljs-title function_">concat</span>(<span class="hljs-title function_">_flat</span>(cur, depth - <span class="hljs-number">1</span>))<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> prev.<span class="hljs-title function_">concat</span>(cur);<br>    &#125;<br>  &#125;, []);<br>&#125;<br></code></pre></td></tr></table></figure><p>push</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 简便写法</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">push</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">for</span>( <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span> ; i++)&#123;<br><span class="hljs-variable language_">this</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>] = <span class="hljs-variable language_">arguments</span>[i] ;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>;<br>&#125;<br><br><br><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">push</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">...items</span>) &#123;<br>  <span class="hljs-keyword">let</span> O = <span class="hljs-title class_">Object</span>(<span class="hljs-variable language_">this</span>);<br>  <span class="hljs-keyword">let</span> len = <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span> &gt;&gt;&gt; <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> argCount = items.<span class="hljs-property">length</span> &gt;&gt;&gt; <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 2 ** 53 - 1 为JS能表示的最大正整数</span><br>  <span class="hljs-keyword">if</span> (len + argCount &gt; <span class="hljs-number">2</span> ** <span class="hljs-number">53</span> - <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;The number of array is over the max value restricted!&quot;</span>)<br>  &#125;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; argCount; i++) &#123;<br>    O[len + i] = items[i];<br>  &#125;<br>  <span class="hljs-keyword">let</span> newLength = len + argCount;<br>  O.<span class="hljs-property">length</span> = newLength;<br>  <span class="hljs-keyword">return</span> newLength;<br>&#125;<br></code></pre></td></tr></table></figure><p>pop</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">pop</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> O = <span class="hljs-title class_">Object</span>(<span class="hljs-variable language_">this</span>);<br>  <span class="hljs-keyword">let</span> len = <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span> &gt;&gt;&gt; <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (len === <span class="hljs-number">0</span>) &#123;<br>    O.<span class="hljs-property">length</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;<br>  &#125;<br>  len --;<br>  <span class="hljs-keyword">let</span> value = O[len];<br>  <span class="hljs-keyword">delete</span> O[len];<br>  O.<span class="hljs-property">length</span> = len;<br>  <span class="hljs-keyword">return</span> value;<br>&#125;<br></code></pre></td></tr></table></figure><p>filter</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_filter</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fn !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;参数必须是一个函数&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">const</span> res = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>; i &lt; len; i++) &#123;<br>        <span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">this</span>[i]) &amp;&amp; res.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>map</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 简便写法</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">map</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">cb,thisArg</span>)&#123;<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(<span class="hljs-variable language_">this</span>) || <span class="hljs-keyword">typeof</span> cb != <span class="hljs-string">&#x27;function&#x27;</span>)&#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;has Error, please check!&#x27;</span>)<br>    &#125;<br>    <span class="hljs-keyword">var</span> res = []<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>; i++)&#123;<br>     <span class="hljs-comment">//使用call方法来改变this指向即可</span><br>     res.<span class="hljs-title function_">push</span>(cb.<span class="hljs-title function_">call</span>(thisArg,<span class="hljs-variable language_">this</span>[i],i,<span class="hljs-variable language_">this</span>))<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br><br><br><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_map</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">fn</span>) &#123;<br>   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fn !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;参数必须是一个函数&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">const</span> res = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>; i &lt; len; i++) &#123;<br>        res.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">this</span>[i]));<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>reduce</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">reduce</span>  = <span class="hljs-keyword">function</span>(<span class="hljs-params">callbackfn, initialValue</span>) &#123;<br>  <span class="hljs-comment">// 异常处理，和 map 一样</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span> === <span class="hljs-literal">null</span> || <span class="hljs-variable language_">this</span> === <span class="hljs-literal">undefined</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;Cannot read property &#x27;reduce&#x27; of null or undefined&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(callbackfn) != <span class="hljs-string">&quot;[object Function]&quot;</span>) &#123; <span class="hljs-comment">//注意中间无逗号</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(callbackfn + <span class="hljs-string">&#x27; is not a function&#x27;</span>)<br>  &#125;<br>  <span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 后面要重复利用</span><br>  <span class="hljs-keyword">let</span> O = <span class="hljs-title class_">Object</span>(<span class="hljs-variable language_">this</span>);  <span class="hljs-comment">// 先将调用者转为对象</span><br>  <span class="hljs-keyword">let</span> len = O.<span class="hljs-property">length</span> &gt;&gt;&gt; <span class="hljs-number">0</span>;  <span class="hljs-comment">// 确认为整数</span><br>  <span class="hljs-keyword">let</span> accumulator = initialValue; <span class="hljs-comment">// 积累值</span><br>  <span class="hljs-keyword">if</span> (accumulator === <span class="hljs-literal">undefined</span>) &#123;   <span class="hljs-comment">// 没传初始值</span><br>    <span class="hljs-keyword">for</span>(; k &lt; len ; k++) &#123;<br>      <span class="hljs-keyword">if</span> (k <span class="hljs-keyword">in</span> O) &#123;  <br>        accumulator = O[k];<br>        k++;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 表示数组全为空</span><br>  <span class="hljs-keyword">if</span>(k === len &amp;&amp; accumulator === <span class="hljs-literal">undefined</span>) <br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Each element of the array is empty&#x27;</span>);<br>  <br>  <span class="hljs-keyword">for</span>(;k &lt; len; k++) &#123;<br>    <span class="hljs-keyword">if</span> (k <span class="hljs-keyword">in</span> O) &#123;<br>      accumulator = callbackfn.<span class="hljs-title function_">call</span>(<span class="hljs-literal">undefined</span>, accumulator, O[k], k, O);   <span class="hljs-comment">// 注意，核心！</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> accumulator;<br>&#125;<br></code></pre></td></tr></table></figure><p>sort</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> quick_sort = <span class="hljs-keyword">function</span>(<span class="hljs-params">a, l, r</span>)&#123;<br>    <span class="hljs-keyword">if</span>(l &gt;= r)<span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">let</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> x = a[mid];<br>    <span class="hljs-keyword">while</span>(i &lt; j)&#123;<br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span>(a[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span>(a[j] &gt; x);<br>        <span class="hljs-keyword">if</span>(i &lt; j)&#123;<br>            <span class="hljs-keyword">let</span> z = a[i];<br>            a[i] = a[j];<br>            a[j] = z;<br>        &#125;<br>    &#125;<br>    <span class="hljs-title function_">quick_sort</span>(a, l, j);<br>    <span class="hljs-title function_">quick_sort</span>(a, j + <span class="hljs-number">1</span>, r);<br>&#125;<br><span class="hljs-keyword">var</span> q = [<span class="hljs-number">1</span>,<span class="hljs-number">44</span>,<span class="hljs-number">6</span>,<span class="hljs-number">713</span>,<span class="hljs-number">76</span>];<br><span class="hljs-title function_">quick_sort</span>(q, <span class="hljs-number">0</span>, q.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(q);  <span class="hljs-comment">// [ 1, 6, 44, 76, 713 ]</span><br></code></pre></td></tr></table></figure><p>splice 方法(了解原理)</p><details class="lake-collapse"><summary id="u3d2e2d29"><span class="ne-text">代码</span></summary><pre data-language="javascript" id="YT8RU" class="ne-codeblock language-javascript" style="border: 1px solid #e8e8e8; border-radius: 2px; background: #f9f9f9; padding: 16px; font-size: 13px; color: #595959"><code>Array.prototype.splice = function(startIndex, deleteCount, ...addElements)  &#123;  // 1. 初始工作  let argumentsLen = arguments.length;  let array = Object(this);  let len = array.length;  let deleteArr = new Array(deleteCount);<pre><code class="hljs">// 2. 参数的清洗工作</code></pre><p>  &#x2F;&#x2F; 当用户传来非法的 startIndex 和 deleteCount 或者负索引的时候，需要我们做出特殊的处理。<br>  if (startIndex &lt; 0) {<br>    startIndex &#x3D; startIndex + len &gt; 0 ? startIndex + len: 0;<br>  }<br>  else startIndex &#x3D; startIndex &gt;&#x3D; len ? len: startIndex;</p><p>  &#x2F;&#x2F; 删除数目没有传，默认删除startIndex及后面所有的<br>  if (argumentsLen &#x3D;&#x3D;&#x3D; 1)  deleteCount &#x3D; len - startIndex;<br>  else if (deleteCount &lt; 0) deleteCount &#x3D; 0 &#x2F;&#x2F; 删除数目过小<br>  else if (deleteCount &gt; len - startIndex) deletCount &#x3D; len - startIndex; &#x2F;&#x2F;删除数目过大</p><pre><code class="hljs">// 3. 判断 sealed 对象和 frozen 对象, 即 密封对象 和 冻结对象if (Object.isSealed(array) &amp;amp;&amp;amp; deleteCount !== addElements.length) &#123;throw new TypeError(&#39;the object is a sealed object!&#39;)</code></pre><p>  } else if(Object.isFrozen(array) &amp;&amp; (deleteCount &gt; 0 || addElements.length &gt; 0)) {<br>    throw new TypeError(‘the object is a frozen object!’)<br>  }</p><p>  &#x2F;&#x2F; 4.拷贝删除的元素<br>  for (let i &#x3D; 0; i &lt; deleteCount; i++) {<br>    let index &#x3D; startIndex + i;<br>    if (index in array) {<br>      let current &#x3D; array[index];<br>      deleteArr[i] &#x3D; current;<br>    }<br>  }</p><p>  &#x2F;&#x2F; 5.移动删除元素后面的元素</p><p>  &#x2F;&#x2F; 对删除元素后面的元素进行挪动, 挪动分为三种情况:<br>  &#x2F;&#x2F; * 添加的元素和删除的元素个数相等<br>  &#x2F;&#x2F; * 添加的元素个数小于删除的元素<br>  &#x2F;&#x2F; * 添加的元素个数大于删除的元素</p><p>  if (deleteCount &#x3D;&#x3D;&#x3D; addElements.length) &#x2F;&#x2F; 就什么也不管<br>  else if(deleteCount &gt; addElements.length) {<br>    &#x2F;&#x2F; 删除的元素比新增的元素多，那么后面的元素整体向前挪动<br>    for (let i &#x3D; startIndex + deleteCount; i &lt; len; i++) {<br>      let fromIndex &#x3D; i; &#x2F;&#x2F; 移动元素的起始位置<br>      let toIndex &#x3D; i - (deleteCount - addElements.length); &#x2F;&#x2F; 将要挪动到的目标位置<br>      if (fromIndex in array) {<br>        array[toIndex] &#x3D; array[fromIndex];<br>      } else {<br>        delete array[toIndex];<br>      }<br>    }<br>    &#x2F;&#x2F; 注意注意！这里我们把后面的元素向前挪，相当于数组长度减小了，需要删除冗余元素<br>    &#x2F;&#x2F; 目前长度为 len + addElements - deleteCount<br>    for (let i &#x3D; len - 1; i &gt;&#x3D; len + addElements.length - deleteCount; i –) {<br>      delete array[i];<br>    }<br>  }<br>     else if(deleteCount &lt; addElements.length) {<br>    &#x2F;&#x2F; 删除的元素比新增的元素少，那么后面的元素整体向后挪动<br>    &#x2F;&#x2F; 思考一下: 这里为什么要从后往前遍历？从前往后会产生什么问题？<br>    for (let i &#x3D; len - 1; i &gt;&#x3D; startIndex + deleteCount; i–) {<br>      let fromIndex &#x3D; i;  &#x2F;&#x2F; 挪动元素的初始位置<br>      let toIndex &#x3D; i + (addElements.length - deleteCount); &#x2F;&#x2F; 将要挪动到的目标位置<br>      if (fromIndex in array) {<br>        array[toIndex] &#x3D; array[fromIndex];<br>      } else {<br>        delete array[toIndex];<br>      }<br>    }<br>  }</p><p>  &#x2F;&#x2F; 6.插入新元素<br>  for (let i &#x3D; 0; i &lt; addElements.length; i++) {<br>    array[startIndex + i] &#x3D; addElements[i];<br>  }<br>  array.length &#x3D; len - deleteCount + addElements.length;</p><p>  &#x2F;&#x2F; 7.返回被删除元素组成的数组<br>  return deleteArr;<br>}</code></pre></details></p><h3 id="实现数组的乱序输出"><a href="#实现数组的乱序输出" class="headerlink" title="实现数组的乱序输出"></a>实现数组的乱序输出</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>  <span class="hljs-comment">// 注意最后加i就行, 否则会重复输出同一个值</span><br>  <span class="hljs-keyword">const</span> randomIndex = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * (arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span> - i)) + i; <br>  [arr[i], arr[randomIndex]] = [arr[randomIndex], arr[i]];<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr)<br></code></pre></td></tr></table></figure><h3 id="实现字符串的-repeat-方法"><a href="#实现字符串的-repeat-方法" class="headerlink" title="实现字符串的 repeat 方法"></a>实现字符串的 repeat 方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">repeat</span>(<span class="hljs-params">s, n</span>) &#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(n + <span class="hljs-number">1</span>)).<span class="hljs-title function_">join</span>(s);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-实现字符串各个方法"><a href="#3-实现字符串各个方法" class="headerlink" title="3. 实现字符串各个方法"></a>3. 实现字符串各个方法</h3><p>repeat</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">repeat</span>(<span class="hljs-params">s, n</span>) &#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(n + <span class="hljs-number">1</span>)).<span class="hljs-title function_">join</span>(s);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-将数字每千分位用逗号隔开"><a href="#4-将数字每千分位用逗号隔开" class="headerlink" title="4. 将数字每千分位用逗号隔开"></a>4. 将数字每千分位用逗号隔开</h3><p>数字无小数版本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">format</span> = n =&gt; &#123;<br>    <span class="hljs-keyword">let</span> num = n.<span class="hljs-title function_">toString</span>() <br>    <span class="hljs-keyword">let</span> len = num.<span class="hljs-property">length</span><br>    <span class="hljs-keyword">if</span> (len &lt;= <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-keyword">return</span> num<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">let</span> remainder = len % <span class="hljs-number">3</span><br>        <span class="hljs-keyword">if</span> (remainder &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 不是3的整数倍</span><br>          <span class="hljs-comment">// 每隔三个数字用逗号分隔为字符串</span><br>          <span class="hljs-keyword">return</span> num.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, remainder) + <span class="hljs-string">&#x27;,&#x27;</span> + num.<span class="hljs-title function_">slice</span>(remainder, len).<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\d&#123;3&#125;/g</span>).<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;,&#x27;</span>) <br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 是3的整数倍</span><br>            <span class="hljs-keyword">return</span> num.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, len).<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\d&#123;3&#125;/g</span>).<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;,&#x27;</span>) <br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-title function_">format</span>(<span class="hljs-number">1232323</span>)  <span class="hljs-comment">// &#x27;1,232,323&#x27;</span><br></code></pre></td></tr></table></figure><p>数字有小数版本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">format</span> = n =&gt; &#123;<br>    <span class="hljs-keyword">let</span> num = n.<span class="hljs-title function_">toString</span>() <span class="hljs-comment">// 转成字符串</span><br>    <span class="hljs-keyword">let</span> decimals = <span class="hljs-string">&#x27;&#x27;</span><br>        <span class="hljs-comment">// 判断是否有小数</span><br>    num.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;.&#x27;</span>) &gt; -<span class="hljs-number">1</span> ? decimals = num.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;.&#x27;</span>)[<span class="hljs-number">1</span>] : decimals<br>    <span class="hljs-keyword">let</span> len = num.<span class="hljs-property">length</span><br>    <span class="hljs-keyword">if</span> (len &lt;= <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-keyword">return</span> num<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">let</span> temp = <span class="hljs-string">&#x27;&#x27;</span><br>        <span class="hljs-keyword">let</span> remainder = len % <span class="hljs-number">3</span><br>        decimals ? temp = <span class="hljs-string">&#x27;.&#x27;</span> + decimals : temp<br>        <span class="hljs-keyword">if</span> (remainder &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 不是3的整数倍</span><br>            <span class="hljs-keyword">return</span> num.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, remainder) + <span class="hljs-string">&#x27;,&#x27;</span> + num.<span class="hljs-title function_">slice</span>(remainder, len).<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\d&#123;3&#125;/g</span>).<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;,&#x27;</span>) + temp<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 是3的整数倍</span><br>            <span class="hljs-keyword">return</span> num.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, len).<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\d&#123;3&#125;/g</span>).<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;,&#x27;</span>) + temp <br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-title function_">format</span>(<span class="hljs-number">12323.33</span>)  <span class="hljs-comment">// &#x27;12,323.33&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="5-手写日期格式化函数"><a href="#5-手写日期格式化函数" class="headerlink" title="5. 手写日期格式化函数"></a>5. 手写日期格式化函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">dateFormat</span> = (<span class="hljs-params">dateInput, format</span>)=&gt;&#123;<br>    <span class="hljs-keyword">var</span> day = dateInput.<span class="hljs-title function_">getDate</span>() <br>    <span class="hljs-keyword">var</span> month = dateInput.<span class="hljs-title function_">getMonth</span>() + <span class="hljs-number">1</span>  <br>    <span class="hljs-keyword">var</span> year = dateInput.<span class="hljs-title function_">getFullYear</span>()   <br>    format = format.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/yyyy/</span>, year)<br>    format = format.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/MM/</span>,month)<br>    format = format.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/dd/</span>,day)<br>    <span class="hljs-keyword">return</span> format<br>&#125;<br><span class="hljs-title function_">dateFormat</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-string">&#x27;2020-12-01&#x27;</span>), <span class="hljs-string">&#x27;yyyy/MM/dd&#x27;</span>) <span class="hljs-comment">// 2020/12/01</span><br><span class="hljs-title function_">dateFormat</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-string">&#x27;2020-04-01&#x27;</span>), <span class="hljs-string">&#x27;yyyy/MM/dd&#x27;</span>) <span class="hljs-comment">// 2020/04/01</span><br><span class="hljs-title function_">dateFormat</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-string">&#x27;2020-04-01&#x27;</span>), <span class="hljs-string">&#x27;yyyy年MM月dd日&#x27;</span>) <span class="hljs-comment">// 2020年04月01日</span><br></code></pre></td></tr></table></figure><h3 id="6-实现大整数相加"><a href="#6-实现大整数相加" class="headerlink" title="6. 实现大整数相加"></a>6. 实现大整数相加</h3><p>来自算法篇章</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-string">&#x27;13124342343353535235&#x27;</span><br><span class="hljs-keyword">let</span> b = <span class="hljs-string">&#x27;34423434234234243233&#x27;</span><br><span class="hljs-comment">// 两个字符串a, b</span><br><span class="hljs-keyword">let</span> arr1 = a.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Number</span>);<br><span class="hljs-keyword">let</span> arr2 = b.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Number</span>);<br><span class="hljs-keyword">let</span> res = [];<br><span class="hljs-keyword">let</span> flag = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(arr1.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span> || arr2.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>  <span class="hljs-keyword">let</span> t1 = arr1.<span class="hljs-title function_">pop</span>() || <span class="hljs-number">0</span>;  <span class="hljs-comment">// 判断arr1是否已经为空</span><br>  <span class="hljs-keyword">let</span> t2 = arr2.<span class="hljs-title function_">pop</span>() || <span class="hljs-number">0</span>;  <span class="hljs-comment">// 判断arr2是否已经为空</span><br>  <span class="hljs-keyword">let</span> tmp = t1 + t2 + flag;<br>  flag = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(tmp / <span class="hljs-number">10</span>)<br>  res.<span class="hljs-title function_">unshift</span>(tmp % <span class="hljs-number">10</span>)<br>&#125;<br><span class="hljs-keyword">if</span>(flag) res.<span class="hljs-title function_">unshift</span>(flag);<br>res = res.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res); <span class="hljs-comment">// 47547776577587778468</span><br></code></pre></td></tr></table></figure><h3 id="7-解析-URL-Params-为对象"><a href="#7-解析-URL-Params-为对象" class="headerlink" title="7. 解析 URL Params 为对象"></a>7. 解析 URL Params 为对象</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> url = <span class="hljs-string">&#x27;http://www.domain.com/?user=anonymous&amp;id=123&amp;id=456&amp;city=%E5%8C%97%E4%BA%AC&amp;enabled&#x27;</span>;<br><span class="hljs-title function_">parseParam</span>(url)<br><span class="hljs-comment">/* 结果</span><br><span class="hljs-comment">&#123; user: &#x27;anonymous&#x27;,</span><br><span class="hljs-comment">  id: [ 123, 456 ], // 重复出现的 key 要组装成数组，能被转成数字的就转成数字类型</span><br><span class="hljs-comment">  city: &#x27;北京&#x27;, // 中文需解码</span><br><span class="hljs-comment">  enabled: true, // 未指定值得 key 约定为 true</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>exec 是正则的方法</p><p>exec() 方法在一个指定字符串中执行一个搜索匹配。返回一个结果数组或 null。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">parseParam</span>(<span class="hljs-params">url</span>) &#123;<br>  <span class="hljs-keyword">const</span> paramsStr = <span class="hljs-regexp">/.+\?(.+)$/</span>.<span class="hljs-title function_">exec</span>(url)[<span class="hljs-number">1</span>]; <span class="hljs-comment">// 将 ? 后面的字符串取出来❗</span><br>  <span class="hljs-keyword">const</span> paramsArr = paramsStr.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&amp;&#x27;</span>); <span class="hljs-comment">// 将字符串以 &amp; 分割后存到数组中</span><br>  <span class="hljs-keyword">let</span> paramsObj = &#123;&#125;;<br>  <span class="hljs-comment">// 将 params 存到对象中</span><br>  paramsArr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">param</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/=/</span>.<span class="hljs-title function_">test</span>(param)) &#123; <span class="hljs-comment">// 处理有 value 的参数, 存在 &#x27;=&#x27;</span><br>      <span class="hljs-keyword">let</span> [key, val] = param.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;=&#x27;</span>); <span class="hljs-comment">// 分割 key 和 value</span><br>      val = <span class="hljs-built_in">decodeURIComponent</span>(val); <span class="hljs-comment">// 解码❗ 注意还需解码</span><br>      val = <span class="hljs-regexp">/^\d+$/</span>.<span class="hljs-title function_">test</span>(val) ? <span class="hljs-built_in">parseFloat</span>(val) : val; <span class="hljs-comment">// 判断是否转为数字</span><br>      <span class="hljs-keyword">if</span> (paramsObj.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123; <span class="hljs-comment">// 如果对象有 key，则添加一个值</span><br>        paramsObj[key] = [].<span class="hljs-title function_">concat</span>(paramsObj[key], val); <span class="hljs-comment">// 将其变为数组, 因为有多个值, 就用数组存起来</span><br>      &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 如果对象没有这个 key，创建 key 并设置值</span><br>        paramsObj[key] = val;<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 处理没有 value 的参数</span><br>      paramsObj[param] = <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;)<br>  <span class="hljs-keyword">return</span> paramsObj;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>手写</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue响应式原理</title>
    <link href="/2023/09/12/Vue%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"/>
    <url>/2023/09/12/Vue%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="1-认识响应式逻辑"><a href="#1-认识响应式逻辑" class="headerlink" title="1. 认识响应式逻辑"></a>1. 认识响应式逻辑</h2><blockquote><p>抽象描绘</p></blockquote><ul><li>假如你有一个变量m , 你的某一段代码使用了变量m , 如果某个时刻变量m发生了改变, 那么这段代码也会重新执行.</li><li>但实际上执行的代码中可能不止一行代码，所以我们可以将这些代码放到一个函数中, 于是就变成了, <strong>你有一个对象, 你的某个函数使用了对象的某个属性, 如果某个时候这个属性发生改变, 这个函数也会重新执行</strong></li></ul><blockquote><p>具体描述</p></blockquote><p>数据驱动视图 </p><p>简洁版 :</p><p>在 Vue 实例创建过程中，首先对所有属性进行劫持 ( vue2 &#x2F; vue3 方法和原理都不同, 注意辨别 ) ,   同时会为每个数据属性创建一个 <code>Dep</code>（依赖），Dep 用于收集所有订阅了该属性的 <code>Watcher</code>。当属性值发生变化时，Vue 会通知该属性对应的这些 <code>Watcher</code> 实例进行相应的更新操作。</p><ul><li>数据响应式</li></ul><p>Vue采用的是<strong>数据劫持</strong>结合<strong>发布和-订阅者模式</strong>的方式</p><blockquote><p> 通过拦截对数据的操作，在数据变动时发布消息给订阅者，触发相应的监听回调。</p></blockquote><h3 id=""><a href="#" class="headerlink" title=""></a></h3><ul><li>数据劫持</li></ul><blockquote><p>vue2数据劫持</p></blockquote><p>vue2通过<code>Object.defineProperty</code>对<code>data</code>上的数据<strong>递归地</strong>进行(转为)<code>getter</code>和<code>setter</code>操作。也就是对属性的读取、修改进行拦截（数据劫持）</p><p>注意是将 data 中的所有属性进行监听</p><blockquote><p>vue3 数据劫持</p></blockquote><p>vue3通过<code>Proxy</code>对象创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。<code>Proxy</code>的监听是深层次的，<strong>监听整个对象，而不是某个属性。</strong></p><p>这里是将 reactive () 中的所有属性进行监听</p><ul><li>发布者-订阅者模式</li></ul><p>简单地说，发布者-订阅者模式的流程就是，监听器<code>**Observer**</code>监听数据状态变化, 一旦数据发生变化，则会通知(数据)对应的订阅者<code>**Watcher**</code>，让订阅者执行对应的业务逻辑 。</p><ul><li>整个响应式执行过程</li></ul><ol><li>在 Vue 实例初始化过程中， 我们设置了一个监听器<code>**Observer**</code>，此实例的所有相关属性会被监听(也就是上方的数据劫持)  . 在此过程中，Vue 会对<strong>每个属性</strong>创建一个 <code>dep</code> 实例</li></ol><ul><li>vue2 对 data 中的属性进行遍历生成 <code>dep</code> 实例</li><li>vue3 中对 <code>reactive()</code> 中的对象进行遍历生成 <code>dep</code> 实例</li><li><code>dep</code> 实例会收集所有订阅了该属性的 <code>Watcher 订阅者</code>, 并将该 <code>Watcher</code> 绑定更新函数</li><li>这些更新函数可能会执行一些操作，比如更新模板中的文本、计算新的值等</li></ul><ol><li>通过<code>Compile</code>解析模板指令，将模板中的数据和方法与真实 DOM 节点关联起来，使得数据和方法能够被视图访问和使用, 然后再初始化渲染页面视图.</li><li>一旦属性发生变化，Vue 会通知所有订阅了当前属性的的订阅者<code>Watcher</code>(这些 <code>Watcher</code> 放在属性对应的 <code>dep</code> 实例当中), 来执行此订阅者对应的更新函数,  从而更新视图.</li></ol><blockquote><p> MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</p></blockquote><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309210946810.png" alt="image-20230921094628751"></p><h2 id="2-响应式依赖收集"><a href="#2-响应式依赖收集" class="headerlink" title="2. 响应式依赖收集"></a>2. 响应式依赖收集</h2><h3 id="2-1-响应式函数的实现watchFn"><a href="#2-1-响应式函数的实现watchFn" class="headerlink" title="2.1. 响应式函数的实现watchFn"></a>2.1. 响应式函数的实现watchFn</h3><p>我们现在实现一个响应式函数</p><p>◼ 但是我们怎么区分呢？</p><ul><li>这个时候我们封装一个新的函数<code>watchFn</code>；</li><li><strong>凡是传入到watchFn的函数，就是需要响应式的；</strong></li><li>其他默认定义的函数都是不需要响应式的；</li></ul><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927280.png" alt="img"></p><p>如图, foo以及bar都是需要响应式的</p><p>我们将这些函数在响应之前先执行一次</p><p>当obj的某个属性发生变化时, 就依次执行reactiveFns中的函数</p><p>目前当然是极为不完善, 待后续优化hhh</p><h3 id="2-2-响应式依赖的收集-类"><a href="#2-2-响应式依赖的收集-类" class="headerlink" title="2.2. 响应式依赖的收集__类"></a>2.2. 响应式依赖的收集__类</h3><p>◼ 目前我们收集的依赖是放到一个数组中来保存的，但是这里会存在数据管理的问题：</p><ul><li> 我们在实际开发中<strong>需要监听很多对象的响应式；</strong></li><li> 这些对象需要监听的不只是一个属性，它们很多属性的变化，都会有对应的响应式函数；</li><li> 我们不<strong>可能在全局维护一大堆的数组来保存这些响应函数；</strong></li></ul><p>◼ 所以我们要<strong>设计一个类，这个类用于管理某一个对象的某一个属性的所有响应式函数：</strong></p><ul><li> 相当于替代了原来的简单 reactiveFns 的数组；</li></ul><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927189.png" alt="img"></p><p>这个类记住</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927257.png" alt="img"></p><p>当我们某个属性发生变化时, 只需执行dep.notify()就行了, 无需一个一个的遍历函数</p><p>这个obj对象就对应Depend类所创建出来的对象</p><p>当然, 还需大大的优化</p><p>现在我们每次修改了一个属性之后都是手动的去调用, 这样太麻烦了, 我们想要让它自动去调用响应函数,</p><p>因此我们要去监听属性的变化</p><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h2 id="3-Object-defineProperty-监听属性变化"><a href="#3-Object-defineProperty-监听属性变化" class="headerlink" title="3. Object.defineProperty()监听属性变化"></a>3. Object.defineProperty()监听属性变化</h2><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927250.png" alt="img"></p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927238.png" alt="img"></p><p>再记一遍这个类</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927292.png" alt="img"></p><p>注意看注释</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927814.png" alt="img"></p><p>这里在属性变化后就不用手动给它通知了, 自动响应实现</p><p>不过这种收集方式其实是错误的hhhhh</p><h2 id="4-自动收集依赖-🔥"><a href="#4-自动收集依赖-🔥" class="headerlink" title="4. 自动收集依赖 🔥"></a>4. 自动收集依赖 🔥</h2><p>我们现在发现了一个问题 , obj 对象的两个属性都依赖于 同一个dep对象的reactiveFns,</p><p>这样就会造成我们根本没办法区分它们</p><p>对于同一个对象来说, 我们还是给它放到了同一个dep里面, 这会造成无法将它的属性区分</p><p><strong>如何解决这个问题呢 ?</strong> </p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927843.png" alt="img"></p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927050.png" alt="img"></p><p>比如我们要获取obj对象的name属性的依赖</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> dep = objMap.<span class="hljs-title function_">get</span>(obj).<span class="hljs-title function_">get</span>(name);<br>dep.<span class="hljs-title function_">notifiy</span>();<br></code></pre></td></tr></table></figure><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927155.png" alt="img"></p><ul><li><p>dep对象数据结构的管理</p></li><li><p>每一个对象的每一个属性都会对应一个dep对象</p></li><li><p>同一个对象的多个属性的dep对象是存放一个map对象中</p></li><li><p>多个对象的map对象, 会被存放到一个objMap的对象中</p></li><li><p>当执行get函数, 自动的添加fn函数</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Depend</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span> = []<br>  &#125;<br><br>  <span class="hljs-title function_">addDepend</span>(<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-keyword">if</span> (fn) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span>.<span class="hljs-title function_">push</span>(fn)<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-title function_">notify</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> &#123;<br>      <span class="hljs-title function_">fn</span>()<br>    &#125;)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span><br>&#125;<br><br><span class="hljs-comment">// 设置一个专门执行响应式函数的一个函数</span><br><span class="hljs-keyword">let</span> reactiveFn = <span class="hljs-literal">null</span> <span class="hljs-comment">// </span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">watchFn</span>(<span class="hljs-params">fn</span>) &#123;<br>  reactiveFn = fn<br>  <span class="hljs-title function_">fn</span>() <span class="hljs-comment">// 执行下方的get方法 , 使得间接的把函数加到特定的dep对象上</span><br>  <span class="hljs-comment">//(因为函数中会有一些对象会有一些属性)</span><br>  reactiveFn = <span class="hljs-literal">null</span> <span class="hljs-comment">// 使用完后再置为null, 不然可能会造成影响</span><br>&#125;<br><br><span class="hljs-comment">// 封装一个函数: 负责通过obj的key获取对应的Depend对象</span><br><span class="hljs-comment">// 我们用一个WeakMap对所有对象进行管理, 我们不需要对里面进行强引用, </span><br><span class="hljs-comment">// 如果有一天obj为null,那就无法销毁了</span><br><span class="hljs-keyword">const</span> objMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>()<br><br><br><span class="hljs-comment">// 这个函数的作用是通过对象的key找到它的dep对象</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getDepend</span>(<span class="hljs-params">obj, key</span>) &#123;<br>  <br>  <span class="hljs-comment">// 1.根据对象obj, 找到对应的map对象</span><br>  <span class="hljs-keyword">let</span> map = objMap.<span class="hljs-title function_">get</span>(obj) <span class="hljs-comment">// 没有就new一个</span><br>  <span class="hljs-keyword">if</span> (!map) &#123;<br>    map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br>    objMap.<span class="hljs-title function_">set</span>(obj, map)<br>  &#125;<br><br>  <span class="hljs-comment">// 2.根据key, 找到对应的depend对象</span><br>  <span class="hljs-keyword">let</span> dep = map.<span class="hljs-title function_">get</span>(key)<br>  <span class="hljs-keyword">if</span> (!dep) &#123;<br>    dep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Depend</span>()<br>    map.<span class="hljs-title function_">set</span>(key, dep)<br>  &#125;<br>  <span class="hljs-keyword">return</span> dep<br>&#125;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> value = obj[key]<br><br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, key, &#123;<br>    <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">newValue</span>) &#123;<br>      value = newValue<br>      <span class="hljs-comment">// 拿到这个对象的属性的dep对象</span><br>      <span class="hljs-keyword">const</span> dep = <span class="hljs-title function_">getDepend</span>(obj, key)<br>      dep.<span class="hljs-title function_">notify</span>()  <span class="hljs-comment">// 对这些</span><br>    &#125;,<br>    <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-comment">// 在函数中拿到obj 和 key 就会调用这个get方法</span><br>      <span class="hljs-comment">// console.log(&quot;get函数中:&quot;, obj, key)</span><br>      <span class="hljs-comment">// 找到对应的obj对象的key对应的dep对象</span><br>      <span class="hljs-keyword">const</span> dep = <span class="hljs-title function_">getDepend</span>(obj, key) <br>      <span class="hljs-comment">// 意味着我们只会创建obj对象的key属性的dep对象</span><br>      dep.<span class="hljs-title function_">addDepend</span>(reactiveFn) <br>      <span class="hljs-comment">// 精髓 : 在这个dep对象上放入跟特有对象的特有属性相关的函数,即reactiveFn</span><br>      <span class="hljs-comment">// dep这个对象就是保存了跟这个特有对象特有属性相关的一些函数</span><br>      <br>      <span class="hljs-keyword">return</span> value<br>    &#125;<br>  &#125;)<br>&#125;)<br><br><span class="hljs-title function_">watchFn</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;foo function&quot;</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;foo:&quot;</span>, obj.<span class="hljs-property">name</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;foo&quot;</span>, obj.<span class="hljs-property">age</span>)<br>&#125;)<br><br><span class="hljs-title function_">watchFn</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;bar function&quot;</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;bar:&quot;</span>, obj.<span class="hljs-property">age</span> + <span class="hljs-number">10</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>注意看注释 !!!!!</p><p>你用了我的数据, 我就收集你的依赖, 你没用, 我就不收集 —</p><p>我们还有可以优化的点 : </p><p>当我们执行下面这段代码时</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927937.png" alt="img"></p><p>age发生变化时, 它会执行两次函数</p><p>我们可以这样操作</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927105.png" alt="img"></p><p>我们的reactiveFns是一个Set, 这样它就不会添加相同的函数到这里面去</p><p>然后下方的push改为add</p><p>还有一个地方是我们可以给<img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927328.png" alt="img">这个地方换个写法</p><p>我们并不希望将reactiveFn添加放到get中，因为它是属于Dep的行为 (也可以不换, 看自己 )</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927511.png" alt="img"></p><p>我们直接在类中添加一个方法自动获取收集的函数<code>depend()</code></p><p>相当于利用到这个自由变量<code>reactiveFn</code></p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927495.png" alt="img"></p><p>然后直接<code>dep.depen()</code>调用即可</p><p>不过这两种写法都可以 hhh</p><p>但这个代码还有不足, 关于<strong>多个对象</strong>, 我们如何给它挨个来自动收集依赖, 因为我们这里是写死给obj对象自动收集依赖的</p><p>如何解决呢? </p><p>方法如下hhh —- 多个对象响应式</p><h2 id="5-多个对象响应式"><a href="#5-多个对象响应式" class="headerlink" title="5. 多个对象响应式"></a>5. 多个对象响应式</h2><p>我们只需要将监听对象属性的这一串代码封装为一个函数</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927710.png" alt="img"></p><p>这里我们将这一串代码封装为一个函数reactive, 我们创建的对象就可以作为参数传递进去, 那么这个对象的所有属性就能被监听到了, 然后我们<strong>返回一个被监听的对象</strong></p><p>注意 : 需要返回这个对象哈, 别搞忘了</p><p>然后我们在创建对象时使用这个函数, 那么对象的所有属性就能被监听到了</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927717.png" alt="img"></p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927766.png" alt="img"></p><p>以上都是vue2响应式原理(也就是defineProperty), 接下来我们用vue3对代码进行重构</p><p>特别easy</p><h2 id="6-vue3-监听对象-proxy"><a href="#6-vue3-监听对象-proxy" class="headerlink" title="6. vue3__监听对象__proxy"></a>6. vue3__监听对象__proxy</h2><p>我们直接将</p><p>Object.defineProperty</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927710.png" alt="img"></p><p>这部分代码改成</p><p>proxy</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927876.png" alt="img"></p><p>在我们调用了Proxy的get捕获器时, 收集依赖</p><p>因为如果一个函数中使用了某个对象的key，那么它应该被收集依赖；</p><p>这部分代码即可</p><p>都是学过的东西 , 忘了就翻翻前面的笔记 </p><h2 id="7-完整响应式代码"><a href="#7-完整响应式代码" class="headerlink" title="7. 完整响应式代码"></a>7. 完整响应式代码</h2><p>完整响应式代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Depend</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()<br>  &#125;<br><br>  <span class="hljs-title function_">addDepend</span>(<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-keyword">if</span> (fn) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span>.<span class="hljs-title function_">add</span>(fn)<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-title function_">depend</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (reactiveFn) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span>.<span class="hljs-title function_">add</span>(reactiveFn)<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-title function_">notify</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> &#123;<br>      <span class="hljs-title function_">fn</span>()<br>    &#125;)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> reactiveFn = <span class="hljs-literal">null</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">watchFn</span>(<span class="hljs-params">fn</span>) &#123;<br>  reactiveFn = fn<br>  <span class="hljs-title function_">fn</span>()<br>  reactiveFn = <span class="hljs-literal">null</span><br>&#125;<br><br><span class="hljs-keyword">const</span> objMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>()<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getDepend</span>(<span class="hljs-params">obj, key</span>) &#123;<br>  <span class="hljs-comment">// 1.根据对象obj, 找到对应的map对象</span><br>  <span class="hljs-keyword">let</span> map = objMap.<span class="hljs-title function_">get</span>(obj)<br>  <span class="hljs-keyword">if</span> (!map) &#123;<br>    map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br>    objMap.<span class="hljs-title function_">set</span>(obj, map)<br>  &#125;<br><br>  <span class="hljs-comment">// 2.根据key, 找到对应的depend对象</span><br>  <span class="hljs-keyword">let</span> dep = map.<span class="hljs-title function_">get</span>(key)<br>  <span class="hljs-keyword">if</span> (!dep) &#123;<br>    dep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Depend</span>()<br>    map.<span class="hljs-title function_">set</span>(key, dep)<br>  &#125;<br>  <span class="hljs-keyword">return</span> dep<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">reactive</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">const</span> objProxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;<br>    <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">target, key, newValue, receiver</span>) &#123;<br>      <span class="hljs-comment">// target[key] = newValue</span><br>      <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, newValue, receiver)<br>      <span class="hljs-keyword">const</span> dep = <span class="hljs-title function_">getDepend</span>(target, key)<br>      dep.<span class="hljs-title function_">notify</span>()<br>    &#125;,<br>    <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">target, key, receiver</span>) &#123;<br>      <span class="hljs-keyword">const</span> dep = <span class="hljs-title function_">getDepend</span>(target, key)<br>      dep.<span class="hljs-title function_">depend</span>()<br>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver)<br>    &#125;<br>  &#125;)<br>  <span class="hljs-keyword">return</span> objProxy <br>&#125;<br></code></pre></td></tr></table></figure><p>业务代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = <span class="hljs-title function_">reactive</span>(&#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>  <span class="hljs-attr">address</span>: <span class="hljs-string">&quot;广州市&quot;</span><br>&#125;)<br><br><span class="hljs-title function_">watchFn</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">name</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">age</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">age</span>)<br>&#125;)<br><br><span class="hljs-comment">// 修改name</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;--------------&quot;</span>)<br><span class="hljs-comment">// obj.name = &quot;kobe&quot;</span><br>obj.<span class="hljs-property">age</span> = <span class="hljs-number">20</span><br><span class="hljs-comment">// obj.address = &quot;上海市&quot;</span><br><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;=============== user =================&quot;</span>)<br><span class="hljs-keyword">const</span> user = <span class="hljs-title function_">reactive</span>(&#123;<br>  <span class="hljs-attr">nickname</span>: <span class="hljs-string">&quot;abc&quot;</span>,<br>  <span class="hljs-attr">level</span>: <span class="hljs-number">100</span><br>&#125;)<br><br><span class="hljs-title function_">watchFn</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;nickname:&quot;</span>, user.<span class="hljs-property">nickname</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;level:&quot;</span>, user.<span class="hljs-property">level</span>)<br>&#125;)<br><br>user.<span class="hljs-property">nickname</span> = <span class="hljs-string">&quot;cba&quot;</span><br></code></pre></td></tr></table></figure><p>执行结果</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202309121927019.png" alt="img"></p><p>总结 : </p><ul><li>Vue3主要是通过Proxy来监听数据的变化以及收集相关的依赖的；</li><li>ue2中通过我们前面学习过的Object.defineProerty的方式来实现对象属性的监听；</li></ul>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>手写</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>后端抽象理解</title>
    <link href="/2023/06/19/%E5%90%8E%E7%AB%AF%E5%BD%A2%E8%B1%A1%E7%90%86%E8%A7%A3%E7%AF%87/"/>
    <url>/2023/06/19/%E5%90%8E%E7%AB%AF%E5%BD%A2%E8%B1%A1%E7%90%86%E8%A7%A3%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h2 id="如何形象的理解-spring"><a href="#如何形象的理解-spring" class="headerlink" title="如何形象的理解 spring?"></a>如何形象的理解 spring?</h2><blockquote><p>依赖注入框架，帮助你管理 Java 对象，集成一些其他的内容</p></blockquote><p>让我们用通俗易懂的语言来解释Spring框架。</p><p>想象一下你在组装一台电脑。你需要连接各个硬件组件，如CPU、内存、硬盘等，并确保它们能够协同工作。Spring框架就像是电脑组装的助手，它帮助你管理和组织各个组件，并提供一些便捷的功能。</p><p>在这个比喻中：</p><ul><li>你可以将硬件组件看作是你的应用程序中的不同部分，如服务、数据访问对象、控制器等。</li><li>Spring框架则扮演了管理和组织这些组件的角色，确保它们能够协同工作。</li><li>框架提供了一种便捷的方式来连接和配置这些组件，就像你将硬件组件插入主板上的插槽一样。</li><li>框架还提供了一些额外的功能，如依赖注入（DI），就像是帮助你将各个硬件组件连接在一起，使它们可以相互通信和协作。</li><li>你可以使用框架提供的功能来实现业务逻辑，就像在电脑上运行软件应用程序一样。</li></ul><p>总的来说，Spring框架是一个帮助你管理和组织应用程序组件的工具。它简化了开发过程，提供了便捷的连接和配置方式，并提供了一些额外的功能来增强应用程序的灵活性和可维护性。使用Spring框架，你可以更轻松地构建和管理复杂的应用程序，并提供高效、可靠的功能。</p><h2 id="如何形象的理解依赖注入"><a href="#如何形象的理解依赖注入" class="headerlink" title="如何形象的理解依赖注入?"></a>如何形象的理解依赖注入?</h2><p>让我们用一个日常生活的比喻来形象地理解依赖注入。</p><p>假设你是一个厨师，需要准备一道菜。为了完成这道菜，你需要使用一些食材，如蔬菜、肉类、调味料等。</p><p>在没有依赖注入的情况下，你可能需要自己去购买这些食材，并将它们携带到厨房。这意味着你要亲自管理食材的采购、携带和使用过程。这可能会增加你的负担和工作量，还可能导致混乱和错误。</p><p>现在，假设你有一个厨师助手，他负责为你提供所需的食材。这就是依赖注入的概念在生活中的体现。</p><p>在这个比喻中：</p><ul><li>你是主厨，负责菜的制作，即应用程序的核心逻辑。</li><li>食材是你所需要的依赖对象，如服务、数据访问对象等。</li><li>厨师助手是依赖注入的机制，负责将食材提供给你，以供你使用。</li><li>依赖注入让你从繁琐的采购和管理任务中解放出来，专注于菜的制作。</li></ul><p>在编程中，依赖注入的概念类似。它是一种设计模式，通过在需要使用某个对象的地方将其注入（提供）给目标对象，减少了目标对象与依赖对象之间的耦合性。这样，目标对象可以专注于自己的业务逻辑，而不需要关心如何创建或获取依赖对象。</p><p>总而言之，依赖注入就像是一个厨师助手为你提供所需食材一样，它让你从繁琐的依赖管理中解放出来，让你的代码更加清晰、模块化和可维护。它使代码的组织和协作更加灵活和简单。</p><h2 id="如何形象的理解-springmvc"><a href="#如何形象的理解-springmvc" class="headerlink" title="如何形象的理解 springmvc ?"></a>如何形象的理解 springmvc ?</h2><blockquote><p>web 框架，提供接口访问、restful接口等能力</p></blockquote><p>让我们用一个类比来形象地理解Spring MVC。</p><p>假设你是一家快餐店的服务员，负责接待顾客并处理他们的点餐请求。</p><p>在没有Spring MVC的情况下，你可能需要一个人来处理所有的任务，包括接待顾客、记录点餐、取餐、上菜等。这样的情况下，你可能会感到忙碌和混乱，很难有效地处理顾客的需求。</p><p>现在，假设快餐店引入了Spring MVC框架来协助你进行工作。这就是Spring MVC的作用。</p><p>在这个比喻中：</p><ul><li>你是服务员，负责处理顾客的点餐请求，即处理Web请求的控制器。</li><li>顾客是Web应用的用户，发送请求给服务器。</li><li>Spring MVC框架则扮演了一个协调者的角色，负责接收请求、路由请求到适当的控制器，并将结果返回给用户。</li><li>框架提供了一些便捷的功能，如请求路由、参数绑定、视图渲染等，使你能够更加高效地处理顾客的点餐请求。</li></ul><p>使用Spring MVC，你可以将业务逻辑分散到不同的控制器中，每个控制器负责处理特定类型的请求。这样，你可以更好地组织和管理代码，并提供更好的用户体验。</p><p>总而言之，Spring MVC就像是一个服务员的协助工具，帮助你更好地处理Web请求，分散和管理业务逻辑，并提供高效的处理方式。它简化了开发过程，提供了便捷的路由和控制功能，使得Web应用的开发更加模块化、可维护和可扩展。</p><h2 id="如何形象的理解-mybatis"><a href="#如何形象的理解-mybatis" class="headerlink" title="如何形象的理解 mybatis ?"></a>如何形象的理解 mybatis ?</h2><blockquote><p>Java 操作数据库的框架，持久层框架，对 jdbc 的封装</p></blockquote><p>让我们用一个类比来形象地理解MyBatis。</p><p>假设你是一个图书管理员，负责管理图书馆的图书和借阅记录。</p><p>在没有MyBatis的情况下，你可能需要手动管理图书和借阅记录的存储、查询和更新。这意味着你需要编写大量的SQL语句来执行数据库操作，并处理与数据库的连接、事务等细节。这样的工作可能会非常繁琐和复杂。</p><p>现在，假设你有一个智能助手，他帮助你<strong>自动化处理图书和借阅记录的管理</strong>。这就是MyBatis的作用。</p><p>在这个比喻中：</p><ul><li>你是图书管理员，负责处理图书和借阅记录的管理，即数据访问对象（DAO）。</li><li>图书和借阅记录是数据库中的数据，需要进行存储、查询和更新。</li><li>MyBatis框架则扮演了一个智能助手的角色，负责处理与数据库的交互和操作。</li><li>框架提供了一种便捷的方式来映射数据库表和<code>Java</code>对象，并提供了一些SQL执行和结果映射的功能。</li></ul><p>使用MyBatis，你可以通过简单的配置文件和注解来定义SQL语句和参数映射，而无需手动编写大量的SQL语句。框架会自动处理与数据库的连接、事务和结果集的映射，让你更专注于业务逻辑的实现。</p><p>总而言之，MyBatis就像是一个智能助手，帮助你简化和自动化与数据库的交互和操作。它减少了手动编写SQL语句的工作量，提供了便捷的数据访问方式，并帮助你更好地组织和管理数据库操作的代码。使用MyBatis，你可以更轻松地进行数据库操作，并提供高效和可维护的数据访问层。</p><h2 id="如何形象的理解-mybatis-plus"><a href="#如何形象的理解-mybatis-plus" class="headerlink" title="如何形象的理解 mybatis - plus ?"></a>如何形象的理解 mybatis - plus ?</h2><blockquote><p>对 mybatis 的增强，不用写 sql 也能实现增删改查</p></blockquote><p>让我们用一个类比来形象地理解MyBatis-Plus。</p><p>假设你是一位室内设计师，负责设计客户的家居装修方案。</p><p>在没有MyBatis-Plus的情况下，你可能需要从头开始设计和实施每个客户的装修方案。这意味着你需要考虑并编写各种细节，如房间布局、材料选择、色彩搭配等。这样的工作可能会非常繁琐和耗时。</p><p>现在，假设你有一个装修助手，他为你提供了一套标准化的装修方案和设计模板。这就是MyBatis-Plus的作用。</p><p>在这个比喻中：</p><ul><li>你是室内设计师，负责设计和实施装修方案，即数据访问对象（DAO）。</li><li>客户是数据库中的表，每个客户对应一张表，需要进行增删改查等操作。</li><li>MyBatis-Plus框架则扮演了一个装修助手的角色，提供了一系列标准化的操作和设计模板。</li><li>框架提供了一种简单的方式来定义实体类和数据库表的映射关系，并提供了一些通用的数据访问功能。</li></ul><p>使用MyBatis-Plus，你可以通过简单的注解和配置来定义实体类和数据库表的映射关系，而无需手动编写繁琐的SQL语句。框架会自动处理与数据库的连接、事务和CRUD操作，让你更专注于业务逻辑的实现。</p><p>总而言之，MyBatis-Plus就像是一个装修助手，为你提供了一套标准化的操作和设计模板。它简化了数据访问层的开发过程，提供了便捷的数据访问方式，并帮助你更好地组织和管理数据库操作的代码。使用MyBatis-Plus，你可以更轻松地进行数据库操作，并提供高效和可维护的数据访问层。</p><h2 id="如何形象的理解-springboot"><a href="#如何形象的理解-springboot" class="headerlink" title="如何形象的理解 springboot ?"></a>如何形象的理解 springboot ?</h2><blockquote><p>快速启动 &#x2F; 快速集成项目。不用自己管理 spring 配置，不用自己整合各种框架</p></blockquote><p>让我们用一个类比来形象地理解Spring Boot。</p><p>假设你是一位厨师，需要准备一道复杂的菜肴。</p><p>在没有Spring Boot的情况下，你需要从头开始购买食材、准备厨房、研究菜谱、调整烹饪参数等。这意味着你需要花费大量的时间和精力来完成每个环节，才能最终完成菜肴的制作。</p><p>现在，假设你有一套现成的厨房设备和标准化的食谱，这就是Spring Boot的作用。</p><p>在这个比喻中：</p><ul><li>你是厨师，负责设计和制作菜肴，即应用程序的开发者。</li><li>菜肴是应用程序，需要进行配置、开发和部署等操作。</li><li>Spring Boot框架则扮演了一个现成的厨房设备和标准化的食谱的角色，提供了一套预定义的配置和开发规范。</li><li>框架帮助你简化了应用程序的搭建和开发过程，提供了自动配置、内嵌服务器、依赖管理等功能。</li></ul><p>使用Spring Boot，你可以通过简单的配置和约定来快速搭建和开发应用程序，无需手动处理繁琐的配置和依赖管理。框架会自动处理与服务器的集成、配置的加载和管理，让你更专注于业务逻辑的实现。</p><p>总而言之，Spring Boot就像是一个现成的厨房设备和标准化的食谱，帮助你快速搭建和开发应用程序。它简化了应用程序的搭建和开发过程，提供了自动化的配置和依赖管理，让你能够更轻松地构建高效和可维护的应用程序。</p><blockquote><p>Spring Boot是Spring的一个子项目，旨在简化Spring应用程序的搭建和开发过程，通过自动配置和约定大于配置的原则，提供了一套预定义的规范和配置，使得开发者能够更快速地创建独立的、自包含的应用程序。</p></blockquote><h2 id="什么是-junit-单元测试库"><a href="#什么是-junit-单元测试库" class="headerlink" title="什么是 junit 单元测试库?"></a>什么是 junit 单元测试库?</h2><p>JUnit是一个Java单元测试库，用于编写和执行单元测试。它提供了一组用于编写测试用例的注解和断言方法，可以帮助开发者进行自动化的单元测试。</p><p>JUnit的主要作用是帮助开发者验证代码的正确性和稳定性。通过编写单元测试用例，开发者可以针对代码的不同模块、方法或类编写测试代码，用于验证其预期行为是否符合预期。单元测试可以帮助开发者发现和修复代码中的bug，减少代码出错的可能性，并提高代码的质量和可维护性。</p><p>JUnit提供了一些常用的注解，如<code>@Test</code>用于标记测试方法，<code>@Before</code>和<code>@After</code>用于在测试方法执行前后执行一些初始化和清理操作，<code>@BeforeClass</code>和<code>@AfterClass</code>用于在所有测试方法执行前后执行一次初始化和清理操作。此外，JUnit还提供了一系列的断言方法，如<code>assertEquals</code>、<code>assertTrue</code>、<code>assertFalse</code>等，用于验证测试结果是否符合预期。</p><p>使用JUnit，开发者可以编写简洁、可重复运行的测试用例，并通过运行JUnit测试来自动执行这些测试用例，获取测试结果。这样可以提高开发效率，减少手动测试的工作量，并保证代码的可靠性和稳定性。</p><p>总之，JUnit是一个Java单元测试库，它提供了注解和断言方法，用于编写和执行单元测试，帮助开发者验证代码的正确性和稳定性，并提高代码的质量和可维护性。</p><h2 id="关于用户登录状态管理的详细过程："><a href="#关于用户登录状态管理的详细过程：" class="headerlink" title="关于用户登录状态管理的详细过程："></a>关于用户登录状态管理的详细过程：</h2><ol><li><p>客户端与服务器建立连接后，服务器为客户端创建一个会话（session），并返回会话的标识符（session ID）给客户端。这个会话可以是匿名会话，表示客户端尚未登录。</p></li><li><p>当用户成功登录时，服务器会为该用户创建一个具有用户信息的会话对象，并将会话对象存储在服务器端。通常会将用户信息存储在会话对象的属性中，例如，将用户ID、用户名等信息存储为会话属性。</p></li><li><p>服务器将会话的标识符（session ID）发送给客户端，并要求客户端将其存储为一个 cookie。这个 cookie 的作用是在客户端保存会话标识符，以便在后续的请求中携带该会话标识符。</p></li><li><p>客户端接收到服务器返回的会话标识符后，将其存储为 cookie，保存在客户端浏览器中。</p></li><li><p>当客户端再次向服务器发送请求时，在请求头中会包含该域名下的所有 cookie 信息，包括会话标识符。</p></li><li><p>服务器接收到请求后，从请求头中提取出会话标识符，通过该标识符在服务器端查找对应的会话对象。</p></li><li><p>服务器根据会话标识符找到对应的会话对象后，可以从会话对象中获取存储的用户信息，如用户的登录名等。</p></li></ol><p>总结：通过将会话标识符存储在客户端的 cookie 中，客户端在后续的请求中携带该会话标识符，使服务器能够识别客户端，并通过会话对象管理用户的登录状态和其他相关信息。</p><p>需要注意的是，上述过程是一种常见的用户登录状态管理方式，但实际上，还有其他方法可以实现用户登录状态的管理，如使用 JSON Web Token (JWT) 等。具体的实现方式可能因框架和技术选型而有所差异。</p><h2 id="简单说明cookie和session"><a href="#简单说明cookie和session" class="headerlink" title="简单说明cookie和session"></a><strong>简单说明cookie和session</strong></h2><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcode">🪔 以最常见的登陆案例讲解cookie的使用过程：<br>（<span class="hljs-number">1</span>）首先用户在客户端浏览器向服务器首次发起登陆请求<br>（<span class="hljs-number">2</span>）登陆成功后，服务端会把登陆的用户信息设置在cookie 中，并将cookie返回给客户端浏览器<br>（<span class="hljs-number">3</span>）客户端浏览器接收到 cookie 请求后，会把 cookie 保存到本地<span class="hljs-comment">(可能是内存，也可能是磁盘，看具体使用情况而定)</span><br>（<span class="hljs-number">4</span>）以后再次访问该 web 应用时，客户端浏览器就会把本地的 cookie 带上，这样服务端就能根据 cookie 获得用户信息了<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">🪔 同样以登陆案例为例子讲解 <span class="hljs-keyword">session</span> 的使用过程：<br>（<span class="hljs-number">1</span>）首先用户在客户端浏览器发起登陆请求<br>（<span class="hljs-number">2</span>）登陆成功后，服务端会把用户信息保存在服务端，并返回一个唯一的 <span class="hljs-keyword">session</span> 标识给客户端浏览器。<br>（<span class="hljs-number">3</span>）客户端浏览器会把这个唯一的 <span class="hljs-keyword">session</span> 标识保存在起来<br>（<span class="hljs-number">4</span>）以后再次访问 web 应用时，客户端浏览器会把这个唯一的 <span class="hljs-keyword">session</span> 标识带上，这样服务端就能根据这个唯一标识找到用户信息。<br></code></pre></td></tr></table></figure><p><strong>看到这里可能会引起疑问：把唯一的 session 标识返回给客户端浏览器，然后保存起来，以后访问时带上，这难道不是 cookie 吗？</strong></p><blockquote><p>没错，session 只是一种会话机制，在许多 web 应用中，session 机制就是通过 cookie 来实现的。也就是说它只是使用了 cookie 的功能，并不是使用 cookie完成会话保存。与 cookie 在保存客户端保存会话的机制相反，session 通过 cookie 的功能把会话信息保存到了服务端。</p></blockquote><p><strong>session和cookie有什么区别？</strong></p><ol><li><p>cookie 是浏览器提供的一种缓存机制，它可以用于维持客户端与服务端之间的会话</p></li><li><p>session 指的是维持客户端与服务端会话的一种机制，它可以通过 cookie 实现，也可以通过别的手段实现。</p></li><li><p>如果用 cookie 实现会话，那么会话会保存在客户端浏览器中</p></li><li><p>而 session 机制提供的会话是保存在服务端的。</p></li></ol><p><strong>举个小例子说明Cookie和Session之间的区别和联系</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">🦥 <br>假如一个咖啡店有喝五杯赠一杯咖啡的优惠，但是一次性消费<span class="hljs-number">5</span>杯咖啡的客人很少，这时就需要某种方式来记录某位顾客的消费数量。无外乎下面的几种方案：<br><span class="hljs-number">1</span>、该店的店员很厉害，能记住每位顾客的消费数量，只要顾客一走进咖啡店，店员就知道该怎么对待了。这种做法就是协议本身支持状态。但是<span class="hljs-keyword">http</span>协议本身是无状态的。<br><span class="hljs-number">2</span>、发给顾客一张卡片，上面记录着消费的数量，一般还有个有效期限。每次消费时，如果顾客出示这张卡片，则此次消费就会与以前或以后的消费相联系起来。这种做法就是在客户端保持状态，也就是cookie，顾客就相当于浏览器。<br><span class="hljs-number">3</span>、发给顾客一张会员卡，除了卡号之外什么信息也不纪录，每次消费时，如果顾客出示该卡片，则店员在店里的记录本上找到这个卡号对应的记录添加一些消费信息。这种做法就是在服务器端保持状态。<br></code></pre></td></tr></table></figure><h2 id="正向代理和反向代理的区别是什么"><a href="#正向代理和反向代理的区别是什么" class="headerlink" title="正向代理和反向代理的区别是什么?"></a>正向代理和反向代理的区别是什么?</h2><p><a href="https://www.cnblogs.com/taostaryu/p/10547132.html">原文</a></p><blockquote><p>代理其实就是一个中介，A和B本来可以直连，中间插入一个C，C就是中介。<br>刚开始的时候，代理多数是帮助内网client访问外网server用的<br>后来出现了反向代理，”反向”这个词在这儿的意思其实是指方向相反，即代理将来自外网客户端的请求转发到内网服务器，从外到内.</p></blockquote><h4 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h4><p>正向代理类似一个跳板机，代理访问外部资源 .</p><p>比如我们国内访问谷歌，直接访问访问不到，我们可以通过一个正向代理服务器，请求发到代理服，代理服务器能够访问谷歌，这样由代理去谷歌取到返回数据，再返回给我们，这样我们就能访问谷歌了 .</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202306181011210.png" alt="image-20230618101113110"></p><p><strong>正向代理的用途：</strong></p><ol><li>访问原来无法访问的资源，如google</li><li>可以做缓存，加速访问资源</li><li>对客户端访问授权，上网进行认证</li><li>代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息</li></ol><h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><p>反向代理（Reverse Proxy）实际运行方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202306181011725.png" alt="image-20230618101124689"></p><p><strong>反向代理的作用：</strong></p><ol><li>保证内网的安全，阻止web攻击，大型网站，通常将反向代理作为公网访问地址，Web服务器是内网 . </li><li>负载均衡，通过反向代理服务器来优化网站的负载</li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>正向代理即是客户端代理, 代理客户端, 服务端不知道实际发起请求的客户端.</strong></p><p><strong>反向代理即是服务端代理, 代理服务端, 客户端不知道实际提供服务的服务端</strong></p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202306181014100.png" alt="image-20230618101447052"></p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202306181013811.png" alt="image-20230618101318766"></p><h2 id="java项目中target文件是什么文件"><a href="#java项目中target文件是什么文件" class="headerlink" title="java项目中target文件是什么文件?"></a>java项目中target文件是什么文件?</h2><p><code>target</code> 文件夹通常是在构建过程中由构建工具生成的默认输出目录，例如 Maven 或 Gradle。在 Maven 项目中，<code>target</code> 文件夹用于存储编译后的类文件、资源文件和生成的构建产物（如 JAR 文件）等。</p><p>当你执行 Maven 的构建命令（如 <code>mvn package</code>）时，Maven 会将项目的源代码编译成字节码，并将编译后的类文件和其他资源文件输出到 <code>target</code> 文件夹中。此外，构建工具还会在 <code>target</code> 文件夹中生成其他与构建过程相关的临时文件和日志文件。</p><p>通常情况下，<code>target</code> 文件夹的内容应该是可以被忽略的，不应该被版本控制系统（如 Git）所跟踪。这是因为 <code>target</code> 文件夹的内容可以通过重新构建项目来生成，而不需要将生成的文件包含在版本控制中。</p><p>需要注意的是，<code>target</code> 文件夹的名称可以在 Maven 或 Gradle 的配置文件中进行自定义，但通常情况下，<code>target</code> 是默认的输出目录名称。</p><h2 id="java项目中controller文件的作用是什么"><a href="#java项目中controller文件的作用是什么" class="headerlink" title="java项目中controller文件的作用是什么?"></a>java项目中controller文件的作用是什么?</h2><p>在Java项目中，控制器（Controller）的作用是处理客户端发起的请求并返回响应。它充当了应用程序的入口点，协调不同的组件来完成特定的业务逻辑。控制器主要负责以下几个方面的工作：</p><ol><li><p><strong>接收请求</strong>：控制器监听特定的URL路径或请求方法，并接收来自客户端的请求。它充当了请求的入口，接收并解析请求参数、路径、请求体等信息。</p></li><li><p><strong>处理业务逻辑</strong>：一旦接收到请求，控制器会调用相应的服务（Service）或业务逻辑组件来处理具体的业务逻辑。它可以从数据库、外部服务或其他组件中获取数据，并对数据进行处理、转换或验证。</p></li><li><p><strong>调用服务层</strong>：控制器通常与服务层（Service Layer）进行交互，通过依赖注入或手动创建实例来调用服务层提供的方法。服务层负责封装业务逻辑，处理数据持久化、事务管理、业务规则等操作。</p></li><li><p><strong>返回响应</strong>：控制器根据请求处理的结果生成相应的响应，并将其返回给客户端。响应可以是HTML页面、JSON数据、文件下载等形式。控制器负责将响应数据封装成适当的格式，并设置响应头和状态码。</p></li><li><p><strong>路由和URL映射</strong>：控制器根据不同的URL路径和请求方法来映射到相应的处理方法。它通过使用路由配置或注解来定义URL与处理方法之间的映射关系，以便将请求正确地分发到对应的处理方法。</p></li><li><p><strong>控制流程和验证</strong>：控制器可以处理用户输入的验证和数据校验，确保数据的合法性和完整性。它还可以根据业务需求决定请求的流程，例如重定向、转发或错误处理等。</p></li></ol><p>总之，控制器在Java项目中起着连接用户界面、业务逻辑和数据持久化层的桥梁作用。它接收并处理请求，协调其他组件完成特定的业务功能，并将处理结果返回给客户端。控制器的设计良好与否对于项目的可维护性、可测试性和灵活性具有重要影响。</p><h2 id="java项目里mapper的作用是什么"><a href="#java项目里mapper的作用是什么" class="headerlink" title="java项目里mapper的作用是什么?"></a>java项目里mapper的作用是什么?</h2><p>在Java项目中，Mapper（或称为数据访问对象，DAO）的作用是封装对数据库的访问操作。它充当了应用程序和数据库之间的桥梁，负责执行数据库查询、更新、插入和删除等操作。Mapper的主要作用如下：</p><ol><li><p><strong>数据库访问</strong>：Mapper负责与数据库进行交互，执行SQL语句或调用数据库的API来完成数据的读取、写入和修改操作。它封装了对数据库的底层访问细节，使开发人员可以以面向对象的方式操作数据库，而无需直接编写原始的SQL语句。</p></li><li><p><strong>对象关系映射</strong>（ORM）：Mapper将数据库中的表和实体对象进行映射，实现了对象与关系数据库之间的转换。它通过配置或注解定义实体类和数据库表之间的映射关系，使开发人员可以以面向对象的方式操作数据，而不需要关注数据库的具体实现细节。</p></li><li><p><strong>数据库事务管理</strong>：Mapper可以处理数据库事务，确保一组数据库操作要么全部成功提交，要么全部回滚。它提供了事务的开始、提交和回滚等操作，使开发人员能够在一致的状态下操作数据库，保持数据的完整性和一致性。</p></li><li><p><strong>查询优化和性能调优</strong>：Mapper可以通过编写高效的SQL语句或使用数据库的特定特性来优化查询性能。它可以利用数据库的索引、缓存机制、分页查询等功能来提高数据访问的效率，减少数据库的负载和响应时间。</p></li><li><p><strong>数据库访问的抽象层</strong>：Mapper提供了对数据库访问的高层抽象，使开发人员能够以面向对象的方式对数据进行操作，而不必关注数据库的细节。它提供了一组通用的CRUD（创建、读取、更新、删除）方法，简化了对数据的操作。</p></li></ol><p>总之，Mapper在Java项目中起着与数据库交互的角色，负责执行数据库操作、实现对象与数据库之间的映射以及提供事务管理等功能。它使开发人员能够以面向对象的方式操作数据库，提高了开发效率和代码的可维护性。通过使用Mapper，可以将数据库操作与业务逻辑解耦，提供了灵活性和可扩展性，使得数据访问更加方便和高效。</p><h2 id="IService和BaseMapper它们的区别是什么"><a href="#IService和BaseMapper它们的区别是什么" class="headerlink" title="IService和BaseMapper它们的区别是什么?"></a>IService<T>和BaseMapper<T>它们的区别是什么?</h2><p><code>IService&lt;T&gt;</code> 和 <code>BaseMapper&lt;T&gt;</code> 是 MyBatis-Plus 框架中的两个核心接口，它们在功能和作用上有一些区别。</p><p><code>IService&lt;T&gt;</code> 接口是用于定义通用的业务操作方法的接口，提供了对数据库表进行常见的增删改查操作的方法定义。它包含了一系列的方法，如保存实体对象、删除记录、更新记录、查询记录等。开发人员可以通过实现 <code>IService&lt;T&gt;</code> 接口或继承该接口来自定义业务逻辑操作。</p><p><code>BaseMapper&lt;T&gt;</code> 接口是 MyBatis-Plus 框架提供的基础映射器接口，用于定义数据库表的基本操作方法。它继承了 MyBatis 中的 <code>Mapper&lt;T&gt;</code> 接口，并额外添加了一些常见的数据库操作方法，如插入记录、删除记录、更新记录、查询记录等。<code>BaseMapper&lt;T&gt;</code> 接口提供了对数据库表进行基本操作的能力。</p><p>区别总结如下：</p><ul><li><code>IService&lt;T&gt;</code> 是定义通用业务操作方法的接口，用于封装和定义业务逻辑，提供了更高层次的抽象，使得业务逻辑更加简洁和易于维护。</li><li><code>BaseMapper&lt;T&gt;</code> 是基础映射器接口，用于定义数据库表的基本操作方法，提供了对数据库的增删改查能力。</li><li><code>IService&lt;T&gt;</code> 可以自定义业务逻辑方法，对数据库操作进行封装，而 <code>BaseMapper&lt;T&gt;</code> 主要提供了一些基本的数据库操作方法。</li><li><code>IService&lt;T&gt;</code> 可以根据具体业务需求进行扩展和定制，而 <code>BaseMapper&lt;T&gt;</code> 主要用于执行基本的数据库操作。</li></ul><p>在实际开发中，通常会同时使用 <code>IService&lt;T&gt;</code> 和 <code>BaseMapper&lt;T&gt;</code> 接口。<code>IService&lt;T&gt;</code> 可以作为业务层的接口，定义具体业务操作方法，而 <code>BaseMapper&lt;T&gt;</code> 则作为数据访问层的接口，提供基本的数据库操作方法。这样可以将业务逻辑和数据访问操作进行解耦，并提高代码的可读性和可维护性。</p><h2 id="Autowired注解的作用是什么"><a href="#Autowired注解的作用是什么" class="headerlink" title="@Autowired注解的作用是什么?"></a>@Autowired注解的作用是什么?</h2><p><code>@Autowired</code> 注解是 Spring 框架提供的依赖注入注解，用于自动装配对象。</p><p>作用如下：</p><ol><li>自动装配依赖对象：<code>@Autowired</code> 注解可以自动将标注的属性、构造函数或方法参数与容器中匹配的 bean 进行关联，完成依赖对象的注入。</li><li>简化配置：通过 <code>@Autowired</code> 注解，可以省去手动配置依赖对象的步骤，由 Spring 容器自动查找并注入所需的对象。</li><li>解决对象之间的耦合：通过依赖注入，对象之间的关系由容器管理，减少了对象之间的直接依赖，降低了耦合性，提高了代码的灵活性和可维护性。</li><li>提高代码的可测试性：使用依赖注入可以方便进行单元测试，可以轻松替换依赖对象或使用模拟对象进行测试。</li></ol><p>要注意的是，使用 <code>@Autowired</code> 注解进行自动装配时，需要保证容器中存在匹配的 bean 对象。如果存在多个匹配的 bean 对象，可以结合使用 <code>@Qualifier</code> 注解或通过指定 bean 的名称进行限定，以确定要注入的具体对象。</p><p>另外，<code>@Autowired</code> 注解可以用于字段、构造函数、Setter 方法以及一些特殊的注入场景，例如 <code>@Autowired</code> 与 <code>@Qualifier</code> 的组合使用，以及与 <code>@Value</code> 注解一起使用等。</p><p>当用户使用网上零食商城的零食分类模块时，以下是一个具体的流程示例：</p><ol><li>用户进入网上零食商城的零食分类页面。</li><li>用户提供分类条件，例如选择特定的食品类别、价格范围或品牌等。</li><li>用户点击”搜索”或类似的按钮，将输入条件传递给零食分类模块。</li><li>零食分类模块接收用户输入的条件。</li><li>模块开始处理用户输入的条件，进行以下步骤：<ul><li>分析用户选择的食品类别、价格范围或品牌等条件。</li><li>查询数据库或调用相关接口，获取与用户条件匹配的零食列表。</li><li>对零食列表进行筛选和排序，根据用户的排序要求或其他标准进行处理。</li><li>生成经过分类和排序的零食列表。</li></ul></li><li>零食分类模块将处理结果返回给用户界面。</li><li>用户界面展示分类结果，包括零食的名称、价格、图片等信息（O1）。</li><li>用户可以浏览所展示的零食列表，查看详细信息，并选择感兴趣的零食进行购买。</li><li>用户可以选择特定的分类结果，例如点击特定的分类标签。</li><li>用户界面将用户选择的分类结果传递给零食分类模块。</li><li>模块接收用户选择的分类结果并进行处理，展示与选择分类匹配的零食列表（O2）。</li><li>用户界面展示根据</li><li>用户选择的分类结果所筛选出的零食列表，供用户浏览和购买。</li><li>用户可以继续浏览和购买感兴趣的零食，或者返回重新选择分类条件。</li></ol>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>费曼学习法</title>
    <link href="/2023/06/10/%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95/"/>
    <url>/2023/06/10/%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="关于费曼学习法"><a href="#关于费曼学习法" class="headerlink" title="关于费曼学习法"></a>关于费曼学习法</h2><blockquote><p>前两天偶然间了解到了费曼学习法, 算是拓宽了我对学习方法的认知. </p><p>它可以简化为四个单词 </p></blockquote><p><code>Concept</code> (概念) – <code>Teach</code> (教给别人) – <code>Review</code> (回顾) – <code>Simplify</code> (简化)</p><ol><li>第一步 : 假装把一个知识(概念) 教给一个小孩子 .</li></ol><p>尽量用最基础的词汇, 以使得这些小孩子刚好能理解这些基本的概念和知识, 当你卡壳了, 也就是不知道如何解释某个概念或与其它知识的联系的时候 – 预示着学习的机会到来了. </p><ol start="2"><li>第二步 : 回顾</li></ol><p>你已经发现了你大脑知识库的边缘, 懂得自己能力的界限也是一种能力. 你需要回到自己的原始材料, 重新学习, 直到你可以用基本的术语解释这一概念. </p><ol start="3"><li>第三步: 将语言条理化 , 简化</li></ol><p>要保证你的手上有一套自己的手写笔记 , 检查一下确保自己没有从原材料中借用任何行话. 请阅读一遍自己的手写笔记 , 如果听起来比较混乱 , 这意味着你还需要更深入的理解该领域 . 这时候你需要重新回到第二步 —— 一直重复直到你的手写笔记解释得通俗易懂且有条理性 . </p><ol start="4"><li>第四步(可选) : 传授</li></ol><p>如果你真的确保你的理解没什么问题, 检测知识最终的途径就是你能有能力把它传播给另一个人 , 如果没有这样一个具象的人 , 那你可以将自己的笔记分享出去 , 通过大家的反馈以使得自己对知识的理解更加通透. </p><blockquote><p>昨天基本上一整天时间都花在搭建博客上了, 这个学习方法也没有得到应用, 从今儿开始, 尝试这种学习方法~🎆</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>日常琐碎</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习方法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的第一篇博客</title>
    <link href="/2023/06/09/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/06/09/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="我的第一篇博客"><a href="#我的第一篇博客" class="headerlink" title="我的第一篇博客"></a>我的第一篇博客</h1><blockquote><p>分享琐碎</p></blockquote><p>忙里偷闲, 或者说闲来无事吧, 实际上, 时间已经来到期末, 可是呢, 我还是保留着对技术的疯狂热情, 搭建这个博客是因为偶然间在星球冲浪时, 看见一位大佬所写的hexo搭建博客系列. 正是这一契机让我花了大半天时间搞了这一个博客.</p><p>其实之前也有花时间搭过一个博客, 是通过 <code>VuePress</code> 搭建的 </p><p>(刚刚搞了好久的图床哈哈哈哈哈哈哈哈哈哈, 主要是通过 阿里云 + Pikgo + Typora 构建的)<br><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202306092321545.png" alt="image-20230609232105109"></p><p>这界面还是略显花哨 , 相比呢以下界面就显得非常滴简约好看</p><p><img src="https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202306092322286.png" alt="image-20230609232220960"> </p><p>话不多说, 准备优化博客咯 —— hh</p>]]></content>
    
    
    <categories>
      
      <category>日常琐碎</category>
      
    </categories>
    
    
    <tags>
      
      <tag>感想</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
